---
alwaysApply: true
description: "Critical development rules - always apply these for safety and consistency"
globs: ["**/*"]
priority: 1
version: "--scope=docs"
lastUpdated: "2025-07-21"
relatedFiles: ["AI_REFERENCE.md", "AI_SESSION_STARTER.md"]
---

# Critical Rules - Always Apply

## üéØ Core Context

### **User Profile**
- **Beginner programmer** with ADHD/depression
- **Windows 11** environment, PowerShell syntax required
- **Personal project** - building mental health assistant for own use
- **Values learning and efficiency** over being right
- **Will miss things** and fail to consider things - relies on AI for thoroughness
- **Prefers correction** over inefficient approaches

### **Project Purpose**
Building a personal mental health assistant that helps manage executive functioning deficits and health needs, staying connected to life priorities and goals, providing motivation and hope for the future.

### **Project Vision**
- **Communication-First Design**: All user interactions through channels (Discord, email, etc.)
- **AI-Powered Interface**: Users interact primarily through AI chatbot with optional menus
- **No Required User UI**: Admin interface exists for management, but users never need separate UI
- **Channel-Agnostic Architecture**: Features work across all communication channels

## üõ°Ô∏è Core Development Rules

### **Safety First**
- **Test**: `python run_mhm.py` must work after changes
- **Backup**: `Copy-Item -Path "." -Destination "../backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')" -Recurse`
- **Incremental**: Make small, tested changes
- **Document**: Update `CHANGELOG_DETAIL.md` and `AI_CHANGELOG` for all changes
- **Dependencies**: Update `requirements.txt` for new dependencies

### **Key Files**
- `run_mhm.py` - Main entry point
- `core/service.py` - Background service
- `ui/ui_app_qt.py` - Admin interface (admin only)
- `core/config.py` - Configuration
- `core/file_operations.py`, `core/user_management.py`, `core/message_management.py`, `core/schedule_management.py`, `core/response_tracking.py`, `core/service_utilities.py`, `core/validation.py`
- `bot/` - Communication channel implementations
- `data/users/` - User data

### **Development Workflow**
1. **Test current state**: `python run_mhm.py`
2. **Create backup**: PowerShell backup command
3. **Make incremental changes**
4. **Test after each change**
5. **Update documentation**: `CHANGELOG_DETAIL.md` and `AI_CHANGELOG` 

## üí¨ Communication Guidelines

### **Response Style**
- **Simple explanations** - focus on one concept at a time
- **Step-by-step instructions** - break complex tasks into steps
- **Explain WHY** - always explain why changes are needed
- **Be patient and encouraging** - acknowledge progress and successes
- **Question assumptions** - suggest better alternatives when appropriate

### **Beginner Programmer Support**
**CRITICAL**: User prefers correction over inefficient approaches.

**When User Suggests Something:**
- Question their goals and reasoning
- Suggest better alternatives if you see them
- Educate about relevant concepts they might not know
- Point out potential problems or inefficiencies
- Ask clarifying questions when unsure

**Key Questions to Ask:**
- "What's your goal with this approach?"
- "Are you aware of [alternative]?"
- "What's driving this decision?"
- "Have you considered [potential issue]?"
- "Would you like me to explain [concept]?"

## üéØ Development Approach

### **Thoroughness**
- Always be thorough and check for consistency
- If changing a function or moving a file, check all references
- Update all related places appropriately
- Repeat as needed to ensure consistency
- You can always ask if deviating from a rule would be better

### **Safety First**
- Backup before major changes
- Test incrementally
- Make small, tested changes
- Explain the reasoning behind suggestions
- Prioritize reliability over cleverness

## üîÑ Flexibility
You can always ask if you think deviating from a rule would be a better option.

## üö´ Legacy Code Standards

### **User's Legacy Code Preferences**
The user has **strong preferences** about legacy and backward compatibility code:

**Core Principle**: "I always prefer the code to be cleaner and more honest about what it actually needs. Backwards compatibility is fine, if it's necessary, clearly marked, and usage logged for future removal."

**Requirements for ANY Legacy Code:**
1. **Necessary**: Must serve an actual purpose, not just defensive programming
2. **Clearly Marked**: Must have explicit `LEGACY COMPATIBILITY` comments
3. **Usage Logged**: Must log warnings when legacy code paths are accessed
4. **Removal Plan**: Must have documented removal plan with timeline
5. **Monitoring**: Must monitor usage and remove when no longer needed

**When Encountering Legacy Code:**
- **Question necessity**: "Is this actually needed or just defensive programming?"
- **Add proper marking**: Include `LEGACY COMPATIBILITY` headers and removal plans
- **Add usage logging**: Log warnings when legacy interfaces are accessed
- **Document removal**: Create clear removal plans with timelines
- **Monitor and remove**: Track usage and remove when safe

**Legacy Code Documentation Format:**
```python
# LEGACY COMPATIBILITY: [Brief description]
# TODO: Remove after [specific condition]
# REMOVAL PLAN:
# 1. [Step 1]
# 2. [Step 2]
# 3. [Step 3]
```

**TESTING**: If you can see this rule, please confirm by saying "I can see the critical.mdc rule"

