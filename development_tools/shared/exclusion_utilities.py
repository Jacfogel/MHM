#!/usr/bin/env python3
# TOOL_TIER: core

"""
Shared Exclusion Utilities for Analysis Tools

This module provides standardized exclusion utilities that can be reused
across all development tools to ensure consistent function and code filtering.

These utilities complement the file-level exclusions in standard_exclusions.py
by providing function-level and code-level exclusion logic.

Usage:
    from development_tools.shared.exclusion_utilities import (
        is_generated_file,
        is_generated_function,
        is_special_python_method,
        is_test_function
    )

    if is_generated_file(file_path):
        # Skip this file
    if is_generated_function(func_name):
        # Skip this function
"""

from typing import Optional
from core.error_handling import handle_errors
from core.logger import get_component_logger

logger = get_component_logger("development_tools")

# Default test keywords (can be overridden via config)
_DEFAULT_TEST_KEYWORDS = ["test_", "test"]


def _get_test_keywords():
    """Get test keywords from config or return defaults."""
    try:
        from .. import config

        config.load_external_config()
        function_config = config.get_analyze_functions_config()
        return function_config.get("test_keywords", _DEFAULT_TEST_KEYWORDS)
    except (ImportError, AttributeError):
        return _DEFAULT_TEST_KEYWORDS


@handle_errors("checking if file is generated", default_return=False)
def is_generated_file(file_path: str) -> bool:
    """
    Determine if a file is auto-generated and should be excluded from analysis.

    This function identifies:
    - Files explicitly marked as generated in header comments
    - Files located in generated directories
    - Files with auto-generated naming patterns
    - PyQt auto-generated files

    Args:
        file_path: Path to the file

    Returns:
        True if the file should be excluded from analysis
    """

    # --- Detect explicit "generated" markers in file header ---
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            first_lines = "".join(f.readlines()[:10]).lower()
            if (
                "generated" in first_lines
                or "auto-generated" in first_lines
                or "generated by" in first_lines
            ):
                return True
    except Exception:
        # If the file can't be read, do not assume it's generated
        pass

    normalized_path = file_path.replace("\\", "/").lower()

    # Exclude files in generated directories
    if "/generated/" in normalized_path:
        return True

    # Exclude PyQt auto-generated files
    if "_pyqt.py" in normalized_path:
        return True

    # Exclude files with auto-generated patterns in name
    auto_generated_file_patterns = [
        "_ui.py",  # UI generated files
        "_generated.py",  # Explicitly generated files
        "_auto.py",  # Auto-generated files
    ]

    for pattern in auto_generated_file_patterns:
        if normalized_path.endswith(pattern):
            return True

    return False


@handle_errors("checking if function is generated", default_return=False)
def is_generated_function(func_name: str) -> bool:
    """
    Determine if a function name matches auto-generated patterns.

    This function identifies:
    - PyQt-generated UI functions
    - Functions with common auto-generated naming conventions

    Args:
        func_name: Name of the function

    Returns:
        True if the function should be excluded from analysis
    """

    if not func_name:
        return False

    # Exact matches for known generated functions
    exact_generated_names = {
        "setupUi",  # PyQt UI setup
        "retranslateUi",  # PyQt translation
        "setup_ui",  # Alternative PyQt setup
        "retranslate_ui",  # Alternative PyQt translation
    }

    if func_name in exact_generated_names:
        return True

    # Substring-based patterns
    generated_name_patterns = [
        "setup_ui_",  # UI setup helpers
        "retranslate_ui_",  # UI translation helpers
        "_generated_",  # Generated functions
        "_auto_",  # Auto-generated helpers
    ]

    for pattern in generated_name_patterns:
        if pattern in func_name:
            return True

    return False


@handle_errors("checking if method is special Python method", default_return=False)
def is_special_python_method(func_name: str, complexity: Optional[int] = None) -> bool:
    """
    Determine if a function is a special Python method that should be excluded from undocumented count.

    Special methods are Python's "magic methods" that have well-defined behavior
    and typically don't need documentation. However, context managers (__enter__, __exit__)
    should be documented as they define custom behavior.

    Simple __init__ methods (complexity < 20) are also excluded as they typically
    just assign parameters to instance variables.

    Args:
        func_name: Name of the function
        complexity: Optional complexity score (used for __init__ exclusion)

    Returns:
        True if the function should be excluded from undocumented count
    """
    # Special methods that should be excluded from undocumented count
    special_methods = {
        "__new__",  # Singleton patterns
        "__post_init__",  # Dataclass post-init
        "__repr__",  # String representation
        "__str__",  # String conversion
        "__hash__",  # Hashing
        "__eq__",  # Equality comparison
        "__lt__",
        "__le__",
        "__gt__",
        "__ge__",  # Comparison methods
        "__len__",  # Length
        "__bool__",  # Boolean conversion
        "__call__",  # Callable
        "__getitem__",
        "__setitem__",
        "__delitem__",  # Item access
        "__iter__",
        "__next__",  # Iteration
        "__contains__",  # Membership testing
        "__add__",
        "__sub__",
        "__mul__",
        "__truediv__",  # Arithmetic
        "__radd__",
        "__rsub__",
        "__rmul__",
        "__rtruediv__",  # Reverse arithmetic
        "__iadd__",
        "__isub__",
        "__imul__",
        "__itruediv__",  # In-place arithmetic
    }

    # Context manager methods (these should be documented)
    context_methods = {"__enter__", "__exit__"}

    # Simple __init__ methods (complexity < 20) can be excluded
    if func_name == "__init__" and complexity is not None and complexity < 20:
        return True

    # Exclude special methods but not context managers
    if func_name in special_methods and func_name not in context_methods:
        return True

    return False


@handle_errors("checking if function is a test function", default_return=False)
def is_test_function(func_name: str, file_path: Optional[str] = None) -> bool:
    """
    Determine if a function is a test function that should be excluded from certain analyses.

    Test functions are identified by:
    - Function name starting with 'test_' or containing 'test' keyword
    - File path containing 'test' (if file_path provided)

    Args:
        func_name: Name of the function
        file_path: Optional file path for additional context

    Returns:
        True if the function should be excluded from analysis
    """
    test_keywords = _get_test_keywords()

    # Check function name against test keywords
    func_name_lower = func_name.lower()
    for keyword in test_keywords:
        if keyword in func_name_lower:
            return True

    # If file path provided, check if it's in a test file
    if file_path:
        file_path_lower = file_path.lower()
        if (
            "test_" in file_path_lower
            or "/tests/" in file_path_lower
            or "\\tests\\" in file_path_lower
        ):
            return True

    return False
