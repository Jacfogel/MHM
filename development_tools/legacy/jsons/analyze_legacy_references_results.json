{
  "generated_by": "analyze_legacy_references - Development Tools",
  "last_generated": "2025-12-13 04:51:53",
  "timestamp": "2025-12-13T04:51:53.390547",
  "tool_name": "analyze_legacy_references",
  "domain": "legacy",
  "source": "python development_tools/legacy/analyze_legacy_references.py",
  "note": "This file is auto-generated. Do not edit manually.",
  "data": {
    "findings": {
      "legacy_compatibility_markers": [
        [
          "development_tools\\docs\\analyze_path_drift.py",
          "#!/usr/bin/env python3\n# TOOL_TIER: core\n# TOOL_PORTABILITY: portable\n\n\"\"\"\nPath Drift Analyzer\n\nThis script checks for path drift between code and documentation. It scans the\ncodebase for file paths and imports, then compares them with paths referenced\nin documentation files. Configuration is loaded from external config file\n(development_tools_config.json) if available, making this tool portable\nacross different projects.\n\nUsage:\n    python docs/analyze_path_drift.py\n\"\"\"\n\nimport re\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List, Set, Optional, Any\nfrom collections import defaultdict\n\n# Add project root to path for core module imports\nproject_root = Path(__file__).parent.parent.parent\nif str(project_root) not in sys.path:\n    sys.path.insert(0, str(project_root))\n\nfrom core.logger import get_component_logger\n\n# Handle both relative and absolute imports\nif __name__ != '__main__' and __package__ and '.' in __package__:\n    from .. import config\n    from ..shared.standard_exclusions import should_exclude_file\n    from ..shared.constants import (\n        COMMAND_PATTERNS, COMMON_CLASS_NAMES, COMMON_CODE_PATTERNS,\n        COMMON_FUNCTION_NAMES, COMMON_VARIABLE_NAMES, IGNORED_PATH_PATTERNS,\n        STANDARD_LIBRARY_MODULES, TEMPLATE_PATTERNS, THIRD_PARTY_LIBRARIES,\n        CORE_MODULES\n    )\nelse:\n    from development_tools import config\n    from development_tools.shared.standard_exclusions import should_exclude_file\n    from development_tools.shared.constants import (\n        COMMAND_PATTERNS, COMMON_CLASS_NAMES, COMMON_CODE_PATTERNS,\n        COMMON_FUNCTION_NAMES, COMMON_VARIABLE_NAMES, IGNORED_PATH_PATTERNS,\n        STANDARD_LIBRARY_MODULES, TEMPLATE_PATTERNS, THIRD_PARTY_LIBRARIES,\n        CORE_MODULES\n    )\n\n# Load external config on module import (if not already loaded)\ntry:\n    if hasattr(config, 'load_external_config'):\n        config.load_external_config()\nexcept (AttributeError, ImportError):\n    pass\n\nlogger = get_component_logger(\"development_tools\")\n\n\nclass PathDriftAnalyzer:\n    \"\"\"Analyzes path drift between code and documentation.\"\"\"\n    \n    def __init__(self, project_root: Optional[str] = None, config_path: Optional[str] = None, use_cache: bool = True):\n        \"\"\"\n        Initialize path drift analyzer.\n        \n        Args:\n            project_root: Root directory of the project\n            config_path: Optional path to external config file\n            use_cache: Whether to use mtime-based caching for file analysis\n        \"\"\"\n        # Load external config if provided\n        if config_path:\n            config.load_external_config(config_path)\n        else:\n            config.load_external_config()\n        \n        # Use provided project_root or get from config\n        if project_root:\n            self.project_root = Path(project_root).resolve()\n        else:\n            self.project_root = Path(config.get_project_root()).resolve()\n        \n        # Common path patterns that might drift - improved precision\n        self.path_patterns = [\n            # Only match backtick code that looks like file paths (not code blocks)\n            # Use negative lookahead to avoid matching .md within .mdc or other extensions\n            r'`([a-zA-Z_][a-zA-Z0-9_/]*\\.py)`',\n            r'`([a-zA-Z_][a-zA-Z0-9_/]*\\.md)(?![a-zA-Z0-9])`',  # .md not followed by alphanumeric\n            # Markdown links\n            r'\\[([^\\]]+)\\]\\(([^)]+)\\)',\n            # Python imports - but only in non-code contexts\n            r'from\\s+([a-zA-Z_][a-zA-Z0-9_.]*)\\s+import',\n            r'import\\s+([a-zA-Z_][a-zA-Z0-9_.]*)',\n        ]\n        \n        # Directories to scan for code references - load from config\n        # Use CORE_MODULES from constants (which loads from config) or fall back to scan_directories\n        if CORE_MODULES:\n            self.code_dirs = list(CORE_MODULES)\n        else:\n            # Fall back to scan_directories from config\n            scan_dirs = config.get_scan_directories()\n            self.code_dirs = scan_dirs if scan_dirs else ['core']  # Generic default\n        \n        # Caching - use standardized storage\n        from development_tools.shared.mtime_cache import MtimeFileCache\n        cache_file = self.project_root / \"development_tools\" / \"docs\" / \".path_drift_cache.json\"  # Legacy fallback\n        self.cache = MtimeFileCache(cache_file, self.project_root, use_cache=use_cache,\n                                    tool_name='analyze_path_drift', domain='docs')\n    \n    def _setup_enhanced_filters(self):\n        \"\"\"Setup enhanced filtering patterns to reduce false positives.\"\"\"\n        # Use centralized constants from shared.constants\n        self.stdlib_modules = STANDARD_LIBRARY_MODULES\n        self.third_party_libs = set(THIRD_PARTY_LIBRARIES)\n        self.function_names = set(COMMON_FUNCTION_NAMES)\n        self.class_names = set(COMMON_CLASS_NAMES)\n        self.variable_names = set(COMMON_VARIABLE_NAMES)\n        self.code_patterns = set(COMMON_CODE_PATTERNS)\n        self.ignored_paths = set(IGNORED_PATH_PATTERNS)\n        self.command_patterns = set(COMMAND_PATTERNS)\n        self.template_patterns = set(TEMPLATE_PATTERNS)\n    \n    def _should_skip_path_drift_check(self, doc_file: str) -> bool:\n        \"\"\"Check if a file should be skipped from path drift checking.\n        \n        Skips:\n        - Files with \"PLAN\" in the name (historical context files)\n        - Files in .cursor/plans/ directory\n        - Files in archive directories\n        - Test fixture files (intentional test data, not real documentation issues)\n        \n        Note: Example sections within files are excluded via _is_in_example_context(),\n        not by excluding entire files.\n        \"\"\"\n        doc_file_lower = doc_file.lower()\n        doc_file_path = Path(doc_file)\n        \n        # Skip files with \"PLAN\" in the name (historical context)\n        if 'plan' in doc_file_lower:\n            return True\n        \n        # Skip .cursor/ directory files (plans, rules, etc.)\n        if '.cursor' in doc_file_path.parts:\n            return True\n        \n        # Skip archive directories\n        if 'archive' in doc_file_path.parts:\n            return True\n        \n        # Skip test fixture files (intentional test data, not real documentation issues)\n        # These are in tests/fixtures/ or tests/fixtures/development_tools_demo/\n        if 'tests' in doc_file_path.parts and 'fixtures' in doc_file_path.parts:\n            return True\n        \n        return False\n    \n    def _should_skip_path(self, path: str, doc_file: str) -> bool:\n        \"\"\"Enhanced path filtering to reduce false positives.\"\"\"\n        # Skip URLs and anchors\n        if path.startswith(('http', '#', 'mailto')):\n            return True\n        \n        # Skip Python __future__ feature names (not modules)\n        if path == 'annotations' or path == '__future__':\n            return True\n        \n        # Skip external website references and markdown section headers\n        if path in self.ignored_paths:\n            return True\n        \n        # Skip standard library modules\n        if path in self.stdlib_modules:\n            return True\n        \n        # Skip third-party libraries\n        if path in self.third_party_libs:\n            return True\n        \n        # Skip function names\n        if path in self.function_names:\n            return True\n        \n        # Skip class names\n        if path in self.class_names:\n            return True\n        \n        # Skip variable names and common words\n        if path in self.variable_names:\n            return True\n        \n        # Skip common code patterns\n        if path in self.code_patterns:\n            return True\n        \n        # Skip single words that are clearly not files\n        if len(path.split('.')) == 1 and path.isalpha() and len(path) < 10:\n            return True\n        \n        # Skip Python import patterns that are clearly not files\n        if '.' in path and not path.endswith(('.py', '.md')):\n            # Check if it's a valid Python module pattern\n            parts = path.split('.')\n            if all(part.isidentifier() for part in parts):\n                # This looks like a Python module, not a file\n                return True\n        \n        # Skip command references\n        if any(path.startswith(cmd) for cmd in self.command_patterns):\n            return True\n        \n        # Skip template patterns\n        if any(pattern in path for pattern in self.template_patterns):\n            return True\n        \n        # Skip glob patterns\n        if '*' in path or '?' in path:\n            return True\n        \n        # Skip incomplete patterns\n        if path.endswith('_') or path.startswith('_'):\n            return True\n        \n        # Skip code blocks and method calls\n        if '(' in path and ')' in path:\n            return True\n        \n        # Skip paths that look like method calls or function calls\n        if '.' in path and any(char in path for char in ['(', ')', '=', ' ']):\n            return True\n        \n        # Skip paths that contain Python keywords or operators\n        # Check for whole-word matches only (not substrings)\n        python_keywords = ['def', 'class', 'import', 'from', 'if', 'else', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'return', 'yield', 'lambda', 'and', 'or', 'not', 'in', 'is', 'True', 'False', 'None']\n        # Use word boundaries to avoid false positives (e.g., \"in\" in \"nonexistent\")\n        import re\n        for keyword in python_keywords:\n            # Match whole word only, not as substring\n            if re.search(r'\\b' + re.escape(keyword) + r'\\b', path):\n                return True\n        \n        # Skip paths that look like code snippets (contain newlines or are very long)\n        if '\\n' in path or len(path) > 200:\n            return True\n        \n        # Skip paths that contain Python operators\n        if any(op in path for op in ['==', '!=', '<=', '>=', '+=', '-=', '*=', '/=', '%=', '//=', '**=', '&=', '|=', '^=', '<<=', '>>=']):\n            return True\n        \n        return False\n    \n    def _is_likely_code_snippet(self, path: str, line: str) -> bool:\n        \"\"\"Check if a path looks like it's part of a code snippet rather than a file reference.\"\"\"\n        # Skip if it contains method calls\n        if '(' in path and ')' in path:\n            return True\n        \n        # Skip if it contains Python operators\n        if any(op in path for op in ['==', '!=', '<=', '>=', '+=', '-=', '*=', '/=', '%=', '//=', '**=']):\n            return True\n        \n        # Skip if it contains Python keywords\n        python_keywords = ['def', 'class', 'import', 'from', 'if', 'else', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'return', 'yield', 'lambda']\n        if any(keyword in path for keyword in python_keywords):\n            return True\n        \n        # Skip if the line looks like code (contains indentation and Python syntax)\n        if line.strip().startswith(('    ', '\\t')) and any(char in line for char in ['(', ')', '=', ':', 'def', 'class', 'import', 'from']):\n            return True\n        \n        # Skip if it's very long (likely a code snippet)\n        if len(path) > 100:\n            return True\n        \n        # Skip if it contains newlines (definitely a code snippet)\n        if '\\n' in path:\n            return True\n        \n        return False\n    \n    def _is_section_header_or_link_text(self, path: str, line: str) -> bool:\n        \"\"\"Check if a path is actually a markdown section header or link text that shouldn't be treated as a file path.\"\"\"\n        # Common section header patterns (title case, multiple words, no file extension)\n        if not path.endswith(('.py', '.md', '.json', '.txt', '.yaml', '.yml', '.toml', '.ini', '.cfg')):\n            # Check if it looks like a section header (title case, spaces, common words)\n            if ' ' in path and path[0].isupper():\n                # Common section header words\n                section_words = [\n                    'overview', 'summary', 'introduction', 'background', 'context',\n                    'recommendations', 'suggestions', 'guidelines', 'best practices',\n                    'implementation', 'status', 'progress', 'analysis', 'review',\n                    'findings', 'conclusion', 'next steps', 'action items', 'todo',\n                    'issues', 'problems', 'solutions', 'approach', 'strategy',\n                    'architecture', 'design', 'structure', 'organization', 'layout'\n                ]\n                path_lower = path.lower()\n                # If it contains section header words and doesn't look like a file path\n                if any(word in path_lower for word in section_words):\n                    # Check if it's in a markdown link pointing to an anchor\n                    if re.search(rf'\\[{re.escape(path)}\\]\\(#', line):\n                        return True\n                    # Check if it's in a numbered list with markdown links\n                    if re.search(rf'^\\d+\\.\\s*\\[{re.escape(path)}\\]\\(#', line):\n                        return True\n        \n        # Skip if it's clearly a section header in a table of contents\n        if re.search(rf'^\\d+\\.\\s*\\[{re.escape(path)}\\]\\(#', line):\n            return True\n        \n        # Skip if it's in a markdown link that points to an anchor (not a file)\n        if re.search(rf'\\[{re.escape(path)}\\]\\(#[^)]+\\)', line):\n            return True\n        \n        return False\n    \n    def _is_in_example_context(self, line: str, lines: List[str], line_num: int) -> bool:\n        \"\"\"\n        Check if a line is in an example context based on documentation standards.\n        \n        Examples must be marked using one of these standards:\n        1. Example markers: [OK], [AVOID], [GOOD], [BAD], [EXAMPLE] at start of section\n        2. Example headings: \"Examples:\", \"Example Usage:\", \"Example Code:\" headings\n        3. Code blocks: Automatically excluded (handled separately)\n        4. Archive references: Lines containing \"archive\" or \"archived\" (for archived file references)\n        5. Example phrases: \"for example\", \"for instance\", \"e.g.\", etc.\n        \n        This method implements the example marking standards defined in DOCUMENTATION_GUIDE.md section 2.6.\n        Uses the same logic as fix_documentation.py for consistency.\n        \"\"\"\n        line_stripped = line.strip()\n        line_lower = line.lower()\n        \n        # Standard 4: Check if line contains \"archive\" or \"archived\" (for archived file references)\n        if 'archive' in line_lower or 'archived' in line_lower:\n            return True\n        \n        # Check for [ARCHIVED] marker (similar to [EXAMPLE])\n        if '[archived]' in line_lower:\n            return True\n        \n        # Standard 5: Check for example phrases in the current line\n        example_phrases = ['for example', 'for instance', 'e.g.,', 'e.g.', 'example:', 'examples:']\n        for phrase in example_phrases:\n            if phrase in line_lower:\n                return True\n        \n        # Standard 1: Check for example markers at the start of the line\n        # These are the official markers per documentation standards\n        example_markers = [\n            r'^\\[OK\\]', r'^\\[AVOID\\]', r'^\\[GOOD\\]', r'^\\[BAD\\]', r'^\\[EXAMPLE\\]',\n        ]\n        for marker in example_markers:\n            if re.match(marker, line_stripped, re.IGNORECASE):\n                return True\n        \n        # Standard 1 & 5 (continued): Check previous lines (up to 10 lines back) for example markers and phrases\n        # This catches cases where [AVOID] or [OK] or [EXAMPLE] or [ARCHIVED] is on a previous line (per standard)\n        for i in range(max(0, line_num - 10), line_num):\n            prev_line = lines[i].strip()\n            prev_line_lower = prev_line.lower()\n            # Check for archive references in previous lines too\n            if 'archive' in prev_line_lower or 'archived' in prev_line_lower:\n                if line_num - i <= 10:  # Within 10 lines of archive reference (extended for [ARCHIVED] sections)\n                    return True\n            # Check for [ARCHIVED] marker in previous lines\n            if '[archived]' in prev_line_lower:\n                if line_num - i <= 10:  # Within 10 lines of [ARCHIVED] marker\n                    return True\n            # Check for example phrases in previous lines\n            for phrase in example_phrases:\n                if phrase in prev_line_lower:\n                    if line_num - i <= 3:  # Within 3 lines of example phrase\n                        return True\n            # Check for example markers in previous lines\n            for marker in example_markers:\n                if re.match(marker, prev_line, re.IGNORECASE):\n                    # If we found a marker, check if current line is part of the example\n                    # (list item, continuation, or within same section)\n                    if line_stripped.startswith(('-', '*', '1.', '2.', '3.', '  ')) or \\\n                       line_num - i <= 10:  # Within 10 lines of the marker (extended for [EXAMPLE] sections)\n                        return True\n        \n        # Standard 2: Check if we're in an \"Examples\" section by looking backwards for section headers\n        # Look back up to 20 lines for section headers (per standard)\n        for i in range(max(0, line_num - 20), line_num):\n            prev_line = lines[i].strip()\n            # Check for \"Examples:\" or \"Example Usage:\" or \"Example Code:\" headings (per standard)\n            if re.match(r'^#+\\s+(Examples?|Example\\s+Usage|Example\\s+Code)', prev_line, re.IGNORECASE):\n                return True\n            # Check for bold \"Examples:\" or \"Example Usage:\" text\n            if re.match(r'^\\*\\*(Examples?|Example\\s+Usage)\\*\\*', prev_line, re.IGNORECASE):\n                return True\n        \n        # Note: Code blocks are handled separately in scan_documentation_paths() by checking in_code_block\n        # This is Standard 3 and doesn't need to be checked here\n        \n        return False\n    \n    def _is_valid_file_reference(self, path: str, source_dir: Path) -> bool:\n        \"\"\"Check if a file reference is valid.\"\"\"\n        # Skip obvious glob patterns\n        if path.startswith('*') or path.endswith('*') or '/*' in path:\n            return True\n        \n        # Skip command references\n        if path.startswith('python ') or path.startswith('pip ') or path.startswith('git '):\n            return True\n        \n        # Skip template patterns\n        if '{' in path and '}' in path:\n            return True\n        \n        # Skip test template patterns\n        if path.startswith('test_<') or path.endswith('>.py'):\n            return True\n        \n        # Check if the file exists\n        file_path = self.project_root / path\n        if file_path.exists():\n            return True\n        \n        # If checking for .md file, also check if .mdc file exists (avoid false positives)\n        if path.endswith('.md'):\n            mdc_path = path[:-2] + 'c'  # Replace .md with .mdc\n            mdc_file = self.project_root / mdc_path\n            if mdc_file.exists():\n                return True  # Valid reference to .mdc file, not a missing .md file\n        \n        # Check relative paths (both ../ paths and same-directory paths)\n        # First check if it's a relative path starting with ../\n        if path.startswith('../'):\n            relative_path = source_dir / path\n            if relative_path.exists():\n                return True\n            \n            # Also check for .mdc variant in relative paths\n            if path.endswith('.md'):\n                mdc_path = path[:-2] + 'c'\n                mdc_relative = source_dir / mdc_path\n                if mdc_relative.exists():\n                    return True\n        else:\n            # For paths without ../, check relative to source file's directory\n            # This handles same-directory references (e.g., config.py in development_tools/)\n            relative_path = source_dir / path\n            if relative_path.exists():\n                return True\n            \n            # Also check for .mdc variant\n            if path.endswith('.md'):\n                mdc_path = path[:-2] + 'c'\n                mdc_relative = source_dir / mdc_path\n                if mdc_relative.exists():\n                    return True\n        \n        return False\n    \n    def _is_valid_module_reference(self, path: str, code_paths: Set[str]) -> bool:\n        \"\"\"Check if a module reference is valid.\"\"\"\n        # Skip if it's a standard library module\n        if path in self.stdlib_modules:\n            return True\n        \n        # Skip if it's a third-party library\n        if path in self.third_party_libs:\n            return True\n        \n        # Skip if it's a function name\n        if path in self.function_names:\n            return True\n        \n        # Skip if it's a class name\n        if path in self.class_names:\n            return True\n        \n        # Skip if it's a variable name\n        if path in self.variable_names:\n            return True\n        \n        # Skip if it's a common code pattern\n        if path in self.code_patterns:\n            return True\n        \n        # Skip valid package-level exports (e.g., CommunicationManager from communication package)\n        # These are valid even if not directly importable via static analysis\n        valid_package_exports = {\n            'CommunicationManager',  # Exported via __getattr__ in communication/__init__.py\n        }\n        if path in valid_package_exports:\n            return True\n        \n        # Check if this path exists in the codebase\n        normalized_path = path.replace('.', '/').replace('\\\\', '/')\n        for code_path in code_paths:\n            if normalized_path in code_path or code_path in normalized_path:\n                return True\n        \n        return False\n    \n    def scan_codebase_paths(self) -> Set[str]:\n        \"\"\"Scan codebase for all file paths and imports.\"\"\"\n        paths = set()\n        \n        for code_dir in self.code_dirs:\n            code_path = self.project_root / code_dir\n            if code_path.exists():\n                for py_file in code_path.rglob(\"*.py\"):\n                    try:\n                        with open(py_file, 'r', encoding='utf-8') as f:\n                            content = f.read()\n                            \n                        # Extract import statements\n                        import_pattern = r'^(?:from\\s+([a-zA-Z_][a-zA-Z0-9_.]*)\\s+import|import\\s+([a-zA-Z_][a-zA-Z0-9_.]*))'\n                        for line in content.split('\\n'):\n                            match = re.match(import_pattern, line.strip())\n                            if match:\n                                module = match.group(1) or match.group(2)\n                                if module and not module.startswith(('os', 'sys', 'pathlib', 'typing')):\n                                    paths.add(module)\n                                    \n                    except Exception as e:\n                        if logger:\n                            logger.warning(f\"Error reading {py_file}: {e}\")\n                        \n        return paths\n    \n    def scan_documentation_paths(self) -> Dict[str, List[str]]:\n        \"\"\"Scan documentation files for path references.\"\"\"\n        # Ensure enhanced filters are set up (needed by filtering methods)\n        if not hasattr(self, 'stdlib_modules'):\n            self._setup_enhanced_filters()\n        \n        doc_paths = defaultdict(list)\n        \n        for md_file in self.project_root.rglob(\"*.md\"):\n            # Skip files that should be excluded\n            # Check path relative to project root to avoid matching parent directory exclusions\n            rel_path = str(md_file.relative_to(self.project_root))\n            if should_exclude_file(rel_path, 'documentation'):\n                continue\n                \n            if md_file.name.startswith('.'):\n                continue\n            \n            # Skip historical changelog files - they contain accurate historical references\n            if 'CHANGELOG_DETAIL.md' in str(md_file) or 'AI_CHANGELOG.md' in str(md_file):\n                continue\n            \n            # Check cache first\n            cached_paths = self.cache.get_cached(md_file)\n            if cached_paths is not None:\n                if cached_paths:\n                    rel_path = str(md_file.relative_to(self.project_root))\n                    doc_paths[rel_path] = cached_paths\n                continue\n                \n            try:\n                with open(md_file, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    \n                # Extract all path references with context awareness\n                lines = content.split('\\n')\n                in_code_block = False\n                \n                for line_num, line in enumerate(lines):\n                    # Track code block state\n                    if line.strip().startswith('```'):\n                        in_code_block = not in_code_block\n                        continue\n                    \n                    # Skip extraction if we're inside a code block\n                    if in_code_block:\n                        continue\n                    \n                    # Check if this line is in an example context\n                    if self._is_in_example_context(line, lines, line_num):\n                        continue\n                    \n                    # Extract paths from this line\n                    for pattern in self.path_patterns:\n                        matches = re.findall(pattern, line)\n                        for match in matches:\n                            if isinstance(match, tuple):\n                                # Handle regex groups (e.g., markdown links [text](url))\n                                # For markdown links, check if URL part has valid path\n                                if len(match) >= 2:\n                                    link_text = match[0] if match[0] else ''\n                                    url_part = match[1] if match[1] else ''\n                                    \n                                    # Skip if URL part is a valid file reference (has full path or exists)\n                                    if url_part and not url_part.startswith(('http', '#')):\n                                        # Check if URL part is a valid file reference\n                                        source_dir = md_file.parent\n                                        if self._is_valid_file_reference(url_part, source_dir):\n                                            # URL part is valid, skip link text even if it looks like a file path\n                                            # Only process the URL part\n                                            if not self._is_likely_code_snippet(url_part, line):\n                                                if not self._is_section_header_or_link_text(url_part, line):\n                                                    doc_paths[str(md_file.relative_to(self.project_root))].append(url_part)\n                                            continue\n                                        \n                                    # URL part not valid or not a file path, process link text if it looks like a file path\n                                    if link_text and not link_text.startswith(('http', '#')):\n                                        if link_text.endswith(('.py', '.md')) or '/' in link_text or '\\\\' in link_text:\n                                            if not self._is_likely_code_snippet(link_text, line):\n                                                if not self._is_section_header_or_link_text(link_text, line):\n                                                    doc_paths[str(md_file.relative_to(self.project_root))].append(link_text)\n                                else:\n                                    # Single group match, process normally\n                                    for idx, group in enumerate(match):\n                                        if group and not group.startswith(('http', '#')):\n                                            if not self._is_likely_code_snippet(group, line):\n                                                if not self._is_section_header_or_link_text(group, line):\n                                                    doc_paths[str(md_file.relative_to(self.project_root))].append(group)\n                            else:\n                                if match and not match.startswith(('http', '#')):\n                                    # Additional context filtering\n                                    if not self._is_likely_code_snippet(match, line):\n                                        # Skip section headers and common markdown link text\n                                        if not self._is_section_header_or_link_text(match, line):\n                                            doc_paths[str(md_file.relative_to(self.project_root))].append(match)\n                \n                # Cache results for this file\n                rel_path = str(md_file.relative_to(self.project_root))\n                file_paths = doc_paths.get(rel_path, [])\n                self.cache.cache_results(md_file, file_paths)\n                                \n            except Exception as e:\n                if logger:\n                    logger.warning(f\"Error reading {md_file}: {e}\")\n                # Cache empty result for files with errors\n                self.cache.cache_results(md_file, [])\n        \n        # Save cache\n        self.cache.save_cache()\n        \n        return doc_paths\n    \n    def check_path_drift(self) -> Dict[str, List[str]]:\n        \"\"\"\n        Check for path drift between code and documentation.\n        \n        Returns:\n            Dictionary mapping file paths to lists of issues\n        \"\"\"\n        code_paths = self.scan_codebase_paths()\n        doc_paths = self.scan_documentation_paths()\n        \n        drift_issues = defaultdict(list)\n        \n        # Enhanced filtering patterns for false positives\n        self._setup_enhanced_filters()\n        \n        # Files that document legacy patterns (expected to reference old paths)\n        # Use normalized paths (forward slashes) for comparison\n        legacy_documentation_files = {\n            'development_docs/LEGACY_REFERENCE_REPORT.md',\n            'development_docs\\\\LEGACY_REFERENCE_REPORT.md',  # Windows path\n            'development_docs/CHANGELOG_DETAIL.md',  # May contain historical references\n            'development_docs\\\\CHANGELOG_DETAIL.md',  # Windows path\n            'ai_development_docs/AI_CHANGELOG.md',\n            'ai_development_docs\\\\AI_CHANGELOG.md',  # Windows path\n        }\n        \n        # Check if documented paths exist\n        for doc_file, paths in doc_paths.items():\n            # Skip files that shouldn't be checked for path drift\n            if self._should_skip_path_drift_check(doc_file):\n                continue\n            \n            # Get the directory of the source file for relative path resolution\n            source_dir = self.project_root / doc_file\n            if source_dir.is_file():\n                source_dir = source_dir.parent\n            \n            # Skip legacy documentation files - they intentionally reference old paths\n            # Normalize path for comparison (handle both / and \\)\n            normalized_doc_file = doc_file.replace('\\\\', '/')\n            if normalized_doc_file in legacy_documentation_files or doc_file in legacy_documentation_files:\n                continue\n            \n            for path in paths:\n                # Apply enhanced filtering\n                if self._should_skip_path(path, doc_file):\n                    continue\n                \n                # Check if it's a markdown file reference\n                if path.endswith('.md') or path.endswith('.py'):\n                    if self._is_valid_file_reference(path, source_dir):\n                        continue\n                    else:\n                        drift_issues[doc_file].append(f\"Missing file: {path}\")\n                else:\n                    # Check if it's a Python module reference\n                    if self._is_valid_module_reference(path, code_paths):\n                        continue\n                    else:\n                        drift_issues[doc_file].append(f\"Potentially outdated module: {path}\")\n                    \n        return drift_issues\n    \n    def run_analysis(self) -> Dict[str, Any]:\n        \"\"\"\n        Run path drift analysis and return results in standard format.\n        \n        Returns:\n            Dictionary with standard format: 'summary', 'files', and 'details' keys\n        \"\"\"\n        drift_issues = self.check_path_drift()\n        \n        # Convert to structured format\n        files = {}\n        total_issues = 0\n        for doc_file, issues in drift_issues.items():\n            issue_count = len(issues)\n            files[doc_file] = issue_count\n            total_issues += issue_count\n        \n        # Return standard format\n        return {\n            'summary': {\n                'total_issues': total_issues,\n                'files_affected': len(files)\n            },\n            'files': files,\n            'details': {\n                'detailed_issues': dict(drift_issues)  # Keep detailed issues for reference\n            }\n        }\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Check for path drift between code and documentation\")\n    parser.add_argument('--json', action='store_true', help='Output results as JSON')\n    \n    args = parser.parse_args()\n    \n    analyzer = PathDriftAnalyzer()\n    structured_results = analyzer.run_analysis()\n    \n    if args.json:\n        import json\n        print(json.dumps(structured_results, indent=2))\n        return 0\n    \n    # Print results in human-readable format\n    # LEGACY COMPATIBILITY: Handle both standard format (new) and legacy format (old)\n    # Standard format uses 'summary' key; legacy format has 'total_issues' at top level\n    # Removal plan: After all callers are updated to use standard format, remove legacy format handling.\n    # Detection: Search for \"Legacy format (backward compatibility)\" in this file.\n    if 'summary' in structured_results:\n        # Standard format\n        summary = structured_results.get('summary', {})\n        total_issues = summary.get('total_issues', 0)\n        files = structured_results.get('files', {})\n        details = structured_results.get('details', {})\n        results = details.get('detailed_issues', {})\n    else:\n        # Legacy format (backward compatibility)\n        logger.debug(\"analyze_path_drift main: Using legacy format (backward compatibility)\")\n        results = structured_results.get('detailed_issues', {})\n        total_issues = structured_results.get('total_issues', 0)\n        files = structured_results.get('files', {})\n    \n    if results:\n        print(f\"\\nPath Drift Issues:\")\n        print(f\"   Total files with issues: {len(results)}\")\n        print(f\"   Total issues found: {total_issues}\")\n        print(f\"   Top files with most issues:\")\n        sorted_files = sorted(files.items(), key=lambda x: x[1], reverse=True)\n        for doc_file, issue_count in sorted_files[:5]:\n            print(f\"     {doc_file}: {issue_count} issues\")\n    else:\n        print(\"\\nNo path drift issues found!\")\n    \n    return 0 if not results else 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n\n",
          [
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 751,
              "line_content": "# LEGACY COMPATIBILITY: Handle both standard format (new) and legacy format (old)",
              "start": 34022,
              "end": 34045
            }
          ]
        ],
        [
          "development_tools\\shared\\mtime_cache.py",
          "#!/usr/bin/env python3\n\"\"\"\nMtime-based File Cache Utility\n\nProvides a reusable caching mechanism for file-based analyzers that checks\nfile modification times (mtime) to determine if cached results are still valid.\n\nUsage:\n    from development_tools.shared.mtime_cache import MtimeFileCache\n    \n    cache = MtimeFileCache(\n        cache_file=project_root / \"development_tools\" / \"docs\" / \".my_cache.json\",\n        project_root=project_root,\n        use_cache=True\n    )\n    \n    # Check if file is cached\n    cached_results = cache.get_cached(file_path)\n    if cached_results is not None:\n        # Use cached results\n        return cached_results\n    \n    # Process file and cache results\n    results = process_file(file_path)\n    cache.cache_results(file_path, results)\n    cache.save_cache()\n\"\"\"\n\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for cached results\n\ntry:\n    from core.logger import get_component_logger\n    logger = get_component_logger(\"development_tools\")\nexcept ImportError:\n    logger = None\n\n\nclass MtimeFileCache:\n    \"\"\"\n    Mtime-based file cache for analyzer results.\n    \n    Caches results keyed by file path, with validation based on file modification time.\n    Only re-processes files that have been modified since the last cache entry.\n    \"\"\"\n    \n    def __init__(\n        self,\n        cache_file: Path,\n        project_root: Path,\n        use_cache: bool = True,\n        tool_name: Optional[str] = None,\n        domain: Optional[str] = None\n    ):\n        \"\"\"\n        Initialize the cache.\n        \n        Args:\n            cache_file: Path to the JSON cache file (legacy - used if tool_name/domain not provided)\n            project_root: Root directory of the project (for relative path generation)\n            use_cache: Whether to use caching (if False, all operations are no-ops)\n            tool_name: Name of the tool (e.g., 'analyze_ascii_compliance') - if provided, uses standardized storage\n            domain: Domain directory (e.g., 'docs') - if provided with tool_name, uses standardized storage\n        \"\"\"\n        self.cache_file = cache_file\n        self.project_root = project_root.resolve()\n        self.use_cache = use_cache\n        self.cache_data: Dict[str, Dict[str, Any]] = {}\n        self.tool_name = tool_name\n        self.domain = domain\n        self.use_standardized_storage = tool_name is not None and domain is not None\n        \n        if self.use_cache:\n            self._load_cache()\n    \n    def _load_cache(self) -> None:\n        \"\"\"Load cache from disk if it exists.\"\"\"\n        if self.use_standardized_storage:\n            # Use standardized storage\n            try:\n                from .output_storage import load_tool_cache\n                loaded_data = load_tool_cache(self.tool_name, self.domain, project_root=self.project_root)\n                if loaded_data:\n                    # load_tool_cache already extracts data from metadata wrapper, so loaded_data is the cache content\n                    # Migrate old cache format (with 'issues' key) to new format (with 'results' key)\n                    migrated_data = {}\n                    for key, value in loaded_data.items():\n                        if isinstance(value, dict):\n                            # Check if it's old format with 'issues' key\n                            if 'issues' in value and 'results' not in value:\n                                migrated_data[key] = {\n                                    'mtime': value.get('mtime'),\n                                    'results': value.get('issues', [])\n                                }\n                            else:\n                                # Already in new format or has 'results' key\n                                migrated_data[key] = value\n                        else:\n                            # Invalid format, skip\n                            continue\n                    self.cache_data = migrated_data\n                    if logger:\n                        logger.debug(f\"Loaded cache from standardized storage ({self.tool_name}) with {len(self.cache_data)} entries\")\n                    return\n            except Exception as e:\n                if logger:\n                    logger.warning(f\"Failed to load cache from standardized storage: {e}\")\n        \n        # LEGACY COMPATIBILITY: Fallback to legacy file-based loading\n        # New standardized storage location: development_tools/{domain}/jsons/.{tool_name}_cache.json\n        # Removal plan: After all tools migrate to standardized storage and old cache files are removed, remove this fallback.\n        # Detection: Search for \"cache_file.exists()\" and \"MtimeFileCache\" without tool_name/domain parameters to find legacy usage.\n        if self.cache_file.exists():\n            if logger:\n                logger.debug(f\"LEGACY: Loading cache from legacy location: {self.cache_file}\")\n            try:\n                with open(self.cache_file, 'r', encoding='utf-8') as f:\n                    loaded_data = json.load(f)\n                    # Migrate old cache format (with 'issues' key) to new format (with 'results' key)\n                    # This handles migration from analyze_unused_imports.py old format\n                    migrated_data = {}\n                    for key, value in loaded_data.items():\n                        if isinstance(value, dict):\n                            # Check if it's old format with 'issues' key\n                            if 'issues' in value and 'results' not in value:\n                                migrated_data[key] = {\n                                    'mtime': value.get('mtime'),\n                                    'results': value.get('issues', [])\n                                }\n                            else:\n                                # Already in new format or has 'results' key\n                                migrated_data[key] = value\n                        else:\n                            # Invalid format, skip\n                            continue\n                    self.cache_data = migrated_data\n                if logger:\n                    logger.debug(f\"Loaded cache from {self.cache_file} with {len(self.cache_data)} entries\")\n            except Exception as e:\n                if logger:\n                    logger.warning(f\"Failed to load cache from {self.cache_file}: {e}\")\n                self.cache_data = {}\n    \n    def save_cache(self) -> None:\n        \"\"\"Save cache to disk.\"\"\"\n        if not self.use_cache:\n            return\n        \n        if self.use_standardized_storage:\n            # Use standardized storage\n            try:\n                from .output_storage import save_tool_cache\n                save_tool_cache(self.tool_name, self.domain, self.cache_data, project_root=self.project_root)\n                if logger:\n                    logger.debug(f\"Saved cache to standardized storage ({self.tool_name}) with {len(self.cache_data)} entries\")\n                return\n            except Exception as e:\n                if logger:\n                    logger.warning(f\"Failed to save cache to standardized storage: {e}\")\n        \n        # LEGACY COMPATIBILITY: Fallback to legacy file-based saving\n        # New standardized storage location: development_tools/{domain}/jsons/.{tool_name}_cache.json\n        # Removal plan: After all tools migrate to standardized storage and old cache files are removed, remove this fallback.\n        # Detection: Search for \"cache_file.parent.mkdir\" and \"MtimeFileCache\" without tool_name/domain parameters to find legacy usage.\n        if logger:\n            logger.debug(f\"LEGACY: Saving cache to legacy location: {self.cache_file}\")\n        try:\n            self.cache_file.parent.mkdir(parents=True, exist_ok=True)\n            with open(self.cache_file, 'w', encoding='utf-8') as f:\n                json.dump(self.cache_data, f, indent=2)\n            if logger:\n                logger.debug(f\"Saved cache to {self.cache_file} with {len(self.cache_data)} entries\")\n        except Exception as e:\n            if logger:\n                logger.warning(f\"Failed to save cache to {self.cache_file}: {e}\")\n    \n    def _get_file_cache_key(self, file_path: Path) -> str:\n        \"\"\"Generate cache key for a file (relative path from project root).\"\"\"\n        try:\n            rel_path = file_path.resolve().relative_to(self.project_root)\n            return str(rel_path).replace('\\\\', '/')\n        except ValueError:\n            # File is outside project root, use absolute path\n            return str(file_path.resolve())\n    \n    def _is_file_cached(self, file_path: Path) -> bool:\n        \"\"\"Check if file results are cached and still valid (mtime matches).\"\"\"\n        if not self.use_cache:\n            return False\n        \n        cache_key = self._get_file_cache_key(file_path)\n        if cache_key not in self.cache_data:\n            return False\n        \n        cached_mtime = self.cache_data[cache_key].get('mtime')\n        if cached_mtime is None:\n            return False\n        \n        try:\n            current_mtime = file_path.stat().st_mtime\n            return current_mtime == cached_mtime\n        except OSError:\n            return False\n    \n    def get_cached(self, file_path: Path) -> Optional[T]:\n        \"\"\"\n        Get cached results for a file if available and still valid.\n        \n        Args:\n            file_path: Path to the file to check\n            \n        Returns:\n            Cached results if available and valid, None otherwise\n        \"\"\"\n        if not self._is_file_cached(file_path):\n            return None\n        \n        cache_key = self._get_file_cache_key(file_path)\n        cached_data = self.cache_data[cache_key].get('results')\n        return cached_data\n    \n    def cache_results(self, file_path: Path, results: T) -> None:\n        \"\"\"\n        Cache results for a file.\n        \n        Args:\n            file_path: Path to the file being cached\n            results: Results to cache (must be JSON-serializable)\n        \"\"\"\n        if not self.use_cache:\n            return\n        \n        try:\n            cache_key = self._get_file_cache_key(file_path)\n            mtime = file_path.stat().st_mtime\n            self.cache_data[cache_key] = {\n                'mtime': mtime,\n                'results': results\n            }\n        except OSError:\n            # File doesn't exist or can't be accessed, skip caching\n            pass\n    \n    def clear_cache(self) -> None:\n        \"\"\"Clear all cached data (in memory only, call save_cache() to persist).\"\"\"\n        self.cache_data = {}\n    \n    def get_cache_stats(self) -> Dict[str, int]:\n        \"\"\"\n        Get statistics about the cache.\n        \n        Returns:\n            Dictionary with cache statistics (total_entries, etc.)\n        \"\"\"\n        return {\n            'total_entries': len(self.cache_data),\n            'cache_file': str(self.cache_file)\n        }\n\n",
          [
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 112,
              "line_content": "# LEGACY COMPATIBILITY: Fallback to legacy file-based loading",
              "start": 4365,
              "end": 4388
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 164,
              "line_content": "# LEGACY COMPATIBILITY: Fallback to legacy file-based saving",
              "start": 7203,
              "end": 7226
            }
          ]
        ],
        [
          "development_tools\\shared\\operations.py",
          "#!/usr/bin/env python3\n# TOOL_TIER: core\n\n\n\"\"\"\n\nCore operations used by the AI development toolchain.\n\nThis module contains the reusable service layer that powers the CLI in\n\n`run_development_tools.py`. Each public method exposes a discrete workflow that\n\ncan be invoked programmatically or through a registered command.\n\n\"\"\"\n\nimport sys\n\nimport subprocess\n\nimport json\n\nimport os\n\nimport re\n\nimport argparse\n\nfrom pathlib import Path\n\nfrom datetime import datetime\n\nfrom dataclasses import dataclass\n\nfrom typing import Any, Dict, List, Optional, Sequence, Callable\n\nfrom collections import OrderedDict, defaultdict\n\nfrom .. import config\n# Load external config if path was provided (will be set by AIToolsService)\n\n# Add project root to path for core module imports\nproject_root = Path(__file__).parent.parent.parent\nif str(project_root) not in sys.path:\n    sys.path.insert(0, str(project_root))\n\nfrom core.logger import get_component_logger\n\nlogger = get_component_logger(\"development_tools\")\n\nSCRIPT_REGISTRY = {\n\n    'analyze_documentation': 'docs/analyze_documentation.py',\n\n    'analyze_function_registry': 'functions/analyze_function_registry.py',\n\n    'analyze_module_dependencies': 'imports/analyze_module_dependencies.py',\n\n    'analyze_config': 'config/analyze_config.py',\n\n    'decision_support': 'reports/decision_support.py',\n\n    'analyze_documentation_sync': 'docs/analyze_documentation_sync.py',\n    'analyze_path_drift': 'docs/analyze_path_drift.py',\n    'analyze_missing_addresses': 'docs/analyze_missing_addresses.py',\n    'analyze_ascii_compliance': 'docs/analyze_ascii_compliance.py',\n    'analyze_heading_numbering': 'docs/analyze_heading_numbering.py',\n    'analyze_unconverted_links': 'docs/analyze_unconverted_links.py',\n    'generate_directory_tree': 'docs/generate_directory_tree.py',\n\n    'analyze_error_handling': 'error_handling/analyze_error_handling.py',\n    'generate_error_handling_report': 'error_handling/generate_error_handling_report.py',\n    'generate_error_handling_recommendations': 'error_handling/generate_error_handling_recommendations.py',\n\n    'analyze_functions': 'functions/analyze_functions.py',\n    'analyze_function_patterns': 'functions/analyze_function_patterns.py',\n    'analyze_package_exports': 'functions/analyze_package_exports.py',\n    'generate_function_registry': 'functions/generate_function_registry.py',\n\n    'generate_module_dependencies': 'imports/generate_module_dependencies.py',\n    'analyze_module_imports': 'imports/analyze_module_imports.py',\n    'analyze_dependency_patterns': 'imports/analyze_dependency_patterns.py',\n\n    'fix_legacy_references': 'legacy/fix_legacy_references.py',\n    'analyze_legacy_references': 'legacy/analyze_legacy_references.py',\n    'generate_legacy_reference_report': 'legacy/generate_legacy_reference_report.py',\n\n    'quick_status': 'reports/quick_status.py',\n\n    'generate_test_coverage': 'tests/generate_test_coverage.py',\n    'analyze_test_coverage': 'tests/analyze_test_coverage.py',\n    'generate_test_coverage_reports': 'tests/generate_test_coverage_reports.py',\n    'analyze_test_markers': 'tests/analyze_test_markers.py',\n\n    'analyze_unused_imports': 'imports/analyze_unused_imports.py',\n\n    'analyze_ai_work': 'ai_work/analyze_ai_work.py',\n\n    'fix_version_sync': 'docs/fix_version_sync.py',\n\n    'fix_documentation': 'docs/fix_documentation.py',\n\n    'system_signals': 'reports/system_signals.py',\n    \n    'cleanup_project': 'shared/fix_project_cleanup.py'\n\n}\n\nfrom ..shared.file_rotation import create_output_file\nfrom .common import COMMAND_TIERS\nfrom .output_storage import save_tool_result, load_tool_result, get_all_tool_results, _get_domain_from_tool_name\n\n# Module-level flag to track if ANY audit is in progress\n# This prevents status file writes even from new AIToolsService instances created during tests\n_AUDIT_IN_PROGRESS_GLOBAL = False\n\n# File-based lock for cross-process protection (when pytest-xdist runs tests in separate processes)\n_AUDIT_LOCK_FILE = None  # Will be set to Path object when audit starts\n\ndef _get_status_file_mtimes(project_root: Path) -> Dict[str, float]:\n    \"\"\"\n    Get modification times for all status files.\n    \n    Args:\n        project_root: Project root directory\n        \n    Returns:\n        Dictionary mapping file names to modification times (or 0 if file doesn't exist)\n    \"\"\"\n    status_files = {\n        'AI_STATUS.md': project_root / 'development_tools' / 'AI_STATUS.md',\n        'AI_PRIORITIES.md': project_root / 'development_tools' / 'AI_PRIORITIES.md',\n        'consolidated_report.txt': project_root / 'development_tools' / 'consolidated_report.txt'\n    }\n    \n    mtimes = {}\n    for name, path in status_files.items():\n        if path.exists():\n            mtimes[name] = path.stat().st_mtime\n        else:\n            mtimes[name] = 0.0\n    \n    return mtimes\n\ndef _is_audit_in_progress(project_root: Path) -> bool:\n    \"\"\"\n    Check if audit is in progress using both in-memory flag and file-based lock.\n    This works across processes (e.g., pytest-xdist workers).\n    Also checks for coverage regeneration in progress.\n    \n    Args:\n        project_root: Project root directory\n        \n    Returns:\n        True if audit or coverage regeneration is in progress, False otherwise\n    \"\"\"\n    global _AUDIT_IN_PROGRESS_GLOBAL, _AUDIT_LOCK_FILE\n    \n    # Check in-memory flag (works within same process)\n    if _AUDIT_IN_PROGRESS_GLOBAL:\n        return True\n    \n    # Check file-based lock (works across processes)\n    if _AUDIT_LOCK_FILE is None:\n        _AUDIT_LOCK_FILE = project_root / 'development_tools' / '.audit_in_progress.lock'\n    \n    audit_lock_exists = _AUDIT_LOCK_FILE.exists()\n    \n    # Also check for coverage regeneration lock\n    coverage_lock_file = project_root / 'development_tools' / '.coverage_in_progress.lock'\n    coverage_lock_exists = coverage_lock_file.exists()\n    \n    lock_exists = audit_lock_exists or coverage_lock_exists\n    \n    # Log the check for debugging (only if lock exists to avoid spam)\n    if lock_exists:\n        from core.logger import get_component_logger\n        logger = get_component_logger(\"development_tools\")\n        logger.debug(f\"Audit/coverage lock file check: audit={audit_lock_exists}, coverage={coverage_lock_exists} (project_root: {project_root})\")\n    \n    return lock_exists\n\nclass AIToolsService:\n\n    \"\"\"Comprehensive AI tools runner optimized for AI collaboration.\"\"\"\n\n    def __init__(self, project_root: Optional[str] = None, config_path: Optional[str] = None, \n                 project_name: Optional[str] = None, key_files: Optional[List[str]] = None):\n\n        # Load external config if path provided, or try to auto-load from default location\n        if config_path:\n            config.load_external_config(config_path)\n        else:\n            # Try to auto-load from development_tools/config/development_tools_config.json or project root\n            config.load_external_config()\n        \n        # Use provided project_root or fall back to config\n        if project_root:\n            self.project_root = Path(project_root).resolve()\n        else:\n            self.project_root = Path(config.get_project_root()).resolve()\n        \n        # Store config_path for reference\n        self.config_path = config_path\n        \n        # Project-specific configuration (for portability)\n        # Can be overridden by external config\n        self.project_name = project_name or config.get_external_value('project.name', \"Project\")\n        self.key_files = key_files or config.get_external_value('project.key_files', [])\n\n        self.workflow_config = config.get_workflow_config() or {}\n        \n        # Store path validation result for status display\n        self.path_validation_result: Optional[Dict[str, Any]] = None\n\n        self.validation_config = config.get_ai_validation_config() or {}\n\n        self.ai_config = config.get_ai_collaboration_config() or {}\n\n        self.audit_config = config.get_quick_audit_config() or {}\n\n        self.results_cache = {}\n\n        self.docs_sync_results = None\n\n        self.system_signals = None\n        self.dev_tools_coverage_results = None\n        self.module_dependency_summary = None\n        self.todo_sync_result = None\n\n        self.exclusion_config = {\n\n            'include_tests': False,\n\n            'include_dev_tools': False\n\n        }\n\n        self.docs_sync_summary = None\n\n        self.legacy_cleanup_results = None\n\n        self.legacy_cleanup_summary = None\n\n        self.status_results = None\n\n        self.status_summary = None\n        \n        self.current_audit_tier = None  # Track current audit tier (1=quick, 2=standard, 3=full)\n\n    def set_exclusion_config(self, include_tests: bool = False, include_dev_tools: bool = False):\n\n        \"\"\"Set exclusion configuration for audit tools.\"\"\"\n\n        self.exclusion_config = {\n\n            'include_tests': include_tests,\n\n            'include_dev_tools': include_dev_tools\n\n        }\n\n    def run_script(self, script_name: str, *args, timeout: Optional[int] = 300) -> Dict:\n\n        \"\"\"Run a registered helper script from development_tools.\"\"\"\n\n        script_rel_path = SCRIPT_REGISTRY.get(script_name)\n\n        if not script_rel_path:\n\n            return {\n\n                'success': False,\n\n                'output': '',\n\n                'error': f\"Script '{script_name}' is not registered\"\n\n            }\n\n        script_path = Path(__file__).resolve().parent.parent / script_rel_path\n\n        if not script_path.exists():\n\n            return {\n\n                'success': False,\n\n                'output': '',\n\n                'error': f\"Registered script '{script_name}' not found at {script_rel_path}\"\n\n            }\n\n        cmd = [sys.executable, str(script_path)] + list(args)\n\n        try:\n\n            result = subprocess.run(\n\n                cmd,\n\n                capture_output=True,\n\n                text=True,\n\n                cwd=str(self.project_root),\n\n                timeout=timeout  # default 5 minute timeout\n\n            )\n\n            return {\n\n                'success': result.returncode == 0,\n\n                'output': result.stdout,\n\n                'error': result.stderr,\n\n                'returncode': result.returncode\n\n            }\n\n        except subprocess.TimeoutExpired:\n\n            return {\n\n                'success': False,\n\n                'output': '',\n\n                'error': f\"Script '{script_name}' timed out after {timeout // 60 if timeout else 'N/A'} minutes\",\n\n                'returncode': None\n\n            }\n\n    def run_analyze_documentation(self, include_overlap: bool = False) -> Dict:\n\n        \"\"\"Run analyze_documentation with structured JSON handling.\"\"\"\n\n        args = [\"--json\"]\n        if include_overlap:\n            args.append(\"--overlap\")\n        \n        # Before running, check if we have cached overlap data to preserve\n        cached_overlap_data = None\n        cached_overlap_in_details = False\n        if not include_overlap:\n            # Try to load existing cached data that might have overlap analysis\n            try:\n                from .output_storage import load_tool_result\n                cached_data = load_tool_result('analyze_documentation', 'docs', project_root=self.project_root, normalize=False)\n                if cached_data and isinstance(cached_data, dict):\n                    cached_data_dict = cached_data.get('data', cached_data)\n                    # Check both top level and details for overlap data\n                    details = cached_data_dict.get('details', {})\n                    # Check if overlap data exists in cached data\n                    has_section_overlaps = 'section_overlaps' in cached_data_dict or 'section_overlaps' in details\n                    has_consolidation = 'consolidation_recommendations' in cached_data_dict or 'consolidation_recommendations' in details\n                    if has_section_overlaps or has_consolidation:\n                        # Determine if overlap data is in details or top level\n                        cached_overlap_in_details = ('section_overlaps' in details or 'consolidation_recommendations' in details)\n                        cached_overlap_data = {\n                            'section_overlaps': details.get('section_overlaps') if cached_overlap_in_details else cached_data_dict.get('section_overlaps'),\n                            'consolidation_recommendations': details.get('consolidation_recommendations') if cached_overlap_in_details else cached_data_dict.get('consolidation_recommendations')\n                        }\n            except Exception as e:\n                logger.debug(f\"Failed to load cached overlap data: {e}\")\n        \n        result = self.run_script(\"analyze_documentation\", *args)\n\n        output = result.get('output', '')\n\n        data = None\n\n        if output:\n\n            try:\n\n                data = json.loads(output)\n\n            except json.JSONDecodeError:\n\n                data = None\n\n        if data is not None:\n            # If we have cached overlap data and new data doesn't include it, merge it in\n            if cached_overlap_data and not include_overlap:\n                # Check if new data has overlap keys (it shouldn't if --overlap wasn't used)\n                details = data.get('details', {})\n                has_overlap = ('section_overlaps' in data or 'consolidation_recommendations' in data or\n                              'section_overlaps' in details or 'consolidation_recommendations' in details)\n                if not has_overlap:\n                    # Preserve overlap data in the same location it was found (top level or details)\n                    if cached_overlap_in_details:\n                        # Put in details section\n                        if 'details' not in data:\n                            data['details'] = {}\n                        if cached_overlap_data.get('section_overlaps'):\n                            data['details']['section_overlaps'] = cached_overlap_data['section_overlaps']\n                        if cached_overlap_data.get('consolidation_recommendations'):\n                            data['details']['consolidation_recommendations'] = cached_overlap_data['consolidation_recommendations']\n                    else:\n                        # Put at top level\n                        if cached_overlap_data.get('section_overlaps'):\n                            data['section_overlaps'] = cached_overlap_data['section_overlaps']\n                        if cached_overlap_data.get('consolidation_recommendations'):\n                            data['consolidation_recommendations'] = cached_overlap_data['consolidation_recommendations']\n                    logger.debug(\"Preserved cached overlap analysis data in new results\")\n\n            result['data'] = data\n\n            self.results_cache['analyze_documentation'] = data\n\n            # Save to standardized storage\n            try:\n                save_tool_result('analyze_documentation', 'docs', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_documentation result: {e}\")\n\n            result['issues_found'] = bool(data.get('duplicates') or data.get('placeholders') or data.get('missing'))\n\n            result['success'] = True\n\n            result['error'] = ''\n\n        else:\n\n            lowered = output.lower() if isinstance(output, str) else ''\n\n            if not result.get('success') and (\"verbatim duplicate\" in lowered or \"placeholder\" in lowered):\n\n                result['issues_found'] = True\n\n                result['success'] = True\n\n                result['error'] = ''\n\n        return result\n\n    def run_analyze_function_registry(self) -> Dict:\n\n        \"\"\"Run analyze_function_registry with structured JSON handling.\"\"\"\n\n        result = self.run_script(\"analyze_function_registry\", \"--json\")\n        \n        # Log stderr for debugging (includes our debug_print output)\n        stderr_output = result.get('error', '')\n        if stderr_output:\n            # Log at INFO level so it's visible, and include in error message\n            logger.info(f\"analyze_function_registry stderr output: {stderr_output}\")\n            # Check if there's a traceback in stderr that we should log\n            if 'Traceback' in stderr_output or 'File \"' in stderr_output:\n                logger.error(f\"analyze_function_registry traceback found in stderr:\\n{stderr_output}\")\n            if not result.get('success'):\n                # Include stderr in the error message for better debugging\n                original_error = result.get('error', '')\n                result['error'] = f\"{original_error}\\nStderr: {stderr_output}\" if original_error != stderr_output else stderr_output\n\n        output = result.get('output', '')\n\n        data = None\n\n        if output:\n\n            try:\n\n                data = json.loads(output)\n\n            except json.JSONDecodeError:\n\n                data = None\n\n        if data is not None:\n\n            result['data'] = data\n\n            # Save to standardized storage\n            try:\n                save_tool_result('analyze_function_registry', 'functions', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_function_registry result: {e}\")\n\n            missing = data.get('missing', {}) if isinstance(data.get('missing'), dict) else data.get('missing')\n\n            extra = data.get('extra', {}) if isinstance(data.get('extra'), dict) else data.get('extra')\n\n            errors = data.get('errors') or []\n\n            missing_count = missing.get('count') if isinstance(missing, dict) else missing\n\n            extra_count = extra.get('count') if isinstance(extra, dict) else extra\n\n            result['issues_found'] = bool(missing_count or extra_count or errors)\n\n            result['success'] = True\n\n            result['error'] = ''\n\n        else:\n\n            lowered = output.lower() if isinstance(output, str) else ''\n\n            if 'missing from registry' in lowered or 'missing items' in lowered or 'extra functions' in lowered:\n\n                result['issues_found'] = True\n\n                result['success'] = True\n\n                result['error'] = ''\n\n        return result\n\n    def run_analyze_module_dependencies(self) -> Dict:\n\n        \"\"\"Run analyze_module_dependencies and capture dependency drift summary.\"\"\"\n\n        result = self.run_script(\"analyze_module_dependencies\")\n\n        output = result.get('output', '')\n\n        summary = self._parse_module_dependency_report(output)\n\n        if summary:\n\n            result['data'] = summary\n\n            # Save to standardized storage\n            try:\n                save_tool_result('analyze_module_dependencies', 'imports', summary, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_module_dependencies result: {e}\")\n\n            issues = summary.get('missing_dependencies', 0)\n\n            issues = issues or len(summary.get('missing_sections') or [])\n\n            result['issues_found'] = bool(issues)\n\n            # preserve success flag if script executed; default to True when stdout parsed\n\n            if 'success' not in result:\n\n                result['success'] = True\n\n            self.module_dependency_summary = summary\n\n            self.results_cache['analyze_module_dependencies'] = summary\n\n        return result\n\n    def run_analyze_functions(self) -> Dict:\n\n        \"\"\"Run analyze_functions with structured JSON handling.\"\"\"\n\n        # Build command line arguments based on exclusion configuration\n\n        args = [\"--json\"]  # Always request JSON output for parsing\n\n        if self.exclusion_config.get('include_tests', False):\n\n            args.append(\"--include-tests\")\n\n        if self.exclusion_config.get('include_dev_tools', False):\n\n            args.append(\"--include-dev-tools\")\n\n        result = self.run_script(\"analyze_functions\", *args)\n\n        # Parse JSON output if available\n        if result.get('success') and result.get('output'):\n            try:\n                import json\n                json_data = json.loads(result['output'])\n                result['data'] = json_data\n                \n                # Merge in examples extracted from text output (if available)\n                if 'analyze_functions' in self.results_cache:\n                    extracted_metrics = self.results_cache['analyze_functions']\n                    # Merge examples into json_data\n                    if 'critical_complexity_examples' in extracted_metrics:\n                        json_data['critical_complexity_examples'] = extracted_metrics['critical_complexity_examples']\n                    if 'high_complexity_examples' in extracted_metrics:\n                        json_data['high_complexity_examples'] = extracted_metrics['high_complexity_examples']\n                    if 'undocumented_examples' in extracted_metrics:\n                        json_data['undocumented_examples'] = extracted_metrics['undocumented_examples']\n                \n                # Save to standardized storage (with examples included)\n                try:\n                    save_tool_result('analyze_functions', 'functions', json_data, project_root=self.project_root)\n                    # Also update results_cache with merged data\n                    self.results_cache['analyze_functions'] = json_data\n                except Exception as e:\n                    logger.warning(f\"Failed to save analyze_functions result: {e}\")\n            except (json.JSONDecodeError, ValueError) as e:\n                logger.warning(f\"Failed to parse analyze_functions JSON output: {e}\")\n\n        return result\n\n    def run_decision_support(self) -> Dict:\n\n        \"\"\"Run decision_support with structured JSON handling.\"\"\"\n\n        # Build command line arguments based on exclusion configuration\n\n        args = []\n\n        if self.exclusion_config.get('include_tests', False):\n\n            args.append(\"--include-tests\")\n\n        if self.exclusion_config.get('include_dev_tools', False):\n\n            args.append(\"--include-dev-tools\")\n\n        result = self.run_script(\"decision_support\", *args)\n        \n        # Extract insights from text output\n        self._extract_decision_insights(result)\n        \n        # Always try to save, even if result.get('success') is False (script might have output)\n        try:\n            from .output_storage import save_tool_result\n            # Use extracted insights if available, otherwise try to parse output\n            data = None\n            # Check both cache keys (metrics might be stored under either)\n            if 'decision_support_metrics' in self.results_cache:\n                data = self.results_cache['decision_support_metrics']\n                logger.info(\"Using decision_support_metrics from cache\")\n            elif 'decision_support' in self.results_cache:\n                data = self.results_cache['decision_support']\n                logger.info(\"Using decision_support from cache\")\n            elif result.get('data'):\n                data = result.get('data')\n                logger.info(\"Using data from result\")\n            elif result.get('output'):\n                try:\n                    import json\n                    data = json.loads(result.get('output', ''))\n                    logger.info(\"Parsed JSON from output\")\n                except (json.JSONDecodeError, TypeError):\n                    # If output is not JSON, create structured data from result\n                    data = {\n                        'success': result.get('success', False),\n                        'output': result.get('output', ''),\n                        'error': result.get('error', ''),\n                        'returncode': result.get('returncode', 0)\n                    }\n                    logger.info(\"Created structured data from output\")\n            \n            # Always save something - prefer extracted metrics, fallback to metadata\n            # Even if metrics dict is empty, we should save it (it's still valid data)\n            if data is not None:\n                logger.info(f\"Attempting to save decision_support results (data type: {type(data).__name__})\")\n                save_tool_result('decision_support', 'reports', data, project_root=self.project_root)\n                if isinstance(data, dict):\n                    logger.info(f\"Saved decision_support results with {len(data)} keys: {list(data.keys())[:5]}\")\n                else:\n                    logger.info(\"Saved decision_support results (non-dict data)\")\n            else:\n                # Fallback: save at least the result metadata\n                logger.info(\"No data extracted from decision_support, saving result metadata\")\n                save_tool_result('decision_support', 'reports', {\n                    'success': result.get('success', False),\n                    'output': result.get('output', '')[:500] if result.get('output') else '',  # Truncate long output\n                    'returncode': result.get('returncode', 0)\n                }, project_root=self.project_root)\n                logger.info(\"Saved decision_support result metadata\")\n        except Exception as save_error:\n            logger.error(f\"Failed to save decision_support results: {save_error}\", exc_info=True)\n\n        return result\n\n    def run_analyze_function_patterns(self) -> Dict:\n        \"\"\"Run analyze_function_patterns and save results.\"\"\"\n        try:\n            from .output_storage import save_tool_result\n            from ..functions.analyze_function_patterns import analyze_function_patterns\n            from ..functions.analyze_functions import scan_all_python_files\n            \n            # Get function data\n            actual_functions = scan_all_python_files()\n            \n            # Analyze patterns\n            patterns = analyze_function_patterns(actual_functions)\n            \n            # Save to standardized storage\n            save_tool_result('analyze_function_patterns', 'functions', patterns, project_root=self.project_root)\n            \n            return {\n                'success': True,\n                'data': patterns\n            }\n        except Exception as e:\n            logger.warning(f\"Failed to run analyze_function_patterns: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n\n    def run_analyze_module_imports(self) -> Dict:\n        \"\"\"Run analyze_module_imports and save results.\"\"\"\n        try:\n            from .output_storage import save_tool_result\n            from ..imports.analyze_module_imports import ModuleImportAnalyzer\n            \n            # Initialize analyzer\n            analyzer = ModuleImportAnalyzer(project_root=str(self.project_root))\n            \n            # Scan all Python files\n            import_data = analyzer.scan_all_python_files()\n            \n            # Save to standardized storage\n            save_tool_result('analyze_module_imports', 'imports', import_data, project_root=self.project_root)\n            \n            return {\n                'success': True,\n                'data': import_data\n            }\n        except Exception as e:\n            logger.warning(f\"Failed to run analyze_module_imports: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n\n    def run_analyze_dependency_patterns(self) -> Dict:\n        \"\"\"Run analyze_dependency_patterns and save results.\"\"\"\n        try:\n            from .output_storage import save_tool_result\n            from ..imports.analyze_module_imports import ModuleImportAnalyzer\n            from ..imports.analyze_dependency_patterns import DependencyPatternAnalyzer\n            \n            # Get import data first\n            import_analyzer = ModuleImportAnalyzer(project_root=str(self.project_root))\n            actual_imports = import_analyzer.scan_all_python_files()\n            \n            # Analyze dependency patterns\n            pattern_analyzer = DependencyPatternAnalyzer()\n            patterns = pattern_analyzer.analyze_dependency_patterns(actual_imports)\n            \n            # Save to standardized storage\n            save_tool_result('analyze_dependency_patterns', 'imports', patterns, project_root=self.project_root)\n            \n            return {\n                'success': True,\n                'data': patterns\n            }\n        except Exception as e:\n            logger.warning(f\"Failed to run analyze_dependency_patterns: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n\n    def run_analyze_package_exports(self) -> Dict:\n        \"\"\"Run analyze_package_exports and save results.\"\"\"\n        try:\n            from .output_storage import save_tool_result\n            from ..functions.analyze_package_exports import generate_audit_report\n            \n            # Audit all packages\n            packages = ['core', 'communication', 'ui', 'tasks', 'ai', 'user']\n            all_reports = {}\n            \n            for package in packages:\n                try:\n                    report = generate_audit_report(package)\n                    # Convert sets to lists for JSON serialization\n                    if isinstance(report, dict):\n                        # Convert all sets to sorted lists\n                        for key, value in report.items():\n                            if isinstance(value, set):\n                                report[key] = sorted(value)\n                            elif isinstance(value, dict):\n                                # Recursively convert sets in nested dicts\n                                for nested_key, nested_value in value.items():\n                                    if isinstance(nested_value, set):\n                                        value[nested_key] = sorted(nested_value)\n                    all_reports[package] = report\n                except Exception as e:\n                    logger.warning(f\"Failed to audit package {package}: {e}\")\n                    all_reports[package] = {\n                        'package': package,\n                        'error': str(e),\n                        'missing_exports': [],\n                        'potentially_unnecessary': []\n                    }\n            \n            # Aggregate summary\n            total_missing = sum(len(r.get('missing_exports', [])) for r in all_reports.values())\n            total_unnecessary = sum(len(r.get('potentially_unnecessary', [])) for r in all_reports.values())\n            packages_with_missing = sum(1 for r in all_reports.values() if r.get('missing_exports'))\n            \n            summary = {\n                'total_missing_exports': total_missing,\n                'total_unnecessary_exports': total_unnecessary,\n                'packages_with_missing': packages_with_missing\n            }\n            \n            result_data = {\n                'summary': summary,\n                'packages': all_reports\n            }\n            \n            # Save to standardized storage\n            save_tool_result('analyze_package_exports', 'functions', result_data, project_root=self.project_root)\n            \n            return {\n                'success': True,\n                'data': result_data\n            }\n        except Exception as e:\n            logger.warning(f\"Failed to run analyze_package_exports: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n\n    def run_analyze_error_handling(self) -> Dict:\n\n        \"\"\"Run analyze_error_handling with structured JSON handling.\"\"\"\n\n        # Build command line arguments based on exclusion configuration\n\n        args = [\"--json\"]\n\n        if self.exclusion_config.get('include_tests', False):\n\n            args.append(\"--include-tests\")\n\n        if self.exclusion_config.get('include_dev_tools', False):\n\n            args.append(\"--include-dev-tools\")\n\n        result = self.run_script(\"analyze_error_handling\", *args)\n\n        output = result.get('output', '')\n\n        data = None\n\n        if output:\n\n            try:\n\n                # Find the JSON part in the output (after the text)\n\n                lines = output.split('\\n')\n\n                json_start = -1\n\n                for i, line in enumerate(lines):\n\n                    if line.strip().startswith('{'):\n\n                        json_start = i\n\n                        break\n\n                if json_start >= 0:\n\n                    json_output = '\\n'.join(lines[json_start:])\n\n                    data = json.loads(json_output)\n\n                else:\n\n                    # Fallback: try to parse the entire output\n\n                    data = json.loads(output)\n\n            except json.JSONDecodeError:\n\n                data = None\n\n        # If JSON parsing from stdout failed, try reading from the file\n        # LEGACY COMPATIBILITY: Reading from old file location for backward compatibility\n        # New standardized storage location: error_handling/jsons/analyze_error_handling_results.json\n        # Removal plan: After analyze_error_handling.py is updated to use standardized storage, remove this fallback.\n        # Detection: Search for \"error_handling_details.json\" to find all references.\n        if data is None:\n            try:\n                # Try old file location first (backward compatibility)\n                json_file = self.project_root / 'development_tools' / 'error_handling' / 'jsons' / 'error_handling_details.json'\n                if json_file.exists():\n                    with open(json_file, 'r', encoding='utf-8') as f:\n                        file_data = json.load(f)\n                    # Handle new structure with metadata wrapper\n                    if 'error_handling_results' in file_data:\n                        data = file_data['error_handling_results']\n                    else:\n                        # Fallback to old structure (direct results)\n                        data = file_data\n                else:\n                    # Try new standardized storage location\n                    from .output_storage import load_tool_result\n                    data = load_tool_result('analyze_error_handling', 'error_handling', project_root=self.project_root)\n            except (OSError, json.JSONDecodeError):\n                data = None\n\n        if data is not None:\n\n            result['data'] = data\n\n            # Save to standardized storage\n            try:\n                save_tool_result('analyze_error_handling', 'error_handling', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_error_handling result: {e}\")\n\n            # Check for issues in error handling coverage\n            # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n            coverage = data.get('analyze_error_handling') or data.get('error_handling_coverage', 0)\n\n            missing_count = data.get('functions_missing_error_handling', 0)\n\n            result['issues_found'] = coverage < 80 or missing_count > 0\n\n            result['success'] = True\n\n            result['error'] = ''\n\n        else:\n\n            lowered = output.lower() if isinstance(output, str) else ''\n\n            if 'missing error handling' in lowered or 'coverage' in lowered:\n\n                result['issues_found'] = True\n\n                result['success'] = True\n\n                result['error'] = ''\n\n        return result\n\n    def run_analyze_documentation_sync(self) -> Dict:\n        \"\"\"Run analyze_documentation_sync with structured data handling.\"\"\"\n        try:\n            # Use _run_doc_sync_check to get all aggregated data (paired docs, path drift, ASCII, heading numbering, etc.)\n            if self._run_doc_sync_check('--check'):\n                # Get aggregated summary and all results\n                summary = self.docs_sync_summary or {}\n                all_results = getattr(self, 'docs_sync_results', {}).get('all_results', {})\n                \n                # Convert to the expected format for JSON output\n                data = {\n                    'status': summary.get('status', 'UNKNOWN'),\n                    'total_issues': summary.get('total_issues', 0),\n                    'paired_doc_issues': summary.get('paired_doc_issues', 0),\n                    'path_drift_issues': summary.get('path_drift_issues', 0),\n                    'ascii_compliance_issues': summary.get('ascii_issues', 0),  # Note: summary uses 'ascii_issues' key\n                    'heading_numbering_issues': summary.get('heading_numbering_issues', 0),\n                    'path_drift_files': summary.get('path_drift_files', []),\n                    # Store detailed issues for each category\n                    'paired_docs': all_results.get('paired_docs', {}),\n                    'path_drift': all_results.get('path_drift', {}),\n                    'ascii_compliance': all_results.get('ascii_compliance', {}),\n                    'heading_numbering': all_results.get('heading_numbering', {})\n                }\n                \n                # Generate text output for compatibility\n                import io\n                import sys\n                output_buffer = io.StringIO()\n                original_stdout = sys.stdout\n                sys.stdout = output_buffer\n                try:\n                    # Import and use DocumentationSyncChecker for text output\n                    from ..docs.analyze_documentation_sync import DocumentationSyncChecker\n                    checker = DocumentationSyncChecker()\n                    # Create a results dict compatible with print_report\n                    results = {\n                        'summary': summary,\n                        'paired_docs': all_results.get('paired_docs', {}),\n                        'path_drift': all_results.get('path_drift', {}),\n                        'ascii_compliance': all_results.get('ascii_compliance', {}),\n                        'heading_numbering': all_results.get('heading_numbering', {})\n                    }\n                    checker.print_report(results)\n                    output = output_buffer.getvalue()\n                finally:\n                    sys.stdout = original_stdout\n                \n                # Save to standardized storage\n                try:\n                    from .output_storage import save_tool_result\n                    save_tool_result('analyze_documentation_sync', 'docs', data, project_root=self.project_root)\n                except Exception as e:\n                    logger.warning(f\"Failed to save analyze_documentation_sync result: {e}\")\n                \n                return {\n                    'success': True,\n                    'output': output,\n                    'error': '',\n                    'returncode': 0,\n                    'data': data\n                }\n            else:\n                # _run_doc_sync_check failed, fall through to fallback\n                raise Exception(\"_run_doc_sync_check returned False\")\n        except Exception as e:\n            logger.error(f\"Error running documentation sync checker: {e}\")\n            # Fallback to subprocess method\n        result = self.run_script(\"analyze_documentation_sync\", \"--check\")\n        output = result.get('output', '')\n        data = None\n        \n        if output:\n            try:\n                # Try to parse JSON output if available\n                data = json.loads(output)\n            except json.JSONDecodeError:\n                # If not JSON, create structured data from text output\n                data = self._parse_documentation_sync_output(output)\n        \n        if data is not None:\n            result['data'] = data\n            \n            # Save to standardized storage\n            try:\n                from .output_storage import save_tool_result\n                save_tool_result('analyze_documentation_sync', 'docs', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_documentation_sync result: {e}\")\n            \n            result['success'] = True\n            result['error'] = ''\n        else:\n            result['success'] = False\n            result['error'] = f'Failed to parse documentation sync output: {e}'\n        \n        return result\n\n    def run_analyze_path_drift(self) -> Dict:\n        \"\"\"Run analyze_path_drift with structured data handling.\"\"\"\n        try:\n            # Import and call the analyzer directly to get structured data\n            from ..docs.analyze_path_drift import PathDriftAnalyzer\n            \n            analyzer = PathDriftAnalyzer()\n            structured_results = analyzer.run_analysis()\n            \n            # LEGACY COMPATIBILITY: Handle both standard format (new) and legacy format (old)\n            # Standard format uses 'summary' key; legacy format has 'total_issues' at top level\n            # Removal plan: After all tools are migrated to standard format, remove legacy format handling.\n            # Detection: Search for \"Legacy format (backward compatibility)\" in this file.\n            if 'summary' in structured_results:\n                # Standard format\n                summary = structured_results.get('summary', {})\n                data = {\n                    'files': structured_results.get('files', {}),\n                    'total_issues': summary.get('total_issues', 0),\n                    'detailed_issues': structured_results.get('details', {}).get('detailed_issues', {})\n                }\n            else:\n                # Legacy format (backward compatibility)\n                logger.debug(\"analyze_path_drift: Using legacy format (backward compatibility)\")\n                data = {\n                    'files': structured_results.get('files', {}),\n                    'total_issues': structured_results.get('total_issues', 0),\n                    'detailed_issues': structured_results.get('detailed_issues', {})\n                }\n            \n            # Generate text output for compatibility\n            import io\n            import sys\n            output_buffer = io.StringIO()\n            original_stdout = sys.stdout\n            sys.stdout = output_buffer\n            try:\n                # Print in the format expected by _parse_path_drift_output\n                if data['total_issues'] > 0:\n                    print(f\"\\nPath Drift Issues:\")\n                    print(f\"   Total files with issues: {len(data['files'])}\")\n                    print(f\"   Total issues found: {data['total_issues']}\")\n                    print(f\"   Top files with most issues:\")\n                    sorted_files = sorted(data['files'].items(), key=lambda x: x[1], reverse=True)\n                    for doc_file, issue_count in sorted_files[:5]:\n                        print(f\"     {doc_file}: {issue_count} issues\")\n                else:\n                    print(\"\\nNo path drift issues found!\")\n                output = output_buffer.getvalue()\n            finally:\n                sys.stdout = original_stdout\n            \n            # Save to standardized storage\n            try:\n                from .output_storage import save_tool_result\n                save_tool_result('analyze_path_drift', 'docs', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_path_drift result: {e}\")\n            \n            return {\n                'success': True,\n                'output': output,\n                'error': '',\n                'returncode': 0,\n                'data': data\n            }\n        except Exception as e:\n            logger.error(f\"Error running path drift analyzer: {e}\", exc_info=True)\n            # Fallback to subprocess method - use unified helper to load from cache first\n            result = self.run_script(\"analyze_path_drift\", '--json')\n            try:\n                cache_file = self.project_root / \"development_tools\" / \"docs\" / \"jsons\" / \".analyze_path_drift_cache.json\"\n                \n                # Custom converter for path drift format (includes detailed_issues)\n                def path_drift_converter(file_data: Dict[str, Any]) -> Dict[str, Any]:\n                    files_with_issues = {}\n                    detailed_issues = {}\n                    total_issues = 0\n                    for file_path, file_info in file_data.items():\n                        if isinstance(file_info, dict):\n                            results = file_info.get('results', [])\n                            if results:\n                                files_with_issues[file_path] = len(results)\n                                detailed_issues[file_path] = results\n                                total_issues += len(results)\n                    return {\n                        'files': files_with_issues,\n                        'total_issues': total_issues,\n                        'detailed_issues': detailed_issues\n                    }\n                \n                data = self._load_mtime_cached_tool_results(\n                    'analyze_path_drift',\n                    'docs',\n                    cache_file,\n                    result,\n                    self._parse_path_drift_output,\n                    path_drift_converter\n                )\n                \n                if data:\n                    result['data'] = data\n                    result['success'] = True\n                    result['error'] = ''\n                else:\n                    result['success'] = False\n                    result['error'] = f'Failed to load path drift results: {e}'\n            except Exception as helper_error:\n                logger.debug(f\"Failed to use unified helper for path drift fallback: {helper_error}\")\n                # Ultimate fallback: parse output directly\n                output = result.get('output', '')\n                data = None\n                if output:\n                    try:\n                        data = json.loads(output)\n                    except json.JSONDecodeError:\n                        data = self._parse_path_drift_output(output)\n                \n                if data:\n                    try:\n                        from .output_storage import save_tool_result\n                        save_tool_result('analyze_path_drift', 'docs', data, project_root=self.project_root)\n                    except Exception as save_error:\n                        logger.warning(f\"Failed to save analyze_path_drift result: {save_error}\")\n                    result['data'] = data\n                    result['success'] = True\n                    result['error'] = ''\n                else:\n                    result['success'] = False\n                    result['error'] = f'Failed to parse path drift output: {e}'\n        \n        return result\n\n    def _parse_documentation_sync_output(self, output: str) -> Dict:\n        \"\"\"Parse documentation sync checker text output into structured data.\"\"\"\n        data = {\n            'path_drift_issues': 0,\n            'paired_doc_issues': 0,\n            'ascii_issues': 0,\n            'path_drift_files': [],\n            'status': 'UNKNOWN'\n        }\n        \n        lines = output.split('\\n')\n        for line in lines:\n            line = line.strip()\n            if 'Path drift issues:' in line:\n                try:\n                    data['path_drift_issues'] = int(line.split(':')[1].strip())\n                except (ValueError, IndexError):\n                    pass\n            elif 'Paired documentation issues:' in line:\n                try:\n                    data['paired_doc_issues'] = int(line.split(':')[1].strip())\n                except (ValueError, IndexError):\n                    pass\n            elif 'ASCII compliance issues:' in line:\n                try:\n                    data['ascii_issues'] = int(line.split(':')[1].strip())\n                except (ValueError, IndexError):\n                    pass\n            elif 'Overall status:' in line:\n                data['status'] = line.split(':')[1].strip()\n        \n        return data\n\n    def run_analyze_legacy_references(self) -> Dict:\n        \"\"\"Run analyze_legacy_references with structured data handling.\"\"\"\n        try:\n            # Import and call the analyzer directly to get structured data\n            from ..legacy.analyze_legacy_references import LegacyReferenceAnalyzer\n            \n            analyzer = LegacyReferenceAnalyzer(project_root=str(self.project_root))\n            findings = analyzer.scan_for_legacy_references()\n            \n            # Calculate summary statistics\n            total_files = sum(len(files) for files in findings.values())\n            total_markers = sum(len(matches) for files in findings.values() for _, _, matches in files)\n            \n            # Convert findings to JSON-serializable format\n            # Findings is Dict[str, List[Tuple[str, str, List[Dict]]]]\n            # We need to convert tuples to lists for JSON serialization\n            serializable_findings = {}\n            for pattern_type, file_list in findings.items():\n                serializable_findings[pattern_type] = [\n                    [file_path, content, matches] for file_path, content, matches in file_list\n                ]\n            \n            data = {\n                'findings': serializable_findings,\n                'files_with_issues': total_files,\n                'legacy_markers': total_markers,\n                'report_path': 'development_docs/LEGACY_REFERENCE_REPORT.md'\n            }\n            \n            # Save to standardized storage\n            try:\n                from .output_storage import save_tool_result\n                save_tool_result('analyze_legacy_references', 'legacy', data, project_root=self.project_root)\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_legacy_references result: {e}\")\n            \n            # Store in results_cache and legacy_cleanup_summary\n            self.results_cache['analyze_legacy_references'] = data\n            self.legacy_cleanup_summary = data\n            \n            return {\n                'success': True,\n                'output': f\"Found {total_files} files with {total_markers} legacy markers\",\n                'error': '',\n                'returncode': 0,\n                'data': data\n            }\n        except Exception as e:\n            logger.error(f\"Failed to run analyze_legacy_references: {e}\")\n            return {\n                'success': False,\n                'output': '',\n                'error': str(e),\n                'returncode': 1,\n                'data': None\n            }\n\n    def run_analyze_unused_imports(self) -> Dict:\n\n        \"\"\"Run analyze_unused_imports with structured JSON handling.\"\"\"\n\n        # Use longer timeout for this script (10 minutes) as it runs pylint on many files\n\n        script_path = Path(__file__).resolve().parent.parent / 'imports' / 'analyze_unused_imports.py'\n\n        cmd = [sys.executable, str(script_path), '--json']\n\n        try:\n\n            result_proc = subprocess.run(\n\n                cmd,\n\n                capture_output=True,\n\n                text=True,\n\n                cwd=str(self.project_root),\n\n                timeout=600  # 10 minute timeout for pylint operations\n\n            )\n\n            result = {\n\n                'success': result_proc.returncode == 0,\n\n                'output': result_proc.stdout,\n\n                'error': result_proc.stderr,\n\n                'returncode': result_proc.returncode\n\n            }\n\n        except subprocess.TimeoutExpired:\n\n            return {\n\n                'success': False,\n\n                'output': '',\n\n                'error': 'Unused imports checker timed out after 10 minutes',\n\n                'returncode': None,\n\n                'issues_found': False\n\n            }\n\n        output = result.get('output', '')\n\n        data = None\n\n        if output:\n\n            try:\n\n                data = json.loads(output)\n\n            except json.JSONDecodeError:\n\n                data = None\n\n        if data is not None:\n\n            result['data'] = data\n\n            self.results_cache['unused_imports'] = data\n\n            # Check for issues\n\n            total_unused = data.get('total_unused', 0)\n\n            result['issues_found'] = total_unused > 0\n\n            result['success'] = True\n\n            result['error'] = ''\n\n        else:\n\n            lowered = output.lower() if isinstance(output, str) else ''\n\n            if 'unused import' in lowered:\n\n                result['issues_found'] = True\n\n                result['success'] = True\n\n                result['error'] = ''\n\n        return result\n\n    # ===== SIMPLE COMMANDS (for users) =====\n\n    def run_audit(self, quick: bool = False, full: bool = False, include_overlap: bool = False):\n\n        \"\"\"Run audit workflow with three-tier structure.\n\n        Args:\n            quick: If True, run Tier 1 (quick audit) only\n            full: If True, run Tier 3 (full audit) - includes all tiers\n            include_overlap: Include overlap analysis in documentation checks\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        # Declare global flags at the start of the function\n        global _AUDIT_IN_PROGRESS_GLOBAL, _AUDIT_LOCK_FILE\n        \n        # Determine audit tier\n        if quick:\n            tier = 1\n            operation_name = \"audit --quick (Tier 1)\"\n        elif full:\n            tier = 3\n            operation_name = \"audit --full (Tier 3)\"\n        else:\n            tier = 2\n            operation_name = \"audit (Tier 2 - standard)\"\n\n        logger.info(f\"Starting {operation_name}...\")\n        logger.info(\"=\" * 50)\n\n        # Store audit tier for status file generation\n        self.current_audit_tier = tier\n        # Flag to prevent status file writes during audit (they should only happen at the end)\n        self._audit_in_progress = True\n        # Set global flag so even new instances know audit is in progress\n        _AUDIT_IN_PROGRESS_GLOBAL = True\n        \n        # Create file-based lock for cross-process protection (pytest-xdist workers)\n        if _AUDIT_LOCK_FILE is None:\n            _AUDIT_LOCK_FILE = self.project_root / 'development_tools' / '.audit_in_progress.lock'\n        try:\n            _AUDIT_LOCK_FILE.parent.mkdir(parents=True, exist_ok=True)\n            _AUDIT_LOCK_FILE.touch()\n        except Exception as e:\n            logger.warning(f\"Failed to create audit lock file: {e}\")\n        \n        # Track status file modification times at audit start (for detecting mid-audit writes)\n        initial_mtimes = _get_status_file_mtimes(self.project_root)\n        self._audit_start_mtimes = initial_mtimes\n\n        # Store overlap flag for tools that need it\n        self._include_overlap = include_overlap\n        if full and not include_overlap:\n            include_overlap = True\n            self._include_overlap = True\n\n        # Run tier-based tools\n        success = True\n        try:\n            # Tier 1: Quick audit tools (always run first)\n            logger.info(\"Running Tier 1 tools (quick audit)...\")\n            tier1_success = self._run_quick_audit_tools()\n            if not tier1_success:\n                success = False\n\n            # Tier 2: Standard audit tools (run if tier >= 2)\n            if tier >= 2:\n                logger.info(\"Running Tier 2 tools (standard audit)...\")\n                tier2_success = self._run_standard_audit_tools()\n                if not tier2_success:\n                    success = False\n\n            # Tier 3: Full audit tools (run if tier >= 3)\n            if tier >= 3:\n                logger.info(\"Running Tier 3 tools (full audit)...\")\n                tier3_success = self._run_full_audit_tools()\n                if not tier3_success:\n                    success = False\n\n        except Exception as e:\n            logger.error(f\"Error during audit execution: {e}\", exc_info=True)\n            success = False\n\n        # Save all tool results to central aggregation file\n        try:\n            self._save_audit_results_aggregated(tier)\n        except Exception as e:\n            logger.warning(f\"Failed to save aggregated audit results: {e}\")\n\n        # Reload all cache data to ensure we have the latest state before generating status\n        self._reload_all_cache_data()\n        \n        # Sync TODO.md with changelog BEFORE generating status reports\n        self._sync_todo_with_changelog()\n\n        # Validate referenced paths exist BEFORE generating status reports\n        # (so path validation results are available when status is generated)\n        try:\n            self._validate_referenced_paths()\n        except Exception as e:\n            logger.warning(f\"Path validation failed (non-blocking): {e}\")\n\n        # Generate all 4 output files ONCE at the end (not mid-audit)\n        # Ensure current_audit_tier is still set (defensive check)\n        if self.current_audit_tier is None:\n            logger.warning(f\"current_audit_tier is None at end of audit! Setting to tier {tier}\")\n        \n        try:\n            # Track status file modification times before final write (for detecting mid-audit writes)\n            pre_final_mtimes = _get_status_file_mtimes(self.project_root)\n            # Compare with audit start times and warn if files were modified during audit\n            if hasattr(self, '_audit_start_mtimes'):\n                for file_name, mtime in pre_final_mtimes.items():\n                    if mtime > self._audit_start_mtimes.get(file_name, 0):\n                        logger.warning(f\"Status file {file_name} was modified during audit (before final write)! Mtime changed from {self._audit_start_mtimes.get(file_name, 0)} to {mtime}\")\n            \n            # Temporarily clear global flag and lock file to allow end-of-audit writes\n            # (We're in run_audit()'s finally block, so this is the legitimate end-of-audit write)\n            was_audit_in_progress = _AUDIT_IN_PROGRESS_GLOBAL\n            _AUDIT_IN_PROGRESS_GLOBAL = False\n            \n            # Temporarily remove lock file to allow end-of-audit writes\n            if _AUDIT_LOCK_FILE and _AUDIT_LOCK_FILE.exists():\n                try:\n                    _AUDIT_LOCK_FILE.unlink()\n                except Exception as e:\n                    logger.warning(f\"Failed to temporarily remove audit lock file: {e}\")\n            \n            try:\n                # Create AI-optimized status document\n                try:\n                    ai_status = self._generate_ai_status_document()\n                except Exception as e:\n                    logger.warning(f\"Error generating AI_STATUS document: {e}\")\n                    ai_status = \"# AI Status\\n\\nError generating status document. Please run audit again.\"\n                ai_status_file = create_output_file(\"development_tools/AI_STATUS.md\", ai_status, project_root=self.project_root)\n\n                # Create AI-optimized priorities document\n                try:\n                    ai_priorities = self._generate_ai_priorities_document()\n                except Exception as e:\n                    logger.warning(f\"Error generating AI_PRIORITIES document: {e}\")\n                    ai_priorities = \"# AI Priorities\\n\\nError generating priorities document. Please run audit again.\"\n                ai_priorities_file = create_output_file(\"development_tools/AI_PRIORITIES.md\", ai_priorities, project_root=self.project_root)\n\n                # Create comprehensive consolidated report\n                try:\n                    consolidated_report = self._generate_consolidated_report()\n                except Exception as e:\n                    logger.warning(f\"Error generating consolidated report: {e}\")\n                    consolidated_report = \"Error generating consolidated report. Please run audit again.\"\n                consolidated_file = create_output_file(\"development_tools/consolidated_report.txt\", consolidated_report, project_root=self.project_root)\n                \n                # Verify all files were written (check mtimes)\n                post_final_mtimes = _get_status_file_mtimes(self.project_root)\n                for file_name, mtime in post_final_mtimes.items():\n                    if mtime <= pre_final_mtimes.get(file_name, 0):\n                        logger.warning(f\"Status file {file_name} mtime did not change during final write! Expected write but mtime unchanged.\")\n            finally:\n                # Restore global flag (will be cleared again in outer finally block)\n                _AUDIT_IN_PROGRESS_GLOBAL = was_audit_in_progress\n                \n                # Don't restore lock file - it will be removed in the outer finally block anyway\n                # (We're at the end of audit, so the lock should be removed)\n\n            # Check and trim AI_CHANGELOG entries to prevent bloat\n            # Wrap in try-except to prevent errors from blocking file generation\n            try:\n                self._check_and_trim_changelog_entries()\n            except Exception as e:\n                logger.warning(f\"Changelog trim check failed (non-blocking): {e}\")\n\n            # Check for documentation duplicates and placeholders\n            try:\n                self._check_documentation_quality()\n            except Exception as e:\n                logger.warning(f\"Documentation quality check failed (non-blocking): {e}\")\n\n            # Check ASCII compliance\n            try:\n                self._check_ascii_compliance()\n            except Exception as e:\n                logger.warning(f\"ASCII compliance check failed (non-blocking): {e}\")\n\n            # Audit completed\n            logger.info(\"=\" * 50)\n            if success:\n                logger.info(f\"Completed {operation_name} successfully!\")\n                logger.info(f\"* AI Status: {ai_status_file}\")\n                logger.info(f\"* AI Priorities: {ai_priorities_file}\")\n                logger.info(f\"* Consolidated Report: {consolidated_file}\")\n                logger.info(f\"* JSON Data: development_tools/reports/analysis_detailed_results.json\")\n                logger.info(\"* Check development_tools/reports/archive/ for previous runs\")\n            else:\n                logger.warning(f\"Completed {operation_name} with some errors (see above)\")\n        except Exception as e:\n            import traceback\n            logger.error(f\"Error generating status files: {e}\")\n            logger.error(f\"Full traceback:\\n{traceback.format_exc()}\")\n            success = False\n        finally:\n            # Clear audit flag after status files are written\n            self._audit_in_progress = False\n            # Clear global flag as well (already declared as global at function start)\n            _AUDIT_IN_PROGRESS_GLOBAL = False\n            logger.debug(\"Cleared global audit flag: _AUDIT_IN_PROGRESS_GLOBAL = False\")\n            \n            # Remove file-based lock\n            if _AUDIT_LOCK_FILE and _AUDIT_LOCK_FILE.exists():\n                try:\n                    _AUDIT_LOCK_FILE.unlink()\n                    logger.debug(f\"Removed audit lock file: {_AUDIT_LOCK_FILE}\")\n                except Exception as e:\n                    logger.warning(f\"Failed to remove audit lock file: {e}\")\n\n        return success\n\n    # NOTE: This method manually merges results from tools that run during run_status().\n    # TODO: Consider refactoring to use standardized storage (save_tool_result) instead of manual merging.\n    # This would make it consistent with the audit tier system.\n    def _save_additional_tool_results(self):\n        \"\"\"Save results from additional tools to the cached file\n        \n        This method manually merges results from tools that run during run_status() but aren't\n        part of the audit tier system. Consider refactoring to use standardized storage.\n        \"\"\"\n        try:\n            import json\n            from datetime import datetime\n            results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n            \n            # Load existing results\n            if results_file.exists():\n                with open(results_file, 'r', encoding='utf-8') as f:\n                    cached_data = json.load(f)\n            else:\n                cached_data = {'results': {}}\n            \n            # Add legacy cleanup results if available\n            if hasattr(self, 'legacy_cleanup_summary') and self.legacy_cleanup_summary:\n                cached_data['results']['fix_legacy_references'] = {\n                    'success': True,\n                    'data': self.legacy_cleanup_summary,\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Add validation results if available\n            if hasattr(self, 'validation_results') and self.validation_results:\n                cached_data['results']['analyze_ai_work'] = {\n                    'success': True,\n                    'data': self.validation_results,\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Add system signals results if available\n            if hasattr(self, 'system_signals') and self.system_signals:\n                cached_data['results']['system_signals'] = {\n                    'success': True,\n                    'data': self.system_signals,\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Add decision_support metrics if available\n            decision_metrics = self.results_cache.get('decision_support_metrics', {})\n            if decision_metrics:\n                cached_data['results']['decision_support'] = {\n                    'success': True,\n                    'data': {\n                        'decision_support_metrics': decision_metrics\n                    },\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Add aggregated doc sync summary if available\n            if hasattr(self, 'docs_sync_summary') and self.docs_sync_summary:\n                cached_data['results']['analyze_documentation_sync'] = {\n                    'success': True,\n                    'data': self.docs_sync_summary,\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Add analyze_documentation results if available (includes overlap data)\n            if 'analyze_documentation' in self.results_cache:\n                analyze_docs_data = self.results_cache['analyze_documentation']\n                cached_data['results']['analyze_documentation'] = {\n                    'success': True,\n                    'data': analyze_docs_data,\n                    'timestamp': datetime.now().isoformat()\n                }\n            \n            # Save updated results using create_output_file to ensure correct location and rotation\n            from ..shared.file_rotation import create_output_file\n            create_output_file(str(results_file), json.dumps(cached_data, indent=2), project_root=self.project_root)\n                \n        except Exception as e:\n            logger.warning(f\"Failed to save additional tool results: {e}\")\n\n    def _reload_all_cache_data(self):\n        \"\"\"Reload all cache data from disk to ensure we have the latest state before generating status files.\n        \n        Tries to load from standardized storage first, then falls back to central aggregation file.\n        \"\"\"\n        try:\n            # First, try loading from standardized storage (individual tool result files)\n            all_results = get_all_tool_results(project_root=self.project_root)\n            if all_results:\n                for tool_name, result_data in all_results.items():\n                    if isinstance(result_data, dict):\n                        tool_data = result_data.get('data', result_data)\n                        self.results_cache[tool_name] = tool_data\n                        # Special handling for analyze_documentation_sync to populate docs_sync_summary\n                        if tool_name == 'analyze_documentation_sync' and isinstance(tool_data, dict):\n                            self.docs_sync_summary = tool_data\n                        # Special handling for analyze_legacy_references to populate legacy_cleanup_summary\n                        if tool_name == 'analyze_legacy_references' and isinstance(tool_data, dict):\n                            self.legacy_cleanup_summary = tool_data\n            \n            # Also try loading from central aggregation file (backward compatibility fallback)\n            import json\n            results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n            \n            if results_file.exists():\n                with open(results_file, 'r', encoding='utf-8') as f:\n                    cached_data = json.load(f)\n                    \n                # Reload results_cache from cached data (only if not already loaded from standardized storage)\n                if 'results' in cached_data:\n                    for tool_name, tool_data in cached_data['results'].items():\n                        if tool_name not in self.results_cache and 'data' in tool_data:\n                            self.results_cache[tool_name] = tool_data['data']\n                    \n                    # Reload decision_support_metrics if present\n                    if 'decision_support' in cached_data['results']:\n                        ds_data = cached_data['results']['decision_support']\n                        if 'data' in ds_data and 'decision_support_metrics' in ds_data['data']:\n                            self.results_cache['decision_support_metrics'] = ds_data['data']['decision_support_metrics']\n                \n                # Reload doc sync summary if present (only if not already loaded from standardized storage)\n                if not self.docs_sync_summary and 'analyze_documentation_sync' in cached_data.get('results', {}):\n                    doc_sync_data = cached_data['results']['analyze_documentation_sync']\n                    if 'data' in doc_sync_data:\n                        self.docs_sync_summary = doc_sync_data['data']\n                \n                # Reload legacy cleanup summary if present (only if not already loaded from standardized storage)\n                if not hasattr(self, 'legacy_cleanup_summary') or not self.legacy_cleanup_summary:\n                    if 'analyze_legacy_references' in cached_data.get('results', {}):\n                        legacy_data = cached_data['results']['analyze_legacy_references']\n                        if 'data' in legacy_data:\n                            self.legacy_cleanup_summary = legacy_data['data']\n                \n                # Reload coverage summary\n                coverage_summary = self._load_coverage_summary()\n                if coverage_summary:\n                    # Coverage summary is loaded on-demand, but we ensure it's fresh\n                    pass\n                \n                # Reload dev tools coverage\n                if not hasattr(self, 'dev_tools_coverage_results') or not self.dev_tools_coverage_results:\n                    self._load_dev_tools_coverage()\n                \n                # Reload config validation summary (loaded on-demand in status generation)\n                # Reload module dependency summary (should already be in results_cache)\n                if 'analyze_module_dependencies' in cached_data.get('results', {}):\n                    dep_data = cached_data['results']['analyze_module_dependencies']\n                    if 'data' in dep_data:\n                        self.module_dependency_summary = dep_data['data']\n                        \n        except Exception as e:\n            logger.debug(f\"Failed to reload cache data: {e}\")\n\n    def _run_quick_audit_tools(self) -> bool:\n        \"\"\"Run Tier 1 tools: Quick audit (core metrics only).\n        \n        Returns:\n            True if all tools succeeded, False otherwise\n        \"\"\"\n        successful = []\n        failed = []\n        \n        # Tier 1 tools: Core metrics only\n        tier1_tools = [\n            ('analyze_functions', self.run_analyze_functions),\n            ('analyze_documentation_sync', self.run_analyze_documentation_sync),\n            ('system_signals', self.run_system_signals),\n        ]\n        \n        # Handle quick_status separately to parse JSON output\n        try:\n            logger.info(\"  - Running quick_status...\")\n            quick_status_result = self.run_script('quick_status', 'json')\n            if quick_status_result.get('success'):\n                self.status_results = quick_status_result\n                # Parse JSON and store in status_summary\n                output = quick_status_result.get('output', '')\n                if output:\n                    try:\n                        import json\n                        parsed = json.loads(output)\n                        self.status_summary = parsed\n                        quick_status_result['data'] = parsed\n                        # Save to standardized storage\n                        try:\n                            save_tool_result('quick_status', 'reports', parsed, project_root=self.project_root)\n                        except Exception as e:\n                            logger.debug(f\"Failed to save quick_status result: {e}\")\n                        successful.append('quick_status')\n                    except json.JSONDecodeError:\n                        logger.warning(\"  - quick_status output could not be parsed as JSON\")\n                        failed.append('quick_status')\n                else:\n                    failed.append('quick_status')\n            else:\n                failed.append('quick_status')\n                if quick_status_result.get('error'):\n                    logger.error(f\"  - quick_status failed: {quick_status_result['error']}\")\n        except Exception as exc:\n            failed.append('quick_status')\n            logger.error(f\"  - quick_status failed: {exc}\")\n        \n        for tool_name, tool_func in tier1_tools:\n            try:\n                logger.info(f\"  - Running {tool_name}...\")\n                result = tool_func()\n                \n                # Handle both dict and bool return types\n                if isinstance(result, dict):\n                    success = result.get('success', False)\n                    if 'data' in result:\n                        self._extract_key_info(tool_name, result)\n                else:\n                    success = bool(result)\n                \n                if success:\n                    successful.append(tool_name)\n                    # Save result to standardized storage if it has data\n                    if isinstance(result, dict) and 'data' in result:\n                        try:\n                            # Determine domain for tool using standardized function\n                            domain = _get_domain_from_tool_name(tool_name, self.project_root)\n                            save_tool_result(tool_name, domain, result['data'], project_root=self.project_root)\n                        except Exception as e:\n                            logger.debug(f\"Failed to save {tool_name} result: {e}\")\n                else:\n                    failed.append(tool_name)\n                    error_msg = result.get('error', 'Unknown error') if isinstance(result, dict) else str(result)\n                    logger.warning(f\"  - {tool_name} completed with issues: {error_msg}\")\n            except Exception as exc:\n                failed.append(tool_name)\n                logger.error(f\"  - {tool_name} failed: {exc}\")\n        \n        if failed:\n            logger.warning(f\"Tier 1 completed with {len(failed)} failure(s): {', '.join(failed)}\")\n        else:\n            logger.info(f\"Tier 1 completed successfully ({len(successful)} tools)\")\n        \n        return len(failed) == 0\n\n    def _run_standard_audit_tools(self) -> bool:\n        \"\"\"Run Tier 2 tools: Standard audit (quality checks).\n        \n        Note: Tier 1 tools are already run before this method is called.\n        \n        Returns:\n            True if all tools succeeded, False otherwise\n        \"\"\"\n        successful = []\n        failed = []\n        \n        # Tier 2 tools: Quality checks\n        tier2_tools = [\n            ('analyze_documentation', lambda: self.run_analyze_documentation(include_overlap=getattr(self, '_include_overlap', False))),\n            ('analyze_error_handling', self.run_analyze_error_handling),\n            ('decision_support', self.run_decision_support),\n            ('analyze_config', lambda: self.run_script('analyze_config')),\n            ('analyze_ai_work', self.run_validate),\n            # Doc validators (check if docs need regeneration)\n            ('analyze_function_registry', self.run_analyze_function_registry),\n            ('analyze_module_dependencies', self.run_analyze_module_dependencies),\n            # Import and pattern analysis (run after module_dependencies for dependency analysis)\n            ('analyze_module_imports', self.run_analyze_module_imports),\n            ('analyze_dependency_patterns', self.run_analyze_dependency_patterns),\n            # Function pattern analysis\n            ('analyze_function_patterns', self.run_analyze_function_patterns),\n            # Package exports analysis\n            ('analyze_package_exports', self.run_analyze_package_exports),\n        ]\n        \n        for tool_name, tool_func in tier2_tools:\n            try:\n                logger.info(f\"  - Running {tool_name}...\")\n                result = tool_func()\n                \n                # Handle both dict and bool return types\n                if isinstance(result, dict):\n                    success = result.get('success', False)\n                    if 'data' in result:\n                        self._extract_key_info(tool_name, result)\n                else:\n                    success = bool(result)\n                \n                if success:\n                    successful.append(tool_name)\n                    # Save result to standardized storage if it has data\n                    # Note: Some tools (like decision_support) save in their own methods,\n                    # but we also save here if data is present for consistency\n                    if isinstance(result, dict):\n                        data = result.get('data')\n                        if not data and result.get('output'):\n                            # Try to parse output as JSON\n                            try:\n                                import json\n                                data = json.loads(result.get('output', ''))\n                            except (json.JSONDecodeError, TypeError):\n                                pass\n                        if data:\n                            try:\n                                # Determine domain for tool using standardized function\n                                domain = _get_domain_from_tool_name(tool_name, self.project_root)\n                                save_tool_result(tool_name, domain, data, project_root=self.project_root)\n                            except Exception as e:\n                                logger.debug(f\"Failed to save {tool_name} result: {e}\")\n                else:\n                    failed.append(tool_name)\n                    error_msg = result.get('error', 'Unknown error') if isinstance(result, dict) else str(result)\n                    logger.warning(f\"  - {tool_name} completed with issues: {error_msg}\")\n            except Exception as exc:\n                failed.append(tool_name)\n                import traceback\n                exc_traceback = traceback.format_exc()\n                logger.error(f\"  - {tool_name} failed: {exc}\")\n                logger.error(f\"  - {tool_name} traceback:\\n{exc_traceback}\")\n        \n        if failed:\n            logger.warning(f\"Tier 2 completed with {len(failed)} failure(s): {', '.join(failed)}\")\n        else:\n            logger.info(f\"Tier 2 completed successfully ({len(successful)} tools)\")\n        \n        return len(failed) == 0\n\n    def _run_full_audit_tools(self) -> bool:\n        \"\"\"Run Tier 3 tools: Full audit (comprehensive analysis).\n        \n        Note: Tier 1 and Tier 2 tools are already run before this method is called.\n        \n        Returns:\n            True if all tools succeeded, False otherwise\n        \"\"\"\n        successful = []\n        failed = []\n        \n        # Tier 3 analyze tools\n        tier3_analyze_tools = [\n            ('generate_test_coverage', self.run_coverage_regeneration),\n            ('analyze_unused_imports', self.run_unused_imports_report),\n            ('analyze_legacy_references', self.run_analyze_legacy_references),\n        ]\n        \n        # Tier 3 report generators\n        tier3_report_tools = [\n            ('generate_legacy_reference_report', lambda: self.run_script('generate_legacy_reference_report')),\n            ('generate_test_coverage_reports', lambda: self.run_script('generate_test_coverage_reports')),\n            # Note: analyze_unused_imports generates UNUSED_IMPORTS_REPORT.md\n        ]\n        \n        # Run analyze tools\n        for tool_name, tool_func in tier3_analyze_tools:\n            try:\n                logger.info(f\"  - Running {tool_name}...\")\n                result = tool_func()\n                \n                # Handle both dict and bool return types\n                if isinstance(result, dict):\n                    success = result.get('success', False)\n                    if 'data' in result:\n                        self._extract_key_info(tool_name, result)\n                else:\n                    success = bool(result)\n                \n                if success:\n                    successful.append(tool_name)\n                    # Save result to standardized storage if it has data\n                    if isinstance(result, dict) and 'data' in result:\n                        try:\n                            # Determine domain for tool using standardized function\n                            domain = _get_domain_from_tool_name(tool_name, self.project_root)\n                            save_tool_result(tool_name, domain, result['data'], project_root=self.project_root)\n                        except Exception as e:\n                            logger.debug(f\"Failed to save {tool_name} result: {e}\")\n                else:\n                    failed.append(tool_name)\n                    error_msg = result.get('error', 'Unknown error') if isinstance(result, dict) else str(result)\n                    logger.warning(f\"  - {tool_name} completed with issues: {error_msg}\")\n            except Exception as exc:\n                failed.append(tool_name)\n                logger.error(f\"  - {tool_name} failed: {exc}\")\n        \n        # Run report generators\n        for tool_name, tool_func in tier3_report_tools:\n            try:\n                logger.info(f\"  - Running {tool_name} (report generation)...\")\n                # Prepare arguments for report generators\n                if tool_name == 'generate_legacy_reference_report':\n                    # Load legacy reference findings from standardized storage or results_cache\n                    try:\n                        # First try results_cache (data from current audit run)\n                        legacy_data = None\n                        if 'analyze_legacy_references' in self.results_cache:\n                            legacy_data = self.results_cache['analyze_legacy_references']\n                        else:\n                            # Try standardized storage\n                            from .output_storage import load_tool_result\n                            legacy_result = load_tool_result('analyze_legacy_references', 'legacy', project_root=self.project_root)\n                            if legacy_result:\n                                # load_tool_result already unwraps the 'data' key, so legacy_result IS the data\n                                legacy_data = legacy_result\n                        \n                        if legacy_data and isinstance(legacy_data, dict):\n                            # Extract findings from the data structure\n                            findings = legacy_data.get('findings', {})\n                            if findings:\n                                # Convert back to the format expected by generate_legacy_reference_report\n                                # Findings are stored as Dict[str, List[List]] (file_path, content, matches)\n                                # But generate_legacy_reference_report expects Dict[str, List[Tuple]]\n                                # We'll pass it as-is since JSON can handle lists\n                                import tempfile\n                                import json\n                                temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8')\n                                json.dump(findings, temp_file, indent=2)\n                                temp_file.close()\n                                result = self.run_script('generate_legacy_reference_report', '--findings-file', temp_file.name)\n                                # Clean up temp file\n                                try:\n                                    import os\n                                    os.unlink(temp_file.name)\n                                except Exception:\n                                    pass\n                                # Verify report was generated\n                                report_path = self.project_root / \"development_docs\" / \"LEGACY_REFERENCE_REPORT.md\"\n                                if report_path.exists():\n                                    logger.info(f\"  - Legacy reference report generated: {report_path}\")\n                                else:\n                                    logger.warning(f\"  - Legacy reference report not found at {report_path}\")\n                            else:\n                                logger.warning(f\"  - {tool_name}: No legacy reference findings found in data\")\n                                result = {'success': False, 'error': 'No legacy reference findings available'}\n                        else:\n                            logger.warning(f\"  - {tool_name}: No legacy reference data found in standardized storage or cache\")\n                            result = {'success': False, 'error': 'No legacy reference findings available'}\n                    except Exception as e:\n                        logger.warning(f\"  - {tool_name}: Failed to load findings: {e}\")\n                        result = {'success': False, 'error': str(e)}\n                elif tool_name == 'generate_test_coverage_reports':\n                    # Use coverage.json from project root\n                    coverage_json = self.project_root / 'coverage.json'\n                    if coverage_json.exists():\n                        result = self.run_script('generate_test_coverage_reports', '--input', str(coverage_json))\n                    else:\n                        logger.warning(f\"  - {tool_name}: coverage.json not found at {coverage_json}\")\n                        result = {'success': False, 'error': f'coverage.json not found at {coverage_json}'}\n                else:\n                    result = tool_func()\n                \n                if isinstance(result, dict):\n                    success = result.get('success', False)\n                    # Save result if available\n                    if success and 'data' in result:\n                        try:\n                            # Determine domain for tool using standardized function\n                            domain = _get_domain_from_tool_name(tool_name, self.project_root)\n                            save_tool_result(tool_name, domain, result['data'], project_root=self.project_root)\n                        except Exception as e:\n                            logger.debug(f\"Failed to save {tool_name} result: {e}\")\n                else:\n                    success = bool(result)\n                \n                if success:\n                    successful.append(tool_name)\n                else:\n                    failed.append(tool_name)\n                    error_msg = result.get('error', 'Unknown error') if isinstance(result, dict) else str(result)\n                    logger.warning(f\"  - {tool_name} completed with issues: {error_msg}\")\n            except Exception as exc:\n                failed.append(tool_name)\n                logger.error(f\"  - {tool_name} failed: {exc}\")\n        \n        # Run dev tools coverage (Tier 3 only)\n        try:\n            logger.info(\"  - Running development tools coverage analysis...\")\n            dev_tools_coverage = self.run_dev_tools_coverage()\n            if dev_tools_coverage.get('coverage_collected'):\n                overall = dev_tools_coverage.get('overall', {})\n                coverage_pct = overall.get('overall_coverage', 0)\n                logger.info(f\"  - Dev tools coverage: {coverage_pct:.1f}%\")\n                successful.append('dev_tools_coverage')\n            else:\n                logger.warning(\"  - Dev tools coverage data not collected\")\n                failed.append('dev_tools_coverage')\n        except Exception as exc:\n            logger.error(f\"  - Development tools coverage failed: {exc}\")\n            failed.append('dev_tools_coverage')\n        \n        if failed:\n            logger.warning(f\"Tier 3 completed with {len(failed)} failure(s): {', '.join(failed)}\")\n        else:\n            logger.info(f\"Tier 3 completed successfully ({len(successful)} tools)\")\n        \n        return len(failed) == 0\n\n    def _check_and_trim_changelog_entries(self) -> None:\n        \"\"\"Check and trim AI_CHANGELOG entries to prevent bloat.\"\"\"\n        try:\n            from ai_development_docs import changelog_manager  # type: ignore\n        except Exception:\n            changelog_manager = None\n        if changelog_manager and hasattr(changelog_manager, 'trim_change_log'):\n            try:\n                result = changelog_manager.trim_change_log()\n                if isinstance(result, dict):\n                    status = result.get('status')\n                    if status == 'ok':\n                        trimmed = result.get('trimmed_entries')\n                        archive_created = result.get('archive_created')\n                    if trimmed:\n                        logger.info(f\"   Trimmed {trimmed} old changelog entries\")\n                    if archive_created:\n                        logger.info(\"   Created archive: ai_development_docs/AI_CHANGELOG_ARCHIVE.md\")\n                else:\n                    logger.warning(f\"   Changelog trim reported an issue: {result.get('message')}\")\n            except Exception as exc:\n                logger.warning(f\"   Changelog check/trim failed: {exc}\")\n        else:\n            logger.info(\"   Changelog check: Tooling unavailable (skipping trim)\")\n\n    def _validate_referenced_paths(self) -> None:\n        \"\"\"Validate that all referenced paths in documentation exist.\"\"\"\n        try:\n            from ..docs.fix_version_sync import validate_referenced_paths  # type: ignore\n            result = validate_referenced_paths()\n            status = result.get('status') if isinstance(result, dict) else None\n            message = result.get('message') if isinstance(result, dict) else None\n            # Store path validation result for display in status\n            if isinstance(result, dict):\n                self.path_validation_result = result\n            if status == 'ok':\n                logger.info(f\"   Path validation: {message}\")\n            elif status == 'fail':\n                issues = result.get('issues_found', 'unknown') if isinstance(result, dict) else 'unknown'\n                logger.warning(f\"   Path validation failed: {message}\")\n                logger.warning(f\"   Found {issues} path issues - consider running documentation sync checker\")\n            else:\n                logger.warning(f\"   Path validation error: {message}\")\n        except Exception as exc:\n            logger.warning(f\"   Path validation failed: {exc}\")\n            self.path_validation_result = None\n\n    def _check_documentation_quality(self) -> None:\n        \"\"\"Check for documentation duplicates and placeholder content.\"\"\"\n        try:\n            data = self.results_cache.get('analyze_documentation')\n            if not isinstance(data, dict):\n                result = self.run_analyze_documentation()\n                data = result.get('data') if isinstance(result, dict) else None\n                if isinstance(data, dict):\n                    self.results_cache['analyze_documentation'] = data\n            if isinstance(data, dict):\n                duplicates = data.get('duplicates') or []\n                placeholders = data.get('placeholders') or []\n                if duplicates:\n                    logger.warning(f\"   Documentation quality: Found {len(duplicates)} verbatim duplicates\")\n                    logger.warning(\"   -> Remove duplicates between AI and human docs\")\n                else:\n                    logger.info(\"   Documentation quality: No verbatim duplicates found\")\n                if placeholders:\n                    logger.warning(f\"   Documentation quality: Found {len(placeholders)} files with placeholders\")\n                    logger.warning(\"   -> Replace placeholder content with actual content\")\n                else:\n                    logger.info(\"   Documentation quality: No placeholder content found\")\n            else:\n                logger.warning(\"   Documentation quality check unavailable: no analysis data\")\n        except Exception as exc:\n            logger.warning(f\"   Documentation quality check failed: {exc}\")\n\n    def _check_ascii_compliance(self) -> None:\n        \"\"\"Check for non-ASCII characters in documentation files.\"\"\"\n        try:\n            from ..docs.analyze_ascii_compliance import ASCIIComplianceAnalyzer  # type: ignore\n            analyzer = ASCIIComplianceAnalyzer()\n            results = analyzer.check_ascii_compliance()\n            total_issues = sum(len(issues) for issues in results.values())\n            files_with_issues = len(results)\n            if total_issues == 0:\n                logger.info(\"   ASCII compliance: All documentation files use ASCII-only characters\")\n                # Store in docs_sync_summary even if 0\n                if not hasattr(self, 'docs_sync_summary') or not self.docs_sync_summary:\n                    self.docs_sync_summary = {}\n                self.docs_sync_summary['ascii_issues'] = 0\n            else:\n                logger.warning(f\"   ASCII compliance: Found {total_issues} non-ASCII characters in {files_with_issues} files\")\n                logger.warning(\"   -> Replace non-ASCII characters with ASCII equivalents\")\n                # Store in docs_sync_summary for display in reports\n                if not hasattr(self, 'docs_sync_summary') or not self.docs_sync_summary:\n                    self.docs_sync_summary = {}\n                self.docs_sync_summary['ascii_issues'] = files_with_issues\n        except Exception as exc:\n            logger.warning(f\"   ASCII compliance check failed: {exc}\")\n\n    def _sync_todo_with_changelog(self) -> None:\n        \"\"\"Sync TODO.md with AI_CHANGELOG.md to move completed entries.\"\"\"\n        try:\n            from ..docs.fix_version_sync import sync_todo_with_changelog  # type: ignore\n            result = sync_todo_with_changelog()\n            # Store result for status reports\n            self.todo_sync_result = result\n            status = result.get('status') if isinstance(result, dict) else None\n            if status == 'ok':\n                completed_entries = result.get('completed_entries', 0)\n                moved = result.get('moved_entries', 0)\n                if moved:\n                    logger.info(f\"   TODO sync: Moved {moved} completed entries from TODO.md\")\n                    print(f\"TODO sync: Moved {moved} completed entries from TODO.md\")\n                elif completed_entries > 0:\n                    logger.info(f\"   TODO sync: Found {completed_entries} completed entries in TODO.md that need review\")\n                    print(f\"TODO sync: Found {completed_entries} completed entries in TODO.md that need review\")\n                else:\n                    message = result.get('message')\n                    logger.info(f\"   TODO sync: {message}\")\n            else:\n                message = result.get('message') if isinstance(result, dict) else None\n                logger.warning(f\"   TODO sync failed: {message}\")\n        except Exception as exc:\n            logger.warning(f\"   TODO sync failed: {exc}\")\n            self.todo_sync_result = {'status': 'error', 'message': str(exc), 'completed_entries': 0}\n\n    def run_docs(self):\n\n        \"\"\"Update all documentation (OPTIONAL - not essential for audit)\"\"\"\n\n        logger.info(\"Starting documentation update...\")\n\n        logger.info(\"Updating documentation...\")\n\n        logger.info(\"=\" * 50)\n\n        success = True\n\n        # Generate function registry\n\n        try:\n\n            logger.info(\"  - Generating function registry...\")\n\n            result = self.run_script(\"generate_function_registry\")\n\n            if result['success']:\n\n                logger.info(\"  - Function registry generated successfully\")\n\n            else:\n\n                logger.error(f\"  - Function registry generation failed: {result['error']}\")\n\n                success = False\n\n        except Exception as exc:\n\n            logger.error(f\"  - Function registry generation failed: {exc}\")\n\n            success = False\n\n        # Generate module dependencies\n\n        try:\n\n            logger.info(\"  - Generating module dependencies...\")\n\n            result = self.run_script(\"generate_module_dependencies\")\n\n            if result['success']:\n\n                logger.info(\"  - Module dependencies generated successfully\")\n\n            else:\n\n                logger.error(f\"  - Module dependencies generation failed: {result['error']}\")\n\n                success = False\n\n        except Exception as exc:\n\n            logger.error(f\"  - Module dependencies generation failed: {exc}\")\n\n            success = False\n\n        # Generate directory trees\n\n        try:\n\n            logger.info(\"  - Generating directory trees...\")\n\n            self.generate_directory_trees()\n\n        except Exception as exc:\n\n            logger.error(f\"  - Directory tree generation failed: {exc}\")\n\n            success = False\n\n        # Run documentation sync check\n\n        try:\n\n            logger.info(\"  - Checking documentation sync...\")\n\n            if not self._run_doc_sync_check('--check'):\n\n                success = False\n\n        except Exception as exc:\n\n            logger.error(f\"  - Documentation sync check failed: {exc}\")\n\n            success = False\n\n        logger.info(\"=\" * 50)\n\n        if success:\n\n            logger.info(\"Completed documentation update successfully!\")\n\n        else:\n\n            logger.warning(\"Completed documentation update with issues.\")\n\n        return success\n\n    def run_validate(self):\n\n        \"\"\"Validate AI-generated work (simple command)\"\"\"\n\n        logger.info(\"Starting validation...\")\n\n        logger.info(\"Validating AI work...\")\n\n        logger.info(\"=\" * 50)\n\n        result = self.run_script('analyze_ai_work')\n\n        if result['success']:\n\n            # Store results for consolidated report\n            self.validation_results = result\n            \n            # Save results to standardized storage\n            try:\n                from .output_storage import save_tool_result\n                # Try to extract data from output or result\n                data = result.get('data')\n                if not data and result.get('output'):\n                    try:\n                        import json\n                        data = json.loads(result.get('output', ''))\n                    except (json.JSONDecodeError, TypeError):\n                        # If output is not JSON, create structured data from result\n                        data = {\n                            'success': result.get('success', False),\n                            'output': result.get('output', ''),\n                            'error': result.get('error', ''),\n                            'returncode': result.get('returncode', 0)\n                        }\n                if data:\n                    save_tool_result('analyze_ai_work', 'ai_work', data, project_root=self.project_root)\n            except Exception as e:\n                logger.debug(f\"Failed to save analyze_ai_work results: {e}\")\n\n            logger.info(\"=\" * 50)\n\n            logger.info(\"Validation completed successfully!\")\n\n            return True\n\n        else:\n\n            logger.error(f\"Validation failed: {result['error']}\")\n\n            return False\n\n    def run_config(self):\n\n        \"\"\"Check configuration consistency (simple command)\"\"\"\n\n        logger.info(\"Starting configuration check...\")\n\n        logger.info(\"Checking configuration...\")\n\n        logger.info(\"=\" * 50)\n\n        result = self.run_script('analyze_config')\n\n        if result['success']:\n            # Parse JSON output if available\n            output = result.get('output', '')\n            if output:\n                # The output contains both the report (printed by analyze_config) and JSON\n                # Extract JSON from the end of output (it's printed last)\n                try:\n                    import json\n                    # Find the last JSON object in the output (it's printed at the end)\n                    lines = output.strip().split('\\n')\n                    json_start = None\n                    for i in range(len(lines) - 1, -1, -1):\n                        if lines[i].strip().startswith('{'):\n                            json_start = i\n                            break\n                    \n                    if json_start is not None:\n                        json_output = '\\n'.join(lines[json_start:])\n                        json_data = json.loads(json_output)\n                        \n                        # Save to standardized storage\n                        try:\n                            save_tool_result('analyze_config', 'config', json_data, project_root=self.project_root)\n                            logger.debug(\"Regenerated analyze_config_results.json\")\n                        except Exception as e:\n                            logger.warning(f\"Failed to save analyze_config result: {e}\")\n                    else:\n                        # Fallback: try to parse entire output as JSON\n                        json_data = json.loads(output)\n                        save_tool_result('analyze_config', 'config', json_data, project_root=self.project_root)\n                        logger.debug(\"Regenerated analyze_config_results.json\")\n                except (json.JSONDecodeError, ValueError) as e:\n                    logger.warning(f\"Failed to parse analyze_config JSON output: {e}\")\n                    logger.debug(f\"Output was: {output[:500]}...\")  # Log first 500 chars for debugging\n                \n                # Print the output (which includes the report)\n                print(output)\n            else:\n                logger.warning(\"No output from analyze_config script\")\n\n            return True\n        else:\n            logger.error(f\"Configuration check failed: {result['error']}\")\n            return False\n\n    # ===== ADVANCED COMMANDS (for AI collaborators) =====\n\n    def run_workflow(self, task_type: str, task_data: Optional[Dict] = None) -> bool:\n\n        \"\"\"Run workflow with audit-first protocol\"\"\"\n\n        logger.info(f\"Running workflow: {task_type}\")\n\n        logger.info(\"=\" * 50)\n\n        # Check trigger requirements\n\n        if not self.check_trigger_requirements(task_type):\n\n            return False\n\n        # Run audit first\n\n        audit_results = self.run_audit_first(task_type)\n\n        if not audit_results['success']:\n\n            logger.error(f\"Audit failed: {audit_results['error']}\")\n\n            return False\n\n        # Execute the task\n\n        task_success = self.execute_task(task_type, task_data)\n\n        # Validate the work\n\n        if task_success:\n\n            validation_results = self.validate_work(task_type, task_data or {})\n\n            self.show_validation_report(validation_results)\n\n        return task_success\n\n    # LEGACY COMPATIBILITY\n    # This method is kept for backward compatibility with any external callers.\n    # Removal plan: Search for \"run_quick_audit\" to find all callers, update them to use run_audit(quick=True) instead, then remove this method.\n    # Detection: Search codebase for \"run_quick_audit\" to find all references.\n    def run_quick_audit(self) -> bool:\n\n        \"\"\"Run quick audit (Tier 1) - legacy method for backward compatibility.\n        \n        This method is kept for backward compatibility but now uses the new tier structure.\n        New code should use run_audit(quick=True) instead.\n        \"\"\"\n        logger.warning(\"LEGACY: run_quick_audit() is deprecated. Use run_audit(quick=True) instead.\")\n        logger.info(\"Running quick audit (Tier 1)...\")\n        \n        # Use new tier-based structure\n        return self._run_quick_audit_tools()\n\n\n    def run_version_sync(self, scope: str = 'docs'):\n\n        \"\"\"Sync version numbers\"\"\"\n\n        logger.info(f\"Syncing versions for scope: {scope}\")\n\n        logger.info(\"=\" * 50)\n\n        result = self.run_script('fix_version_sync', 'sync', '--scope', scope)\n\n        if result['success']:\n\n            # Store results for consolidated report\n\n            self.fix_version_sync_results = result\n\n            logger.info(\"Version sync completed!\")\n\n            return True\n\n        else:\n\n            logger.error(f\"Version sync failed: {result['error']}\")\n\n            return False\n\n    def run_dev_tools_coverage(self) -> Dict:\n        \"\"\"Run coverage analysis specifically for development_tools directory.\"\"\"\n        logger.info(\"Starting development tools coverage analysis...\")\n        \n        # Create coverage lock file to prevent status file writes during pytest execution\n        global _AUDIT_LOCK_FILE\n        if _AUDIT_LOCK_FILE is None:\n            _AUDIT_LOCK_FILE = self.project_root / 'development_tools' / '.audit_in_progress.lock'\n        coverage_lock_file = self.project_root / 'development_tools' / '.coverage_in_progress.lock'\n\n        # Create lock file to prevent status writes during coverage\n        try:\n            coverage_lock_file.touch()\n        except Exception as e:\n            logger.warning(f\"Failed to create coverage lock file: {e}\")\n        \n        try:\n            from ..tests.generate_test_coverage import CoverageMetricsRegenerator\n            \n            regenerator = CoverageMetricsRegenerator()\n            result = regenerator.run_dev_tools_coverage()\n            \n            # Store results for consolidated report\n            if not hasattr(self, 'dev_tools_coverage_results'):\n                self.dev_tools_coverage_results = {}\n            self.dev_tools_coverage_results = result\n            \n            logger.info(\"Completed development tools coverage analysis!\")\n            \n            # Reload dev tools coverage after regeneration\n            self._load_dev_tools_coverage()\n            \n            return result\n            \n        except Exception as exc:\n            logger.error(f\"Development tools coverage analysis failed: {exc}\")\n            return {'coverage_collected': False, 'error': str(exc)}\n        finally:\n            # Remove coverage lock file\n            try:\n                if coverage_lock_file.exists():\n                    coverage_lock_file.unlink()\n            except Exception as e:\n                logger.warning(f\"Failed to remove coverage lock file: {e}\")\n\n    def run_status(self, skip_status_files: bool = False):\n\n        \"\"\"Get current system status - quick check that updates status files\n        \n        Args:\n            skip_status_files: If True, skip writing status files (used when called during audit)\n        \"\"\"\n        # Automatically skip status files if audit is in progress (check both instance flag and audit status)\n        instance_flag = hasattr(self, '_audit_in_progress') and self._audit_in_progress\n        audit_in_progress_check = _is_audit_in_progress(self.project_root)\n        if instance_flag or audit_in_progress_check:\n            skip_status_files = True\n            logger.warning(f\"run_status() called during audit! Skipping status file generation to prevent mid-audit writes. (instance_flag={instance_flag}, audit_in_progress={audit_in_progress_check}, project_root={self.project_root})\")\n            import traceback\n            logger.debug(f\"Call stack:\\n{''.join(traceback.format_stack())}\")\n        else:\n            # Log when run_status is called and audit is NOT in progress (for debugging)\n            logger.debug(f\"run_status() called - audit NOT in progress (instance_flag={instance_flag}, audit_in_progress={audit_in_progress_check})\")\n\n        logger.info(\"Starting status check...\")\n\n        logger.info(\"Getting system status...\")\n\n        logger.info(\"=\" * 50)\n\n        # Run quick status for basic system health\n        # quick_status.py expects 'json' as the first argument (sys.argv[1])\n        result = self.run_script('quick_status', 'json')\n\n        if result.get('success'):\n\n            self.status_results = result\n\n            parsed = None\n\n            output = result.get('output', '')\n\n            if output:\n\n                try:\n\n                    parsed = json.loads(output)\n\n                except json.JSONDecodeError:\n\n                    parsed = None\n\n            if parsed is not None:\n\n                result['data'] = parsed\n\n                self.status_summary = parsed\n\n                logger.info(\"Status check completed!\")\n\n            else:\n\n                logger.warning(\"Status check completed, but output could not be parsed as JSON.\")\n\n            # Run TODO sync check for status\n            logger.info(\"Checking TODO sync status...\")\n            self._sync_todo_with_changelog()\n\n            # Run system signals generator\n            logger.info(\"Generating system signals...\")\n            self.run_system_signals()\n            \n            # Save additional tool results to cached file (including system signals)\n            self._save_additional_tool_results()\n\n            # Generate all three status files with current data (unless skipped)\n            if not skip_status_files:\n                logger.info(\"Generating status files...\")\n                \n                # AI Status\n                ai_status = self._generate_ai_status_document()\n                ai_status_file = create_output_file(\"development_tools/AI_STATUS.md\", ai_status, project_root=self.project_root)\n                logger.info(f\"AI Status: {ai_status_file}\")\n                \n                # AI Priorities\n                ai_priorities = self._generate_ai_priorities_document()\n                ai_priorities_file = create_output_file(\"development_tools/AI_PRIORITIES.md\", ai_priorities, project_root=self.project_root)\n                logger.info(f\"AI Priorities: {ai_priorities_file}\")\n                \n                # Consolidated Report\n                consolidated_report = self._generate_consolidated_report()\n                consolidated_file = create_output_file(\"development_tools/consolidated_report.txt\", consolidated_report, project_root=self.project_root)\n                logger.info(f\"Consolidated Report: {consolidated_file}\")\n            else:\n                logger.debug(\"Skipping status file generation (called during audit)\")\n\n            logger.info(\"Completed status check successfully!\")\n\n            return True\n\n        if result.get('output'):\n\n            logger.info(result['output'])\n\n        if result.get('error'):\n\n            logger.error(f\"Completed status check with errors: {result['error']}\")\n\n        return False\n\n    def run_documentation_sync(self):\n\n        \"\"\"Run documentation synchronization checks\"\"\"\n\n        logger.info(\"Starting documentation sync check...\")\n\n        logger.info(\"Running documentation synchronization checks...\")\n\n        if self._run_doc_sync_check('--check'):\n\n            logger.info(\"Completed documentation sync check successfully!\")\n\n            return True\n\n        logger.error(\"Completed documentation sync check with errors!\")\n\n        return False\n\n    def run_documentation_fix(self, fix_type: str = 'all', dry_run: bool = False) -> bool:\n\n        \"\"\"Run documentation fix operations.\n\n        Args:\n            fix_type: Type of fix to apply ('add-addresses', 'fix-ascii', 'number-headings', 'convert-links', 'all')\n            dry_run: If True, show what would be changed without making changes\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n\n        logger.info(f\"Starting documentation fix (type: {fix_type}, dry_run: {dry_run})...\")\n\n        try:\n\n            # Use decomposed fixer classes (Batch 2 decomposition)\n            from development_tools.docs.fix_documentation_addresses import DocumentationAddressFixer\n            from development_tools.docs.fix_documentation_ascii import DocumentationASCIIFixer\n            from development_tools.docs.fix_documentation_headings import DocumentationHeadingFixer\n            from development_tools.docs.fix_documentation_links import DocumentationLinkFixer\n\n            results = {}\n\n            if fix_type in ('add-addresses', 'all'):\n\n                fixer = DocumentationAddressFixer(project_root=str(self.project_root))\n                result = fixer.fix_add_addresses(dry_run=dry_run)\n\n                results['add_addresses'] = result\n\n                print(f\"\\nAdd Addresses: Updated {result['updated']}, Skipped {result['skipped']}, Errors {result['errors']}\")\n\n            if fix_type in ('fix-ascii', 'all'):\n\n                fixer = DocumentationASCIIFixer(project_root=str(self.project_root))\n                result = fixer.fix_ascii(dry_run=dry_run)\n\n                results['fix_ascii'] = result\n\n                print(f\"\\nFix ASCII: Updated {result['files_updated']} files, Made {result['replacements_made']} replacements, Errors {result['errors']}\")\n\n            if fix_type in ('number-headings', 'all'):\n\n                fixer = DocumentationHeadingFixer(project_root=str(self.project_root))\n                result = fixer.fix_number_headings(dry_run=dry_run)\n\n                results['number_headings'] = result\n\n                print(f\"\\nNumber Headings: Updated {result['files_updated']} files, Fixed {result['issues_fixed']} issues, Errors {result['errors']}\")\n\n            if fix_type in ('convert-links', 'all'):\n\n                fixer = DocumentationLinkFixer(project_root=str(self.project_root))\n                result = fixer.fix_convert_links(dry_run=dry_run)\n\n                results['convert_links'] = result\n\n                print(f\"\\nConvert Links: Updated {result['files_updated']} files, Made {result['changes_made']} changes, Errors {result['errors']}\")\n\n            # Check for errors\n\n            total_errors = sum(r.get('errors', 0) for r in results.values())\n\n            if total_errors > 0:\n\n                logger.error(f\"Documentation fix completed with {total_errors} error(s)\")\n\n                return False\n\n            logger.info(\"Completed documentation fix successfully!\")\n\n            return True\n\n        except Exception as e:\n\n            logger.error(f\"Error running documentation fix: {e}\", exc_info=True)\n\n            return False\n\n    def run_coverage_regeneration(self):\n\n        \"\"\"Regenerate test coverage metrics\"\"\"\n\n        logger.info(\"Starting coverage regeneration...\")\n        \n        # Create coverage lock file to prevent status file writes during pytest execution\n        global _AUDIT_LOCK_FILE\n        if _AUDIT_LOCK_FILE is None:\n            _AUDIT_LOCK_FILE = self.project_root / 'development_tools' / '.audit_in_progress.lock'\n        coverage_lock_file = self.project_root / 'development_tools' / '.coverage_in_progress.lock'\n\n        # Create lock file to prevent status writes during coverage\n        try:\n            coverage_lock_file.touch()\n        except Exception as e:\n            logger.warning(f\"Failed to create coverage lock file: {e}\")\n        \n        # Track status file modification times before test coverage (for detecting mid-audit writes)\n        pre_coverage_mtimes = _get_status_file_mtimes(self.project_root)\n        # Compare with audit start times and warn if files were modified\n        if hasattr(self, '_audit_start_mtimes'):\n            for file_name, mtime in pre_coverage_mtimes.items():\n                if mtime > self._audit_start_mtimes.get(file_name, 0):\n                    logger.warning(f\"Status file {file_name} was modified before test coverage! Mtime changed from {self._audit_start_mtimes.get(file_name, 0)} to {mtime}\")\n\n        logger.info(\"Regenerating test coverage metrics...\")\n        \n        try:\n            result = self.run_script('generate_test_coverage', '--update-plan', timeout=1800)  # 30 minute timeout for coverage\n            \n            # Track status file modification times after test coverage (for detecting mid-audit writes)\n            post_coverage_mtimes = _get_status_file_mtimes(self.project_root)\n            # Compare with pre-coverage times and warn if files were modified\n            for file_name, mtime in post_coverage_mtimes.items():\n                if mtime > pre_coverage_mtimes.get(file_name, 0):\n                    logger.warning(f\"Status file {file_name} was modified during test coverage! Mtime changed from {pre_coverage_mtimes.get(file_name, 0)} to {mtime}\")\n\n            # Parse test results from output\n            output = result.get('output', '')\n            error_output = result.get('error', '')\n            test_results = self._parse_test_results_from_output(output)\n            \n            # Log error output if present for debugging\n            if error_output and logger:\n                logger.warning(f\"Coverage regeneration stderr: {error_output[:500]}\")\n            \n            # Check if coverage was collected successfully\n            # Only consider it collected if we see actual test output, not just existing files\n            coverage_collected = (\n                'TOTAL' in output or \n                'coverage:' in output.lower() or\n                ('passed' in output.lower() and 'failed' in output.lower()) or  # Test results present\n                ('[  ' in output and '%]' in output)  # Progress indicators from pytest\n            )\n            \n            # If no test output detected but coverage.json exists, warn that tests may not have run\n            if not coverage_collected and ((self.project_root / \"coverage.json\").exists() or (self.project_root / \"development_tools\" / \"tests\" / \"coverage.json\").exists()):\n                if logger:\n                    logger.error(\"Coverage regeneration completed with no test output detected - tests likely did not run!\")\n                    logger.error(f\"Script output length: {len(output)} chars, stderr length: {len(error_output)} chars\")\n                    if error_output:\n                        logger.error(f\"Script stderr (first 1000 chars): {error_output[:1000]}\")\n                    logger.error(\"This indicates the test suite did not execute. Check for import errors or pytest configuration issues.\")\n                # Don't consider it collected - this is a failure\n                coverage_collected = False\n\n            if result['success']:\n\n                # Store results for consolidated report\n\n                self.coverage_results = result\n\n                logger.info(\"Completed coverage regeneration successfully!\")\n                \n                logger.info(\"Coverage metrics regenerated and plan updated!\")\n                \n                # Run test marker analysis after coverage (when tests are run)\n                try:\n                    logger.info(\"  - Running test marker analysis...\")\n                    # Use run_test_markers() method which includes save_tool_result\n                    marker_result = self.run_test_markers('check')\n                    if marker_result.get('success'):\n                        data = marker_result.get('data')\n                        if data:\n                            missing_count = data.get('missing_count', 0)\n                            if missing_count > 0:\n                                logger.info(f\"  - Test marker analysis: {missing_count} tests missing category markers\")\n                            else:\n                                logger.info(\"  - Test marker analysis: All tests have category markers\")\n                except Exception as exc:\n                    logger.debug(f\"  - Test marker analysis failed (non-critical): {exc}\")\n                \n                # Reload coverage summary after regeneration - force reload\n                self.coverage_results = None  # Clear cached results\n                # Force reload by clearing any cached coverage_summary\n                if hasattr(self, '_cached_coverage_summary'):\n                    delattr(self, '_cached_coverage_summary')\n                # Wait a moment for file system to sync, then reload\n                import time\n                time.sleep(0.5)  # Brief pause to ensure file is written\n                coverage_summary = self._load_coverage_summary()\n                if coverage_summary:\n                    overall = coverage_summary.get('overall', {})\n                    logger.info(f\"Reloaded coverage summary after regeneration: {overall.get('coverage', 'N/A')}% ({overall.get('covered', 'N/A')} of {overall.get('statements', 'N/A')} statements)\")\n                    # Save to standardized storage\n                    try:\n                        from .output_storage import save_tool_result\n                        save_tool_result('analyze_test_coverage', 'tests', coverage_summary, project_root=self.project_root)\n                    except Exception as save_error:\n                        logger.debug(f\"Failed to save analyze_test_coverage results: {save_error}\")\n                else:\n                    logger.warning(\"Failed to reload coverage summary after regeneration - coverage.json may not have been updated\")\n                \n                # Report test results if available\n                if test_results.get('test_summary'):\n                    logger.info(f\"Test results: {test_results['test_summary']}\")\n                    if test_results.get('random_seed'):\n                        logger.info(f\"Random seed used: {test_results['random_seed']}\")\n\n            else:\n\n                # Distinguish between coverage collection failures and test failures\n                if coverage_collected:\n                    # Coverage was collected successfully, but tests may have failed\n                    logger.warning(\"Coverage data collected successfully, but script exited with non-zero code\")\n                    \n                    if test_results.get('failed_count', 0) > 0:\n                        failure_msg = f\"Test failures detected ({test_results['failed_count']} failed, {test_results.get('passed_count', 0)} passed)\"\n                        if test_results.get('random_seed'):\n                            failure_msg += f\" (random seed: {test_results['random_seed']})\"\n                        logger.warning(failure_msg)\n                        \n                        if test_results.get('failed_tests'):\n                            logger.warning(\"Failed tests:\")\n                            for test_name in test_results['failed_tests']:\n                                logger.warning(f\"  - {test_name}\")\n                        else:\n                            logger.warning(\"  See development_tools/tests/logs/coverage_regeneration/ for detailed test failure information\")\n                else:\n                    # Coverage collection failed\n                    error_msg = \"Coverage regeneration failed\"\n\n                    if result.get('error'):\n\n                        error_msg += f\": {result['error']}\"\n\n                    if result.get('returncode') is not None:\n\n                        error_msg += f\" (exit code: {result['returncode']})\"\n\n                    # Check for common failure patterns in output\n\n                    if 'unrecognized arguments' in output.lower():\n\n                        error_msg += \"\\n  - Detected pytest argument error (possibly empty --cov argument)\"\n\n                    # Check for empty --cov pattern: \"--cov --cov\" (two --cov in a row)\n                    if output and '--cov' in output:\n                        output_parts = output.split()\n                        for i in range(len(output_parts) - 1):\n                            if output_parts[i] == '--cov' and output_parts[i + 1] == '--cov':\n                                error_msg += \"\\n  - Detected empty --cov argument in error output\"\n                                break\n\n                    logger.error(f\"ERROR: {error_msg}\")\n\n                    if result.get('error'):\n\n                        logger.error(f\"  Full error: {result['error'][:500]}\")  # Limit error length\n\n                logger.info(\"  Check development_tools/tests/logs/coverage_regeneration/ for detailed logs\")\n            \n            return result['success']\n        finally:\n            # Remove coverage lock file\n            try:\n                if coverage_lock_file.exists():\n                    coverage_lock_file.unlink()\n            except Exception as e:\n                logger.warning(f\"Failed to remove coverage lock file: {e}\")\n    \n    def _parse_test_results_from_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse test results from pytest output.\"\"\"\n        results = {\n            'random_seed': None,\n            'test_summary': None,\n            'failed_tests': [],\n            'passed_count': 0,\n            'failed_count': 0,\n            'skipped_count': 0,\n            'warnings_count': 0\n        }\n        \n        if not output:\n            return results\n        \n        # Extract random seed if pytest-randomly is used\n        seed_pattern = r'--randomly-seed=(\\d+)'\n        seed_match = re.search(seed_pattern, output)\n        if seed_match:\n            results['random_seed'] = seed_match.group(1)\n        \n        # Extract test summary (e.g., \"4 failed, 2276 passed, 1 skipped, 4 warnings\")\n        summary_pattern = r'(\\d+)\\s+failed[,\\s]+(\\d+)\\s+passed[,\\s]+(\\d+)\\s+skipped[,\\s]+(\\d+)\\s+warnings'\n        summary_match = re.search(summary_pattern, output)\n        if summary_match:\n            results['failed_count'] = int(summary_match.group(1))\n            results['passed_count'] = int(summary_match.group(2))\n            results['skipped_count'] = int(summary_match.group(3))\n            results['warnings_count'] = int(summary_match.group(4))\n            results['test_summary'] = f\"{results['failed_count']} failed, {results['passed_count']} passed, {results['skipped_count']} skipped, {results['warnings_count']} warnings\"\n        \n        # Extract failed test names from \"short test summary info\" section\n        short_summary_pattern = r'short test summary info[^\\n]*\\n(.*?)(?=\\n===|$)'\n        short_summary_match = re.search(short_summary_pattern, output, re.DOTALL)\n        if short_summary_match:\n            summary_lines = short_summary_match.group(1).strip().split('\\n')\n            for line in summary_lines:\n                if line.strip().startswith('FAILED'):\n                    # Extract test path from \"FAILED tests/path/to/test.py::test_function\"\n                    test_match = re.search(r'FAILED\\s+(.+)', line)\n                    if test_match:\n                        results['failed_tests'].append(test_match.group(1).strip())\n        \n        return results\n\n    def run_legacy_cleanup(self):\n\n        \"\"\"Run legacy reference cleanup\"\"\"\n\n        logger.info(\"Starting legacy cleanup...\")\n\n        logger.info(\"Running legacy reference cleanup...\")\n\n        if self._run_legacy_cleanup_scan('--scan'):\n\n            logger.info(\"Completed legacy cleanup successfully!\")\n\n            return True\n\n        logger.error(\"Completed legacy cleanup with errors!\")\n\n        return False\n\n    def run_cleanup(self, cache: bool = False, test_data: bool = False, \n                    coverage: bool = False, all_cleanup: bool = False, \n                    dry_run: bool = False) -> Dict:\n        \"\"\"Run project cleanup operations.\"\"\"\n        logger.info(\"Starting project cleanup...\")\n        \n        script_path = Path(__file__).resolve().parent.parent / 'shared' / 'fix_project_cleanup.py'\n        cmd = [sys.executable, str(script_path)]\n        \n        if dry_run:\n            cmd.append('--dry-run')\n        if cache:\n            cmd.append('--cache')\n        if test_data:\n            cmd.append('--test-data')\n        if coverage:\n            cmd.append('--coverage')\n        if all_cleanup:\n            cmd.append('--all')\n        \n        cmd.append('--json')\n        \n        try:\n            result_proc = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                cwd=str(self.project_root),\n                timeout=300\n            )\n            \n            output = result_proc.stdout\n            error_output = result_proc.stderr\n            \n            if result_proc.returncode == 0:\n                try:\n                    data = json.loads(output)\n                    return {\n                        'success': True,\n                        'output': output,\n                        'data': data,\n                        'returncode': result_proc.returncode\n                    }\n                except json.JSONDecodeError:\n                    return {\n                        'success': True,\n                        'output': output,\n                        'error': error_output,\n                        'returncode': result_proc.returncode\n                    }\n            else:\n                return {\n                    'success': False,\n                    'output': output,\n                    'error': error_output,\n                    'returncode': result_proc.returncode\n                }\n        except subprocess.TimeoutExpired:\n            logger.error(\"Project cleanup timed out\")\n            return {'success': False, 'error': 'Timeout'}\n        except Exception as exc:\n            logger.error(f\"Project cleanup failed: {exc}\")\n            return {'success': False, 'error': str(exc)}\n\n    def run_system_signals(self):\n        \"\"\"Run system signals generator\"\"\"\n        logger.info(\"Starting system signals generation...\")\n        logger.info(\"Generating system signals...\")\n        \n        result = self.run_script('system_signals', '--json')\n        \n        if result.get('success'):\n            output = result.get('output', '')\n            if output:\n                try:\n                    import json\n                    self.system_signals = json.loads(output)\n                    # Save to standardized storage\n                    try:\n                        from .output_storage import save_tool_result\n                        save_tool_result('system_signals', 'reports', self.system_signals, project_root=self.project_root)\n                    except Exception as save_error:\n                        logger.debug(f\"Failed to save system_signals results: {save_error}\")\n                    logger.info(\"Completed system signals generation successfully!\")\n                    return True\n                except json.JSONDecodeError:\n                    logger.error(\"Completed system signals generation with errors: Failed to parse JSON output\")\n                    return False\n            else:\n                logger.warning(\"Completed system signals generation with warnings: No output from tool\")\n                return False\n        else:\n            if result.get('error'):\n                logger.error(f\"Completed system signals generation with errors: {result['error']}\")\n            return False\n\n    def run_test_markers(self, action: str = 'check', dry_run: bool = False) -> Dict:\n        \"\"\"\n        Run test marker analysis with specified action.\n        \n        Note: Only 'check' and 'analyze' actions are supported.\n        For fixing markers, use fix_test_markers.py directly.\n        \"\"\"\n        logger.info(f\"Starting test marker {action}...\")\n        \n        script_path = Path(__file__).resolve().parent.parent / 'tests' / 'analyze_test_markers.py'\n        cmd = [sys.executable, str(script_path)]\n        \n        if action == 'check':\n            cmd.append('--check')\n        elif action == 'analyze':\n            cmd.append('--analyze')\n        else:\n            logger.error(f\"Unknown action: {action}. Only 'check' and 'analyze' are supported.\")\n            return {'success': False, 'error': f'Unknown action: {action}. Use fix_test_markers.py for fixing.'}\n        \n        cmd.append('--json')\n        \n        try:\n            result_proc = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                cwd=str(self.project_root),\n                timeout=300\n            )\n            \n            output = result_proc.stdout\n            error_output = result_proc.stderr\n            \n            if result_proc.returncode == 0 or (action == 'check' and result_proc.returncode == 1):\n                # Return code 1 from check means markers are missing (expected)\n                try:\n                    data = json.loads(output)\n                    # Save to standardized storage\n                    try:\n                        from .output_storage import save_tool_result\n                        save_tool_result('analyze_test_markers', 'tests', data, project_root=self.project_root)\n                    except Exception as save_error:\n                        logger.debug(f\"Failed to save analyze_test_markers results: {save_error}\")\n                    return {\n                        'success': True,\n                        'output': output,\n                        'data': data,\n                        'returncode': result_proc.returncode\n                    }\n                except json.JSONDecodeError:\n                    return {\n                        'success': True,\n                        'output': output,\n                        'error': error_output,\n                        'returncode': result_proc.returncode\n                    }\n            else:\n                return {\n                    'success': False,\n                    'output': output,\n                    'error': error_output,\n                    'returncode': result_proc.returncode\n                }\n        except subprocess.TimeoutExpired:\n            logger.error(\"Test marker analysis timed out\")\n            return {'success': False, 'error': 'Timeout'}\n        except Exception as exc:\n            logger.error(f\"Test marker analysis failed: {exc}\")\n            return {'success': False, 'error': str(exc)}\n\n    def run_unused_imports_report(self):\n\n        \"\"\"Run unused imports checker and generate report.\n        \n        This method runs analyze_unused_imports.py which generates both:\n        1. UNUSED_IMPORTS_REPORT.md (markdown report)\n        2. JSON data (via --json flag) for standardized storage\n        \"\"\"\n\n        logger.info(\"Starting unused imports check...\")\n\n        # Use execute() function directly instead of subprocess - more reliable and efficient\n        # execute() generates the report and returns structured data in one call\n        data = None\n        result = {'success': False, 'output': '', 'error': '', 'returncode': 0}\n        \n        try:\n            from ..imports.analyze_unused_imports import UnusedImportsChecker, execute\n            # Use execute() to generate report, then get standard format via run_analysis()\n            execute_result = execute(project_root=str(self.project_root), output='development_docs/UNUSED_IMPORTS_REPORT.md')\n            if isinstance(execute_result, dict):\n                # Create checker instance to get standard format\n                checker = UnusedImportsChecker(str(self.project_root))\n                # Scan was already done by execute(), so we can call run_analysis() directly\n                # But we need to set findings and stats from execute_result\n                if 'results' in execute_result:\n                    results = execute_result.get('results', {})\n                    checker.findings = results.get('findings', {})\n                if 'stats' in execute_result:\n                    checker.stats = execute_result.get('stats', {})\n                \n                # Get standard format\n                data = checker.run_analysis()\n                result['success'] = True\n                logger.info(\"Unused imports report generated successfully\")\n                logger.debug(f\"Got unused imports data in standard format: {data.get('summary', {}).get('total_issues', 0)} unused imports\")\n            else:\n                logger.warning(\"execute() returned unexpected format\")\n                result['error'] = 'execute() returned unexpected format'\n        except Exception as e:\n            logger.warning(f\"Failed to get unused imports data from execute function: {e}\")\n            result['error'] = str(e)\n            # Fallback: Try subprocess approach if execute() fails\n            if not data:\n                try:\n                    script_path = Path(__file__).resolve().parent.parent / 'imports' / 'analyze_unused_imports.py'\n                    cmd = [sys.executable, str(script_path), '--json']\n                    result_proc = subprocess.run(\n                        cmd,\n                        capture_output=True,\n                        text=True,\n                        cwd=str(self.project_root),\n                        timeout=600\n                    )\n                    if result_proc.returncode == 0 and result_proc.stdout:\n                        import json\n                        try:\n                            parsed = json.loads(result_proc.stdout.strip())\n                            # Normalize to standard format if needed\n                            from .result_format import normalize_to_standard_format\n                            data = normalize_to_standard_format('analyze_unused_imports', parsed)\n                            result['success'] = True\n                            logger.debug(\"Got unused imports data from subprocess fallback (normalized to standard format)\")\n                        except json.JSONDecodeError:\n                            result['error'] = 'Failed to parse JSON from subprocess output'\n                except Exception as e2:\n                    logger.warning(f\"Subprocess fallback also failed: {e2}\")\n                    result['error'] = f\"Both execute() and subprocess failed: {e2}\"\n        \n        # LEGACY COMPATIBILITY: Ensure data is in standard format\n        # Normalize legacy format to standard format if needed\n        # Removal plan: After all tools output standard format directly, remove normalization step.\n        # Detection: Search for \"Normalize to standard format if needed\" in this file.\n        if data and isinstance(data, dict):\n            # Normalize to standard format if needed\n            if 'summary' not in data:\n                logger.debug(\"run_unused_imports_report: Normalizing legacy format to standard format (backward compatibility)\")\n                from .result_format import normalize_to_standard_format\n                data = normalize_to_standard_format('analyze_unused_imports', data)\n        \n        # Save to standardized storage if we have data\n        # Check if data exists and has the expected structure (standard format or legacy format)\n        if data and isinstance(data, dict) and ('summary' in data or 'total_unused' in data or 'stats' in data or 'files_with_issues' in data):\n            try:\n                from .output_storage import save_tool_result\n                save_tool_result('analyze_unused_imports', 'imports', data, project_root=self.project_root)\n                self.results_cache['analyze_unused_imports'] = data\n                # Log using standard format if available\n                if 'summary' in data:\n                    total_issues = data.get('summary', {}).get('total_issues', 'N/A')\n                    logger.debug(f\"Saved unused imports data in standard format: total_issues={total_issues}\")\n                else:\n                    logger.debug(f\"Saved unused imports data: {len(data)} keys, total_unused={data.get('total_unused', 'N/A')}\")\n            except Exception as e:\n                logger.warning(f\"Failed to save analyze_unused_imports result: {e}\")\n        elif not data:\n            logger.warning(\"No unused imports data to save - data is None or empty\")\n        else:\n            logger.warning(f\"Unused imports data structure unexpected: {type(data)}, keys: {list(data.keys()) if isinstance(data, dict) else 'N/A'}\")\n\n        if result['success']:\n\n            logger.info(\"Completed unused imports check successfully!\")\n\n            report_path = self.project_root / \"development_docs\" / \"UNUSED_IMPORTS_REPORT.md\"\n\n            if report_path.exists():\n\n                logger.info(f\"Report saved to: {report_path}\")\n\n            return {\n                'success': True,\n                'output': result.get('output', ''),\n                'error': '',\n                'returncode': 0,\n                'data': data\n            }\n\n        else:\n\n            logger.error(f\"Completed unused imports check with errors: {result.get('error', 'Unknown error')}\")\n\n            return {\n                'success': False,\n                'output': result.get('output', ''),\n                'error': result.get('error', 'Unknown error'),\n                'returncode': result.get('returncode', 1),\n                'data': data\n            }\n\n    def generate_directory_trees(self):\n\n        \"\"\"Generate directory trees for documentation\"\"\"\n\n        logger.info(\"Generating directory trees...\")\n\n        result = self.run_script('generate_directory_tree')\n\n        if result['success']:\n            # Don't log result['output'] as it contains duplicate messages\n            # The script already logs \"Directory tree generated: {path}\" internally\n            logger.info(\"Directory tree generated!\")\n            logger.info(\"Check development_docs/DIRECTORY_TREE.md for project structure\")\n\n        return result['success']\n\n    # ===== HELPER METHODS =====\n\n    def check_trigger_requirements(self, task_type: str) -> bool:\n\n        \"\"\"Check if trigger requirements are met\"\"\"\n\n        trigger_file = self.project_root / 'TRIGGER.md'\n\n        if not trigger_file.exists():\n\n            logger.warning(\"TRIGGER.md not found - proceeding anyway\")\n\n            return True\n\n        # For AI tools, we don't need user approval\n\n        return True\n\n    def run_audit_first(self, task_type: str) -> Dict:\n\n        \"\"\"Run audit first as required by protocol\"\"\"\n\n        logger.info(\"Running audit-first protocol...\")\n\n        # Use new tier-based structure directly (Tier 1 for audit-first protocol)\n        audit_success = self._run_quick_audit_tools()\n\n        return {\n\n            'success': audit_success,\n\n            'error': '' if audit_success else 'Audit failed'\n\n        }\n\n    def execute_task(self, task_type: str, task_data: Optional[Dict] = None) -> bool:\n\n        \"\"\"Execute the specific task\"\"\"\n\n        if task_type == 'documentation':\n\n            return self._execute_documentation_task()\n\n        elif task_type == 'function_registry':\n\n            return self._execute_function_registry_task()\n\n        elif task_type == 'module_dependencies':\n\n            return self._execute_module_dependencies_task()\n\n        else:\n\n            logger.error(f\"Unknown task type: {task_type}\")\n\n            return False\n\n    def validate_work(self, work_type: str, work_data: Dict) -> Dict:\n\n        \"\"\"Validate the work before presenting\"\"\"\n\n        logger.info(\"Validating work...\")\n\n        result = self.run_script('analyze_ai_work')\n\n        if result['success']:\n\n            return self.validate_audit_results({'output': result['output']})\n\n        else:\n\n            return {\n\n                'completeness': 0.0,\n\n                'accuracy': 0.0,\n\n                'consistency': 0.0,\n\n                'actionable': 0.0,\n\n                'overall': 0.0,\n\n                'issues': [f\"Validation failed: {result['error']}\"]\n\n            }\n\n    def validate_audit_results(self, results: Dict) -> Dict:\n\n        \"\"\"Validate audit results\"\"\"\n\n        # Simple validation for now\n\n        return {\n\n            'completeness': 95.0,\n\n            'accuracy': 90.0,\n\n            'consistency': 85.0,\n\n            'actionable': 80.0,\n\n            'overall': 87.5,\n\n            'issues': []\n\n        }\n\n    def show_validation_report(self, validation_results: Dict):\n\n        \"\"\"Show validation report\"\"\"\n\n        print(\"\\n\" + \"=\" * 50)\n\n        print(\"VALIDATION REPORT\")\n\n        print(\"=\" * 50)\n\n        scores = [\n\n            f\"Completeness: {validation_results['completeness']:.1f}%\",\n\n            f\"Accuracy: {validation_results['accuracy']:.1f}%\",\n\n            f\"Consistency: {validation_results['consistency']:.1f}%\",\n\n            f\"Actionable: {validation_results['actionable']:.1f}%\"\n\n        ]\n\n        overall = validation_results['overall']\n\n        status = \"PASSED\" if overall >= 80.0 else \"NEEDS IMPROVEMENT\"\n\n        print(f\"Overall Score: {overall:.1f}% - {status}\")\n\n        print(\"\\nComponent Scores:\")\n\n        for score in scores:\n\n            print(f\"  {score}\")\n\n        if validation_results['issues']:\n\n            print(\"\\nIssues Found:\")\n\n            for issue in validation_results['issues']:\n\n                print(f\"  [ISSUE] {issue}\")\n\n    def print_audit_summary(self, successful: List, failed: List, results: Dict):\n\n        \"\"\"Print concise audit summary\"\"\"\n\n        print(\"\\n\" + \"=\" * 80)\n\n        print(\"AUDIT SUMMARY\")\n\n        print(\"=\" * 80)\n\n        print(f\"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n\n        print(f\"Successful: {len(successful)}\")\n\n        print(f\"Failed: {len(failed)}\")\n\n        if failed:\n\n            print(f\"\\n[CRITICAL] Failed audits: {', '.join(failed)}\")\n\n        # Extract key metrics\n\n        key_metrics = self._extract_key_metrics(results)\n\n        if key_metrics:\n\n            print(\"\\nKey Metrics:\")\n\n            for metric, value in key_metrics.items():\n\n                print(f\"  {metric}: {value}\")\n\n        print(f\"\\nDetailed results saved to: {(self.audit_config or {}).get('results_file', 'development_tools/reports/analysis_detailed_results.json')}\")\n\n        if self.audit_config.get('prioritize_issues', False):\n\n            print(f\"Critical issues saved to: {self.audit_config['issues_file']}\")\n\n    def _extract_key_info(self, script_name: str, result: Dict[str, Any]):\n\n        \"\"\"Extract key information from script result.\"\"\"\n\n        if script_name not in self.results_cache:\n\n            self.results_cache[script_name] = {}\n\n        if 'analyze_functions' in script_name:\n\n            self._extract_function_metrics(result)\n\n        elif 'analyze_function_registry' in script_name:\n\n            self._extract_documentation_metrics(result)\n\n        elif 'decision_support' in script_name:\n\n            self._extract_decision_insights(result)\n\n        elif 'analyze_error_handling' in script_name:\n\n            self._extract_error_handling_metrics(result)\n\n        elif 'analyze_module_dependencies' in script_name:\n\n            data = result.get('data')\n\n            if data:\n\n                self.module_dependency_summary = data\n\n    def _extract_function_metrics(self, result: Dict[str, Any]):\n\n        \"\"\"Extract function-related metrics\"\"\"\n\n        output = result.get('output', '')\n\n        if not isinstance(output, str):\n\n            return\n\n        lines = output.split('\\n')\n\n        metrics: Dict[str, Any] = {}\n\n        import re\n\n        section_lookup = {\n\n            'high_complexity_examples': 'HIGH COMPLEXITY',\n\n            'critical_complexity_examples': 'CRITICAL COMPLEXITY',\n\n            'undocumented_examples': 'UNDOCUMENTED'\n\n        }\n\n        section_limits = {\n\n            'high_complexity_examples': 5,\n\n            'critical_complexity_examples': 5,\n\n            'undocumented_examples': 5\n\n        }\n\n        current_section = None\n\n        for raw_line in lines:\n\n            line = raw_line.rstrip()\n\n            lower = line.lower()\n\n            if 'found' in lower and 'functions' in lower:\n\n                match = re.search(r'Found (\\d+) functions', line)\n\n                if match:\n\n                    metrics['total_functions'] = int(match.group(1))\n\n                continue\n\n            if 'moderate complexity' in lower and '(' in line:\n\n                match = re.search(r'\\((\\d+)\\):', line)\n\n                if match:\n\n                    metrics['moderate_complexity'] = int(match.group(1))\n\n                continue\n\n            if line.strip().upper().startswith('HIGH COMPLEXITY'):\n\n                current_section = 'high_complexity_examples'\n\n                match = re.search(r'\\((\\d+)\\):', line)\n\n                if match:\n\n                    metrics['high_complexity'] = int(match.group(1))\n\n                continue\n\n            if line.strip().upper().startswith('CRITICAL COMPLEXITY'):\n\n                current_section = 'critical_complexity_examples'\n\n                match = re.search(r'\\((\\d+)\\):', line)\n\n                if match:\n\n                    metrics['critical_complexity'] = int(match.group(1))\n\n                continue\n\n            if line.strip().upper().startswith('UNDOCUMENTED'):\n\n                current_section = 'undocumented_examples'\n\n                match = re.search(r'\\((\\d+)\\):', line)\n\n                if match:\n\n                    metrics['undocumented'] = int(match.group(1))\n\n                continue\n\n            if any(line.strip().upper().startswith(label) for label in section_lookup.values()):\n\n                current_section = None\n\n                continue\n\n            if current_section:\n\n                stripped = line.strip()\n\n                if not stripped.startswith('- '):\n\n                    continue\n\n                if '...and' in stripped and 'more' in stripped:\n\n                    continue\n\n                entry = self._parse_function_entry(stripped[2:])\n\n                if entry is None:\n\n                    continue\n\n                metrics.setdefault(current_section, [])\n\n                if len(metrics[current_section]) < section_limits[current_section]:\n\n                    metrics[current_section].append(entry)\n\n        self.results_cache['analyze_functions'] = metrics\n\n    def _extract_documentation_metrics(self, result: Dict[str, Any]):\n\n        \"\"\"Extract documentation-related metrics\"\"\"\n\n        metrics: Dict[str, Any] = {}\n\n        data = result.get('data')\n\n        if isinstance(data, dict):\n            # Use analyze_functions for docstring coverage (consistent source)\n            # This measures actual docstrings in code, not registry documentation\n            fd_metrics = self.results_cache.get('analyze_functions', {}) or {}\n            total_functions = fd_metrics.get('total_functions')\n            undocumented = fd_metrics.get('undocumented', 0)\n            \n            # Initialize documented to None\n            documented = None\n            \n            if total_functions is not None and total_functions > 0:\n                # Calculate documented count from total - undocumented\n                documented = total_functions - undocumented\n                coverage_pct = (documented / total_functions) * 100\n                if 0 <= coverage_pct <= 100:\n                    metrics['doc_coverage'] = f\"{coverage_pct:.2f}%\"\n                else:\n                    metrics['doc_coverage'] = 'Unknown'\n            else:\n                # If analyze_functions data not available, mark as unknown\n                metrics['doc_coverage'] = 'Unknown'\n\n            # Get totals from data (for analyze_function_registry)\n            totals = data.get('totals')\n            if isinstance(totals, dict):\n\n                metrics['totals'] = totals\n\n                # Don't use registry's functions_found - it's only counting registry entries, not all functions\n                # Store it for reference but don't use it for calculations\n                registry_functions_found = totals.get('functions_found')\n                if registry_functions_found is not None:\n                    metrics['registry_functions_found'] = registry_functions_found  # For reference only\n\n                # Use actual total from analyze_functions (already calculated above)\n                if total_functions is not None:\n                    metrics['total_functions'] = total_functions\n\n                if documented is not None:\n\n                    metrics['documented_functions'] = documented\n\n                classes_found = totals.get('classes_found')\n\n                if classes_found is not None:\n\n                    metrics['classes_found'] = classes_found\n\n                files_scanned = totals.get('files_scanned')\n\n                if files_scanned is not None:\n\n                    metrics['files_scanned'] = files_scanned\n\n            missing = data.get('missing')\n\n            if isinstance(missing, dict):\n\n                metrics['missing_docs'] = missing.get('count')\n\n                metrics['missing_items'] = missing.get('count')\n\n                missing_files = missing.get('missing_files')\n\n                if missing_files:\n\n                    metrics['missing_files'] = missing_files\n\n            extra = data.get('extra')\n\n            if isinstance(extra, dict):\n\n                metrics['extra_items'] = extra.get('count')\n\n        else:\n\n            output = result.get('output', '')\n\n            if not isinstance(output, str):\n\n                self.results_cache['analyze_function_registry'] = metrics\n\n                return\n\n            lines_out = output.split('\\n')\n\n            for line in lines_out:\n\n                lower = line.lower()\n\n                if 'coverage:' in lower:\n\n                    import re\n\n                    match = re.search(r'coverage:\\s*(\\d+\\.?\\d*)%', line, re.IGNORECASE)\n\n                    if match:\n\n                        metrics['doc_coverage'] = match.group(1) + '%'\n\n                        continue\n\n                    coverage_text = line.split(':')[-1].strip()\n\n                    metrics['doc_coverage'] = coverage_text\n\n                elif 'missing from registry:' in lower:\n\n                    metrics['missing_docs'] = line.split(':')[-1].strip()\n\n                elif 'missing items:' in lower:\n\n                    import re\n\n                    match = re.search(r'missing items:\\s*(\\d+)', line, re.IGNORECASE)\n\n                    if match:\n\n                        metrics['missing_items'] = match.group(1)\n\n        self.results_cache['analyze_function_registry'] = metrics\n\n    def _extract_decision_insights(self, result: Dict[str, Any]):\n\n        \"\"\"Extract decision support insights and metrics (counts).\"\"\"\n\n        output = result.get('output', '')\n\n        if not isinstance(output, str):\n\n            return\n\n        lines = output.split('\\n')\n\n        insights: List[str] = []\n\n        metrics: Dict[str, Any] = {}\n        \n        # Track complexity examples\n        critical_examples: List[Dict[str, Any]] = []\n        high_examples: List[Dict[str, Any]] = []\n        current_section = None\n        i = 0\n\n        # Debug: log first few lines to verify output format\n        if lines and len(lines) > 0:\n            logger.debug(f\"decision_support output sample (first 10 lines): {lines[:10]}\")\n\n        while i < len(lines):\n            raw_line = lines[i]\n            line = raw_line.strip()\n            lower = line.lower()\n\n            if any(keyword in lower for keyword in ['[warn]', '[critical]', '[info]', '[complexity]', '[doc]', '[dupe]']):\n\n                insights.append(line)\n                \n                # Track which section we're in\n                if '[critical]' in lower and 'critical' in lower and 'complexity' in lower:\n                    current_section = 'critical'\n                elif '[high]' in lower and 'high' in lower and 'complexity' in lower:\n                    current_section = 'high'\n                elif '[moderate]' in lower:\n                    current_section = None  # Don't track moderate examples\n                else:\n                    # If we see a different section marker, reset\n                    if '[critical]' not in lower and '[high]' not in lower:\n                        # Keep current section if we're still in complexity section\n                        pass\n\n            if line.startswith('Total functions:'):\n\n                value = line.split(':', 1)[1].strip()\n\n                try:\n\n                    metrics['total_functions'] = int(value)\n\n                except ValueError:\n\n                    metrics['total_functions'] = value\n\n            elif line.startswith('Moderate complexity:'):\n\n                value = line.split(':', 1)[1].strip()\n\n                try:\n\n                    metrics['moderate_complexity'] = int(value)\n\n                except ValueError:\n\n                    metrics['moderate_complexity'] = value\n\n            elif line.startswith('High complexity:'):\n\n                value = line.split(':', 1)[1].strip()\n\n                try:\n\n                    metrics['high_complexity'] = int(value)\n\n                except ValueError:\n\n                    metrics['high_complexity'] = value\n\n            elif line.startswith('Critical complexity:'):\n\n                value = line.split(':', 1)[1].strip()\n\n                try:\n\n                    metrics['critical_complexity'] = int(value)\n\n                except ValueError:\n\n                    metrics['critical_complexity'] = value\n\n            elif line.startswith('Undocumented functions:'):\n\n                value = line.split(':', 1)[1].strip()\n\n                try:\n\n                    metrics['undocumented'] = int(value)\n\n                except ValueError:\n\n                    metrics['undocumented'] = value\n            \n            # Extract complexity examples from lines like \"    - function_name (file: file.py, complexity: 250)\"\n            elif line.startswith('- ') and current_section in ('critical', 'high'):\n                # Parse: \"    - function_name (file: file.py, complexity: 250)\"\n                # or: \"    - function_name (file: file.py, complexity: 250)\"\n                try:\n                    # Remove leading \"- \" and parse\n                    func_line = line[2:].strip()\n                    # Extract function name (before first parenthesis)\n                    if '(' in func_line:\n                        func_name = func_line.split('(')[0].strip()\n                        # Extract file and complexity from parentheses\n                        paren_content = func_line[func_line.find('(')+1:func_line.rfind(')')]\n                        file_match = None\n                        complexity_match = None\n                        if 'file:' in paren_content:\n                            file_part = paren_content.split('file:')[1].split(',')[0].strip()\n                            file_match = file_part\n                        if 'complexity:' in paren_content:\n                            complexity_part = paren_content.split('complexity:')[1].strip()\n                            try:\n                                complexity_match = int(complexity_part)\n                            except ValueError:\n                                pass\n                        \n                        example = {\n                            'name': func_name,\n                            'function': func_name,\n                            'file': file_match or 'unknown',\n                            'complexity': complexity_match or 0\n                        }\n                        \n                        if current_section == 'critical':\n                            critical_examples.append(example)\n                        elif current_section == 'high':\n                            high_examples.append(example)\n                except Exception as e:\n                    logger.debug(f\"Failed to parse complexity example line: {line} - {e}\")\n            \n            i += 1\n\n        if insights:\n\n            metrics['decision_support_items'] = len(insights)\n\n            metrics['decision_support_sample'] = insights[:5]\n        \n        # Store complexity examples in metrics\n        if critical_examples:\n            metrics['critical_complexity_examples'] = critical_examples\n        if high_examples:\n            metrics['high_complexity_examples'] = high_examples\n\n        # Store extracted metrics in results_cache\n        # Always store metrics, even if empty (empty dict is still valid data)\n        self.results_cache['decision_support_metrics'] = metrics\n        # Also store under 'decision_support' key for consistency with other tools\n        self.results_cache['decision_support'] = metrics\n        \n        if metrics:\n            logger.debug(f\"Extracted decision_support metrics: {list(metrics.keys())}\")\n        else:\n            logger.warning(\"No metrics extracted from decision_support output - metrics dict is empty\")\n        \n        # Also store examples in analyze_functions cache for backward compatibility\n        if 'analyze_functions' not in self.results_cache:\n            self.results_cache['analyze_functions'] = {}\n        if critical_examples:\n            self.results_cache['analyze_functions']['critical_complexity_examples'] = critical_examples\n        if high_examples:\n            self.results_cache['analyze_functions']['high_complexity_examples'] = high_examples\n\n    def _extract_error_handling_metrics(self, result: Dict[str, Any]):\n\n        \"\"\"Extract error handling coverage metrics\"\"\"\n\n        data = result.get('data')\n\n        if isinstance(data, dict):\n\n            metrics = {\n\n                'total_functions': data.get('total_functions', 0),\n\n                'functions_with_error_handling': data.get('functions_with_error_handling', 0),\n\n                'functions_missing_error_handling': data.get('functions_missing_error_handling', 0),\n\n                # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n                'analyze_error_handling': data.get('analyze_error_handling') or data.get('error_handling_coverage', 0),\n\n                'functions_with_decorators': data.get('functions_with_decorators', 0),\n\n                'error_handling_quality': data.get('error_handling_quality', {}),\n\n                'error_patterns': data.get('error_patterns', {}),\n\n                'recommendations': data.get('recommendations', []),\n\n                'worst_modules': data.get('worst_modules', []),\n\n                # Phase 1: Candidates for decorator replacement\n\n                'phase1_candidates': data.get('phase1_candidates', []),\n\n                'phase1_total': data.get('phase1_total', 0),\n\n                'phase1_by_priority': data.get('phase1_by_priority', {}),\n\n                # Phase 2: Generic exception raises\n\n                'phase2_exceptions': data.get('phase2_exceptions', []),\n\n                'phase2_total': data.get('phase2_total', 0),\n\n                'phase2_by_type': data.get('phase2_by_type', {})\n\n            }\n\n        else:\n\n            # Fallback to parsing output text\n\n            output = result.get('output', '')\n\n            if not isinstance(output, str):\n\n                return\n\n            metrics = {}\n\n            lines = output.split('\\n')\n\n            for line in lines:\n\n                if 'Total Functions:' in line:\n\n                    match = re.search(r'Total Functions: (\\d+)', line)\n\n                    if match:\n\n                        metrics['total_functions'] = int(match.group(1))\n\n                elif 'Functions with Error Handling:' in line:\n\n                    match = re.search(r'Functions with Error Handling: (\\d+)', line)\n\n                    if match:\n\n                        metrics['functions_with_error_handling'] = int(match.group(1))\n\n                elif 'Functions Missing Error Handling:' in line:\n\n                    match = re.search(r'Functions Missing Error Handling: (\\d+)', line)\n\n                    if match:\n\n                        metrics['functions_missing_error_handling'] = int(match.group(1))\n\n                elif 'Error Handling Coverage:' in line:\n\n                    match = re.search(r'Error Handling Coverage: ([\\d.]+)%', line)\n\n                    if match:\n\n                        metrics['analyze_error_handling'] = float(match.group(1))\n\n        self.results_cache['analyze_error_handling'] = metrics\n\n    def _extract_key_metrics(self, results: Dict[str, Any]) -> Dict[str, Any]:\n\n        \"\"\"Collect combined metrics for audit summary output.\"\"\"\n\n        combined: Dict[str, Any] = {}\n\n        for cache_key in ('analyze_functions', 'analyze_function_registry', 'decision_support_metrics', 'analyze_error_handling'):\n\n            cache = self.results_cache.get(cache_key)\n\n            if isinstance(cache, dict):\n\n                for key, value in cache.items():\n\n                    if value is not None and value != '':\n\n                        combined[key] = value\n\n        return combined\n\n    def _parse_function_entry(self, text: str) -> Optional[Dict[str, Any]]:\n\n        \"\"\"Parse a function discovery bullet into structured data.\"\"\"\n\n        if not text:\n\n            return None\n\n        import re\n\n        pattern = re.compile(\n\n            r'^(?P<name>.+?) \\(file: (?P<file>.+?), complexity: (?P<complexity>\\d+)\\)'\n\n        )\n\n        match = pattern.match(text.strip())\n\n        if not match:\n\n            return None\n\n        try:\n\n            complexity = int(match.group('complexity'))\n\n        except ValueError:\n\n            complexity = None\n\n        return {\n\n            'function': match.group('name').strip(),\n\n            'file': match.group('file').strip(),\n\n            'complexity': complexity,\n\n        }\n\n    def _extract_first_int(self, text: str) -> Optional[int]:\n\n        \"\"\"Return the first integer found in the supplied text or None.\"\"\"\n\n        if not isinstance(text, str):\n\n            return None\n\n        match = re.search(r'(-?\\d+)', text)\n\n        if match:\n\n            try:\n\n                return int(match.group(1))\n\n            except ValueError:\n\n                return None\n\n        return None\n\n    def _parse_doc_sync_output(self, output: str) -> Dict[str, Any]:\n\n        \"\"\"Derive structured metrics from documentation sync output.\"\"\"\n\n        summary: Dict[str, Any] = {\n\n            'status': None,\n\n            'total_issues': None,\n\n            'paired_doc_issues': None,\n\n            'path_drift_issues': None,\n\n            'ascii_issues': None,\n\n            'path_drift_files': []\n\n        }\n\n        if not isinstance(output, str) or not output.strip():\n\n            return summary\n\n        lines_iter = output.splitlines()\n\n        path_section = False\n\n        for raw_line in lines_iter:\n\n            line = raw_line.strip()\n\n            if not line:\n\n                if path_section:\n\n                    path_section = False\n\n                continue\n\n            if line.startswith('Status:'):\n\n                summary['status'] = line.split(':', 1)[1].strip() or None\n\n                continue\n\n            if line.startswith('Total Issues:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['total_issues'] = value\n\n                continue\n\n            if line.startswith('Paired Doc Issues:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['paired_doc_issues'] = value\n\n                continue\n\n            if line.startswith('Path Drift Issues:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['path_drift_issues'] = value\n\n                # Don't set path_section here - wait for \"Top files with most issues:\"\n                continue\n\n            if line.startswith('ASCII Compliance Issues:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['ascii_issues'] = value\n\n                # Stop path_section if it was active\n                path_section = False\n                continue\n\n            if line.startswith('Heading Numbering Issues:'):\n\n                # Stop path_section if it was active\n                path_section = False\n                continue\n\n            if line.startswith('Top files with most issues:'):\n\n                path_section = True\n\n                continue\n\n            # Stop path_section when we encounter a new section header\n            # Section headers are typically all caps or start with specific keywords\n            if (line.isupper() and ('ISSUES' in line or 'COMPLIANCE' in line or 'DOCUMENTATION' in line)) or \\\n               line.startswith('HEADING NUMBERING') or \\\n               line.startswith('ASCII COMPLIANCE') or \\\n               line.startswith('PAIRED DOCUMENTATION'):\n                path_section = False\n                continue\n\n            if path_section:\n\n                cleaned = line.lstrip('-*').strip()\n\n                if not cleaned:\n\n                    continue\n\n                if ':' in cleaned:\n\n                    file_part = cleaned.split(':', 1)[0].strip()\n\n                else:\n\n                    file_part = cleaned\n\n                # Skip if it looks like a section header (all caps, contains ISSUES, etc.)\n                if file_part and file_part.isupper() and ('ISSUES' in file_part or 'COMPLIANCE' in file_part):\n                    path_section = False\n                    continue\n\n                if file_part and file_part not in summary['path_drift_files']:\n\n                    summary['path_drift_files'].append(file_part)\n\n        return summary\n\n    def _parse_documentation_sync_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse paired documentation sync output.\"\"\"\n        issues = {}\n        if not isinstance(output, str) or not output.strip():\n            return issues\n        \n        lines = output.splitlines()\n        current_section = None\n        for line in lines:\n            line = line.strip()\n            if 'PAIRED DOCUMENTATION ISSUES:' in line:\n                current_section = 'paired_docs'\n                continue\n            if current_section == 'paired_docs' and line.startswith('   '):\n                if ':' in line:\n                    issue_type = line.split(':')[0].strip()\n                    if issue_type not in issues:\n                        issues[issue_type] = []\n                elif line.startswith('     - '):\n                    if current_section:\n                        last_type = list(issues.keys())[-1] if issues else None\n                        if last_type:\n                            issues[last_type].append(line[7:])\n        \n        return issues\n\n    def _parse_path_drift_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse path drift analysis output.\"\"\"\n        # Try to parse as JSON first (when --json flag is used)\n        if output.strip().startswith('{'):\n            try:\n                import json\n                parsed = json.loads(output)\n                # Normalize to standard format if needed\n                from .result_format import normalize_to_standard_format\n                normalized = normalize_to_standard_format('analyze_path_drift', parsed)\n                # LEGACY COMPATIBILITY: Convert back to legacy format for backward compatibility with existing code\n                # Removal plan: After all code using legacy format is updated, remove this conversion.\n                # Detection: Search for \"Convert back to legacy format\" in this file.\n                if 'summary' in normalized:\n                    logger.debug(\"_parse_path_drift_output: Converting standard format to legacy format (backward compatibility)\")\n                    return {\n                        'files': normalized.get('files', {}),\n                        'total_issues': normalized.get('summary', {}).get('total_issues', 0),\n                        'detailed_issues': normalized.get('details', {}).get('detailed_issues', {})\n                    }\n                return normalized\n            except (json.JSONDecodeError, ValueError):\n                pass  # Fall through to text parsing\n        \n        # LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility\n        # Removal plan: After all tools output JSON, remove text parsing fallback.\n        # Detection: Search for \"Fall back to text parsing for backward compatibility\" in this file.\n        result = {'files': {}, 'total_issues': 0}\n        if not isinstance(output, str) or not output.strip():\n            return result\n        \n        lines = output.splitlines()\n        in_files_section = False\n        for line in lines:\n            line = line.strip()\n            if 'Total issues found:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    result['total_issues'] = value\n            elif 'Top files with most issues:' in line:\n                in_files_section = True\n                continue\n            elif in_files_section and ':' in line and line.endswith('issues'):\n                parts = line.split(':')\n                if len(parts) == 2:\n                    file_path = parts[0].strip()\n                    issue_count = self._extract_first_int(parts[1])\n                    if issue_count is not None:\n                        result['files'][file_path] = issue_count\n        \n        return result\n\n    def _create_standard_format_result(self, total_issues: int, files_affected: int, \n                                       files: Optional[Dict[str, int]] = None, \n                                       details: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        \"\"\"Create a standard format result structure.\"\"\"\n        result = {\n            'summary': {\n                'total_issues': total_issues,\n                'files_affected': files_affected\n            },\n            'details': details or {}\n        }\n        if files:\n            result['files'] = files\n        return result\n\n    def _parse_ascii_compliance_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse ASCII compliance check output. Returns standard format.\"\"\"\n        # Try to parse as JSON first (when --json flag is used)\n        if output.strip().startswith('{'):\n            try:\n                import json\n                parsed = json.loads(output)\n                # Normalize to standard format if needed\n                from .result_format import normalize_to_standard_format\n                return normalize_to_standard_format(parsed)\n            except (json.JSONDecodeError, ValueError):\n                pass  # Fall through to text parsing\n        \n        # LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility\n        # Removal plan: After all tools output JSON, remove text parsing fallback.\n        # Detection: Search for \"Fall back to text parsing for backward compatibility\" in this file.\n        files = {}\n        total_issues = 0\n        file_count = 0\n        \n        if not isinstance(output, str) or not output.strip():\n            return self._create_standard_format_result(total_issues, file_count, files)\n        \n        lines = output.splitlines()\n        for line in lines:\n            line = line.strip()\n            if 'Total files with non-ASCII characters:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    file_count = value\n            elif 'Total issues found:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    total_issues = value\n            elif ':' in line and ('issues' in line.lower() or 'characters' in line.lower()):\n                parts = line.split(':')\n                if len(parts) == 2:\n                    file_path = parts[0].strip()\n                    issue_text = parts[1].strip()\n                    issue_count = self._extract_first_int(issue_text)\n                    if issue_count is not None:\n                        files[file_path] = issue_count\n        \n        return self._create_standard_format_result(total_issues, file_count, files)\n\n    def _parse_heading_numbering_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse heading numbering check output. Returns standard format.\"\"\"\n        # Try to parse as JSON first (when --json flag is used)\n        if output.strip().startswith('{'):\n            try:\n                import json\n                parsed = json.loads(output)\n                # Normalize to standard format if needed\n                from .result_format import normalize_to_standard_format\n                return normalize_to_standard_format(parsed)\n            except (json.JSONDecodeError, ValueError):\n                pass  # Fall through to text parsing\n        \n        # LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility\n        # Removal plan: After all tools output JSON, remove text parsing fallback.\n        # Detection: Search for \"Fall back to text parsing for backward compatibility\" in this file.\n        files = {}\n        total_issues = 0\n        file_count = 0\n        \n        if not isinstance(output, str) or not output.strip():\n            return self._create_standard_format_result(total_issues, file_count, files)\n        \n        lines = output.splitlines()\n        for line in lines:\n            line = line.strip()\n            if 'Total files with numbering issues:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    file_count = value\n            elif 'Total issues found:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    total_issues = value\n            elif ':' in line and 'issues' in line.lower():\n                parts = line.split(':')\n                if len(parts) == 2:\n                    file_path = parts[0].strip()\n                    issue_count = self._extract_first_int(parts[1])\n                    if issue_count is not None:\n                        files[file_path] = issue_count\n        \n        return self._create_standard_format_result(total_issues, file_count, files)\n\n    def _parse_missing_addresses_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse missing addresses check output.\"\"\"\n        # Try to parse as JSON first (when --json flag is used)\n        if output.strip().startswith('{'):\n            try:\n                import json\n                parsed = json.loads(output)\n                # Normalize to standard format if needed\n                from .result_format import normalize_to_standard_format\n                return normalize_to_standard_format(parsed)\n            except (json.JSONDecodeError, ValueError):\n                pass  # Fall through to text parsing\n        \n        # LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility\n        # Removal plan: After all tools output JSON, remove text parsing fallback.\n        # Detection: Search for \"Fall back to text parsing for backward compatibility\" in this file.\n        result = {'files': [], 'total_issues': 0}\n        if not isinstance(output, str) or not output.strip():\n            return result\n        \n        if 'All documentation files have file addresses!' in output:\n            return result\n        \n        lines = output.splitlines()\n        for line in lines:\n            line = line.strip()\n            if 'Total files missing addresses:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    result['total_issues'] = value\n            elif line.startswith('- ') or line.startswith('  - '):\n                file_path = line.lstrip('- ').strip()\n                if file_path:\n                    result['files'].append(file_path)\n        \n        return result\n\n    def _parse_unconverted_links_output(self, output: str) -> Dict[str, Any]:\n        \"\"\"Parse unconverted links check output.\"\"\"\n        # Try to parse as JSON first (when --json flag is used)\n        if output.strip().startswith('{'):\n            try:\n                import json\n                parsed = json.loads(output)\n                # Normalize to standard format if needed\n                from .result_format import normalize_to_standard_format\n                return normalize_to_standard_format(parsed)\n            except (json.JSONDecodeError, ValueError):\n                pass  # Fall through to text parsing\n        \n        # LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility\n        # Removal plan: After all tools output JSON, remove text parsing fallback.\n        # Detection: Search for \"Fall back to text parsing for backward compatibility\" in this file.\n        result = {'files': {}, 'total_issues': 0}\n        if not isinstance(output, str) or not output.strip():\n            return result\n        \n        lines = output.splitlines()\n        for line in lines:\n            line = line.strip()\n            if 'Total files with unconverted links:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    result['file_count'] = value\n            elif 'Total issues found:' in line:\n                value = self._extract_first_int(line)\n                if value is not None:\n                    result['total_issues'] = value\n            elif ':' in line and 'issues' in line.lower():\n                parts = line.split(':')\n                if len(parts) == 2:\n                    file_path = parts[0].strip()\n                    issue_count = self._extract_first_int(parts[1])\n                    if issue_count is not None:\n                        result['files'][file_path] = issue_count\n        \n        return result\n\n    def _aggregate_doc_sync_results(self, all_results: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Aggregate results from all documentation sync tools into unified summary.\"\"\"\n        summary: Dict[str, Any] = {\n            'status': 'PASS',\n            'total_issues': 0,\n            'paired_doc_issues': 0,\n            'path_drift_issues': 0,\n            'ascii_issues': 0,\n            'heading_numbering_issues': 0,\n            'missing_address_issues': 0,\n            'unconverted_link_issues': 0,\n            'path_drift_files': []\n        }\n        \n        # Aggregate paired docs\n        paired_docs = all_results.get('paired_docs', {})\n        if isinstance(paired_docs, dict):\n            for issue_type, issues in paired_docs.items():\n                if isinstance(issues, list):\n                    summary['paired_doc_issues'] += len(issues)\n                    summary['total_issues'] += len(issues)\n        \n        # Aggregate path drift\n        path_drift = all_results.get('path_drift', {})\n        if isinstance(path_drift, dict):\n            summary['path_drift_issues'] = path_drift.get('total_issues', 0)\n            summary['total_issues'] += summary['path_drift_issues']\n            files = path_drift.get('files', {})\n            if isinstance(files, dict):\n                summary['path_drift_files'] = list(files.keys())[:10]  # Top 10\n        \n        # Aggregate ASCII compliance\n        ascii_compliance = all_results.get('ascii_compliance', {})\n        if isinstance(ascii_compliance, dict):\n            summary['ascii_issues'] = ascii_compliance.get('total_issues', 0)\n            summary['total_issues'] += summary['ascii_issues']\n        \n        # Aggregate heading numbering\n        heading_numbering = all_results.get('heading_numbering', {})\n        if isinstance(heading_numbering, dict):\n            summary['heading_numbering_issues'] = heading_numbering.get('total_issues', 0)\n            summary['total_issues'] += summary['heading_numbering_issues']\n        \n        # Aggregate missing addresses\n        missing_addresses = all_results.get('missing_addresses', {})\n        if isinstance(missing_addresses, dict):\n            summary['missing_address_issues'] = missing_addresses.get('total_issues', 0)\n            summary['total_issues'] += summary['missing_address_issues']\n        \n        # Aggregate unconverted links\n        unconverted_links = all_results.get('unconverted_links', {})\n        if isinstance(unconverted_links, dict):\n            summary['unconverted_link_issues'] = unconverted_links.get('total_issues', 0)\n            summary['total_issues'] += summary['unconverted_link_issues']\n        \n        # Determine overall status\n        if summary['total_issues'] > 0:\n            summary['status'] = 'FAIL'\n        else:\n            summary['status'] = 'PASS'\n        \n        return summary\n\n    def _parse_legacy_output(self, output: str) -> Dict[str, Any]:\n\n        \"\"\"Extract headline metrics from the legacy cleanup output.\"\"\"\n\n        summary: Dict[str, Any] = {\n\n            'files_with_issues': None,\n\n            'legacy_markers': None,\n\n            'report_path': None\n\n        }\n\n        if not isinstance(output, str) or not output.strip():\n\n            return summary\n\n        for raw_line in output.splitlines():\n\n            line = raw_line.strip()\n\n            if not line:\n\n                continue\n\n            if line.startswith('Files with issues:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['files_with_issues'] = value\n\n                continue\n\n            if line.startswith('legacy_compatibility_markers:'):\n\n                value = self._extract_first_int(line)\n\n                if value is not None:\n\n                    summary['legacy_markers'] = value\n\n                continue\n\n            if line.startswith('Report saved to:'):\n\n                summary['report_path'] = line.split(':', 1)[1].strip() or None\n\n        return summary\n\n    def _format_list_for_display(self, items: Sequence[str], limit: int = 3) -> str:\n\n        \"\"\"Return a concise, comma-separated list with optional overflow marker.\"\"\"\n\n        filtered = [item for item in items if item]\n\n        if not filtered:\n\n            return ''\n\n        if len(filtered) <= limit:\n\n            return ', '.join(filtered)\n\n        visible = ', '.join(filtered[:limit])\n\n        remaining = len(filtered) - limit\n\n        return f\"{visible}, ... +{remaining}\"\n\n    def _format_percentage(self, value: Any, decimals: int = 1) -> str:\n\n        \"\"\"Format a numeric value as a percentage string.\"\"\"\n\n        try:\n\n            return f\"{float(value):.{decimals}f}%\"\n\n        except (TypeError, ValueError):\n\n            return str(value)\n\n    def _get_missing_doc_files(self, limit: int = 5) -> List[str]:\n\n        \"\"\"Return the top documentation files missing from the registry.\"\"\"\n\n        metrics = self.results_cache.get('analyze_function_registry', {})\n\n        missing_files = []\n\n        if isinstance(metrics, dict):\n\n            missing_files = metrics.get('missing_files') or []\n\n        if not isinstance(missing_files, list):\n\n            return []\n\n        return missing_files[:limit]\n\n    def _load_coverage_summary(self) -> Optional[Dict[str, Any]]:\n\n        \"\"\"Load overall and per-module coverage metrics from coverage.json.\"\"\"\n        \n        # Try project root first, then tests directory\n        coverage_path = self.project_root / \"coverage.json\"\n        if not coverage_path.exists():\n            coverage_path = self.project_root / \"development_tools\" / \"tests\" / \"coverage.json\"\n\n        if not coverage_path.exists():\n\n            return None\n\n        try:\n\n            with coverage_path.open('r', encoding='utf-8') as handle:\n\n                coverage_data = json.load(handle)\n\n        except (OSError, json.JSONDecodeError):\n\n            return None\n\n        files = coverage_data.get('files')\n\n        if not isinstance(files, dict) or not files:\n\n            return None\n\n        total_statements = 0\n\n        total_covered = 0\n\n        module_stats = defaultdict(lambda: {'statements': 0, 'covered': 0, 'missed': 0})\n\n        worst_files: List[Dict[str, Any]] = []\n\n        for path, info in files.items():\n\n            summary = info.get('summary') or {}\n\n            statements = summary.get('num_statements') or 0\n\n            covered = summary.get('covered_lines') or 0\n\n            missed = summary.get('missing_lines')\n\n            if missed is None:\n\n                missed = max(statements - covered, 0)\n\n            total_statements += statements\n\n            total_covered += covered\n\n            parts = path.replace('/', '\\\\').split('\\\\')\n\n            module_name = parts[0] if parts and parts[0] else 'root'\n\n            module_entry = module_stats[module_name]\n\n            module_entry['statements'] += statements\n\n            module_entry['covered'] += covered\n\n            module_entry['missed'] += missed\n\n            if statements > 0:\n\n                coverage_pct = round((covered / statements) * 100, 1)\n\n            else:\n\n                coverage_pct = 0.0\n\n            worst_files.append({\n\n                'path': path.replace('\\\\', '/'),\n\n                'coverage': coverage_pct,\n\n                'missing': missed\n\n            })\n\n        if total_statements == 0:\n\n            overall_coverage = 0.0\n\n        else:\n\n            overall_coverage = round((total_covered / total_statements) * 100, 1)\n\n        module_list: List[Dict[str, Any]] = []\n\n        for module_name, stats in module_stats.items():\n\n            statements = stats['statements']\n\n            if statements == 0:\n\n                coverage_pct = 0.0\n\n            else:\n\n                coverage_pct = round((stats['covered'] / statements) * 100, 1)\n\n            module_list.append({\n\n                'module': module_name.replace('\\\\', '/'),\n\n                'coverage': coverage_pct,\n\n                'missed': stats['missed']\n\n            })\n\n        module_list.sort(key=lambda item: item['coverage'])\n\n        worst_files.sort(key=lambda item: item['coverage'])\n\n        meta = coverage_data.get('meta', {})\n\n        timestamp = meta.get('timestamp')\n\n        return {\n\n            'overall': {\n\n                'coverage': overall_coverage,\n\n                'statements': total_statements,\n\n                'covered': total_covered,\n\n                'missed': max(total_statements - total_covered, 0),\n\n                'generated': timestamp\n\n            },\n\n            'modules': module_list,\n\n            'worst_files': worst_files[:5]\n\n        }\n\n    def _load_config_validation_summary(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Load config validation summary from JSON file.\"\"\"\n        try:\n            config_file = self.project_root / \"development_tools\" / \"config\" / \"jsons\" / \"analyze_config_results.json\"\n            if config_file.exists():\n                import json\n                with open(config_file, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    # Handle both old format (validation_results) and new format (data)\n                    if 'data' in data:\n                        # New format: data is at top level\n                        config_data = data['data']\n                        summary = config_data.get('summary', {})\n                        # Include recommendations and tools_analysis in the returned summary\n                        summary['recommendations'] = config_data.get('recommendations', [])\n                        summary['tools_analysis'] = config_data.get('tools_analysis', {})\n                        # Also include config_validation and completeness if available\n                        if 'config_validation' in config_data:\n                            config_validation = config_data['config_validation']\n                            summary['config_valid'] = config_validation.get('config_structure_valid', summary.get('config_valid', False))\n                        if 'completeness' in config_data:\n                            completeness = config_data['completeness']\n                            summary['config_complete'] = completeness.get('sections_complete', summary.get('config_complete', False))\n                        return summary\n                    elif 'validation_results' in data:\n                        # Old format: validation_results wrapper\n                        validation_results = data.get('validation_results', {})\n                        summary = validation_results.get('summary', {})\n                        # Include recommendations and tools_analysis in the returned summary\n                        summary['recommendations'] = validation_results.get('recommendations', [])\n                        summary['tools_analysis'] = validation_results.get('tools_analysis', {})\n                        return summary\n        except Exception as e:\n            logger.debug(f\"Failed to load config validation summary: {e}\")\n        return None\n\n    def _load_dev_tools_coverage(self) -> None:\n        \"\"\"Load dev tools coverage from JSON file if it exists.\"\"\"\n        coverage_path = self.project_root / \"development_tools\" / \"tests\" / \"coverage_dev_tools.json\"\n        \n        if not coverage_path.exists():\n            return\n        \n        try:\n            with coverage_path.open('r', encoding='utf-8') as handle:\n                coverage_data = json.load(handle)\n        except (OSError, json.JSONDecodeError):\n            return\n        \n        files = coverage_data.get('files')\n        if not isinstance(files, dict) or not files:\n            return\n        \n        total_statements = 0\n        total_missed = 0\n        \n        for path, info in files.items():\n            summary = info.get('summary') or {}\n            statements = summary.get('num_statements') or 0\n            missed = summary.get('missing_lines') or 0\n            total_statements += statements\n            total_missed += missed\n        \n        if total_statements == 0:\n            overall_coverage = 0.0\n        else:\n            overall_coverage = round((total_statements - total_missed) / total_statements * 100, 1)\n        \n        module_data = self._load_coverage_json(coverage_path)\n        self.dev_tools_coverage_results = {\n            'overall': {\n                'overall_coverage': overall_coverage,\n                'total_statements': total_statements,\n                'total_missed': total_missed\n            },\n            'modules': module_data,\n            'coverage_collected': True,\n            'output_file': str(coverage_path),\n            'html_dir': None  # HTML reports disabled\n        }\n\n    def _parse_module_dependency_report(self, output: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Extract summary statistics from analyze_module_dependencies output.\"\"\"\n        if not output:\n            return None\n\n        summary: Dict[str, Any] = {}\n        patterns = {\n            'files_scanned': r\"Files scanned:\\s+(\\d+)\",\n            'total_imports': r\"Total imports found:\\s+(\\d+)\",\n            'documented_dependencies': r\"Dependencies documented:\\s+(\\d+)\",\n            'standard_library': r\"Standard library imports:\\s+(\\d+)\",\n            'third_party': r\"Third-party imports:\\s+(\\d+)\",\n            'local_imports': r\"Local imports:\\s+(\\d+)\",\n            'missing_dependencies': r\"Total missing dependencies:\\s+(\\d+)\",\n        }\n\n        for key, pattern in patterns.items():\n            match = re.search(pattern, output)\n            if match:\n                try:\n                    summary[key] = int(match.group(1))\n                except ValueError:\n                    summary[key] = None\n\n        missing_files = re.findall(r\"\\[FILE\\]\\s+([^:]+):\", output)\n        missing_sections = re.findall(r\"\\[DIR\\]\\s+(.+?) - ENTIRE FILE MISSING\", output)\n\n        if not summary and not missing_files and not missing_sections:\n            return None\n\n        if missing_files:\n            summary['missing_files'] = [item.strip() for item in missing_files[:5]]\n        if missing_sections:\n            summary['missing_sections'] = [item.strip() for item in missing_sections[:5]]\n\n        return summary\n\n    def _load_coverage_json(self, json_path: Path) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load module metrics from coverage JSON output.\"\"\"\n        try:\n            with json_path.open('r', encoding='utf-8') as json_file:\n                data = json.load(json_file)\n        except (OSError, json.JSONDecodeError):\n            return {}\n        \n        files = data.get('files', {})\n        coverage_data: Dict[str, Dict[str, Any]] = {}\n        \n        for module_name, file_data in files.items():\n            summary = file_data.get('summary', {})\n            statements = int(summary.get('num_statements', 0))\n            covered = int(summary.get('covered_lines', statements - summary.get('missing_lines', 0)))\n            missed = int(summary.get('missing_lines', statements - covered))\n            percent = summary.get('percent_covered')\n            if isinstance(percent, float):\n                percent_value = int(round(percent))\n            else:\n                try:\n                    percent_value = int(percent)\n                except (TypeError, ValueError):\n                    percent_value = 0\n            \n            missing_lines = file_data.get('missing_lines', [])\n            missing_line_strings = [str(line) for line in missing_lines]\n            \n            coverage_data[module_name] = {\n                'statements': statements,\n                'missed': missed,\n                'coverage': percent_value,\n                'missing_lines': missing_line_strings,\n                'covered': covered\n            }\n        \n        return coverage_data\n\n    def _get_dev_tools_coverage_insights(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Return summarized dev tools coverage insights.\"\"\"\n        results = getattr(self, 'dev_tools_coverage_results', None)\n        if not results:\n            return None\n        modules = results.get('modules')\n        if (not modules) and results.get('output_file'):\n            try:\n                modules = self._load_coverage_json(Path(results['output_file']))\n            except Exception:\n                modules = {}\n        if not isinstance(modules, dict):\n            modules = {}\n        overall = results.get('overall') or {}\n        overall_pct = overall.get('overall_coverage') or overall.get('coverage')\n        total_statements = overall.get('total_statements')\n        total_missed = overall.get('total_missed')\n        if (total_statements is None or total_missed is None) and modules:\n            total_statements = sum((data.get('statements') or 0) for data in modules.values())\n            total_missed = sum((data.get('missed') or 0) for data in modules.values())\n        covered = None\n        if total_statements is not None and total_missed is not None:\n            covered = max(total_statements - total_missed, 0)\n        low_modules: List[Dict[str, Any]] = []\n        if modules:\n            sorted_modules = sorted(modules.items(), key=lambda kv: kv[1].get('coverage', 101))\n            for name, data in sorted_modules:\n                coverage_value = data.get('coverage')\n                if coverage_value is None:\n                    continue\n                low_modules.append({\n                    'path': name,\n                    'coverage': coverage_value,\n                    'missed': data.get('missed'),\n                    'statements': data.get('statements')\n                })\n                if len(low_modules) == 3:\n                    break\n        return {\n            'overall_pct': overall_pct,\n            'statements': total_statements,\n            'covered': covered,\n            'html': results.get('html_dir'),\n            'low_modules': low_modules,\n            'module_count': len(modules),\n        }\n\n    def _get_canonical_metrics(self) -> Dict[str, Any]:\n\n        \"\"\"Provide consistent totals across downstream documents.\"\"\"\n\n        results_cache = self.results_cache or {}\n        fd_metrics = results_cache.get('analyze_functions', {}) or {}\n\n        ds_metrics = results_cache.get('decision_support_metrics', {}) or {}\n\n        audit_data = results_cache.get('analyze_function_registry', {}) or {}\n\n        audit_totals = audit_data.get('totals') if isinstance(audit_data, dict) else {}\n        if audit_totals is None or not isinstance(audit_totals, dict):\n            audit_totals = {}\n\n        # PRIORITY: Always use analyze_functions first (most accurate)\n        # Don't use analyze_function_registry's functions_found - it only counts registry entries, not all functions\n        total_functions = None\n\n        # First priority: analyze_functions (most accurate)\n        if fd_metrics:\n            total_functions = fd_metrics.get('total_functions')\n\n        # Second priority: decision_support\n        if total_functions is None:\n            total_functions = ds_metrics.get('total_functions')\n\n        # Last resort: analyze_function_registry (but only if it's reasonable)\n        if total_functions is None and isinstance(audit_data, dict):\n            audit_total = audit_data.get('total_functions')\n            if audit_total is not None and isinstance(audit_total, int) and audit_total > 100:\n                # Only use if it seems reasonable (not the 11 from registry scan)\n                total_functions = audit_total\n\n        # Final fallback: audit_totals (but validate it's reasonable)\n        if total_functions is None and isinstance(audit_totals, dict):\n            registry_total = audit_totals.get('functions_found')\n            if registry_total is not None and isinstance(registry_total, int) and registry_total > 100:\n                # Only use if reasonable (not the 11 from limited registry scan)\n                total_functions = registry_total\n\n        moderate = fd_metrics.get('moderate_complexity')\n\n        if moderate is None:\n\n            moderate = ds_metrics.get('moderate_complexity')\n\n        high = fd_metrics.get('high_complexity')\n\n        if high is None:\n\n            high = ds_metrics.get('high_complexity')\n\n        critical = fd_metrics.get('critical_complexity')\n\n        if critical is None:\n\n            critical = ds_metrics.get('critical_complexity')\n        \n        # If still missing, try loading from cache\n        if total_functions is None or moderate is None or high is None or critical is None:\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    \n                    # Try analyze_functions first\n                    if 'results' in cached_data and 'analyze_functions' in cached_data['results']:\n                        func_data = cached_data['results']['analyze_functions']\n                        if 'data' in func_data:\n                            cached_metrics = func_data['data']\n                            if total_functions is None:\n                                total_functions = cached_metrics.get('total_functions')\n                            if moderate is None:\n                                moderate = cached_metrics.get('moderate_complexity')\n                            if high is None:\n                                high = cached_metrics.get('high_complexity')\n                            if critical is None:\n                                critical = cached_metrics.get('critical_complexity')\n                    \n                    # Fallback to decision_support\n                    if (total_functions is None or moderate is None or high is None or critical is None) and 'results' in cached_data:\n                        if 'decision_support' in cached_data['results']:\n                            ds_data = cached_data['results']['decision_support']\n                            if 'data' in ds_data and 'decision_support_metrics' in ds_data['data']:\n                                cached_ds_metrics = ds_data['data']['decision_support_metrics']\n                                if total_functions is None:\n                                    total_functions = cached_ds_metrics.get('total_functions')\n                                if moderate is None:\n                                    moderate = cached_ds_metrics.get('moderate_complexity')\n                                if high is None:\n                                    high = cached_ds_metrics.get('high_complexity')\n                                if critical is None:\n                                    critical = cached_ds_metrics.get('critical_complexity')\n                    \n                    # Fallback to analyze_function_registry - parse high_complexity array\n                    if (high is None or critical is None) and 'results' in cached_data:\n                        if 'analyze_function_registry' in cached_data['results']:\n                            afr_data = cached_data['results']['analyze_function_registry']\n                            if 'data' in afr_data and 'analysis' in afr_data['data']:\n                                analysis = afr_data['data']['analysis']\n                                high_complexity_array = analysis.get('high_complexity', [])\n                                if isinstance(high_complexity_array, list):\n                                    # Count by thresholds: MODERATE=50, HIGH=100, CRITICAL=200\n                                    critical_count = sum(1 for f in high_complexity_array \n                                                        if isinstance(f, dict) and f.get('complexity', 0) >= 200)\n                                    high_count = sum(1 for f in high_complexity_array \n                                                   if isinstance(f, dict) and 100 <= f.get('complexity', 0) < 200)\n                                    if critical is None:\n                                        critical = critical_count\n                                    if high is None:\n                                        high = high_count\n                                    # For moderate, we'd need all functions, but we can estimate if we have total\n                                    if moderate is None and total_functions is not None and isinstance(total_functions, int):\n                                        # Estimate: total - high - critical (approximate, may include low complexity)\n                                        moderate = max(0, total_functions - high_count - critical_count)\n            except Exception as e:\n                logger.debug(f\"Failed to load metrics from cache in _get_canonical_metrics: {e}\")\n                pass\n\n        doc_coverage = audit_data.get('doc_coverage') if isinstance(audit_data, dict) else None\n\n        # Use analyze_functions for docstring coverage (consistent source)\n        # This measures actual docstrings in code, not registry documentation\n        if doc_coverage is None:\n            # Get from analyze_functions data\n            fd_metrics = self.results_cache.get('analyze_functions', {}) or {}\n            func_total = fd_metrics.get('total_functions')\n            func_undocumented = fd_metrics.get('undocumented', 0)\n            \n            if func_total is not None and func_total > 0:\n                # Calculate documented count from total - undocumented\n                func_documented = func_total - func_undocumented\n                coverage_pct = (func_documented / func_total) * 100\n                if 0 <= coverage_pct <= 100:\n                    doc_coverage = f\"{coverage_pct:.2f}%\"\n                else:\n                    doc_coverage = 'Unknown'\n            else:\n                doc_coverage = 'Unknown'\n\n        # Validate any existing doc_coverage value and reject invalid ones\n        if isinstance(doc_coverage, str):\n            # Check for obviously wrong values\n            if '12690' in doc_coverage or 'Unknown' not in doc_coverage:\n                try:\n                    # Try to parse the percentage\n                    val_str = doc_coverage.strip('%').replace(',', '')\n                    if val_str.replace('.', '').isdigit():\n                        val = float(val_str)\n                        if val > 100:\n                            # Invalid - recalculate if we have the data\n                            # Try to get documented count from available data\n                            fd_metrics = self.results_cache.get('analyze_functions', {}) or {}\n                            func_total = fd_metrics.get('total_functions')\n                            func_undocumented = fd_metrics.get('undocumented', 0)\n                            if func_total is not None and func_total > 0:\n                                func_documented = func_total - func_undocumented\n                                coverage_pct = (func_documented / func_total) * 100\n                                if 0 <= coverage_pct <= 100:\n                                    doc_coverage = f\"{coverage_pct:.2f}%\"\n                                else:\n                                    doc_coverage = 'Unknown'\n                            else:\n                                doc_coverage = 'Unknown'\n                except (ValueError, TypeError):\n                    # Can't parse - might be valid string like \"Unknown\"\n                    if '12690' in doc_coverage:\n                        doc_coverage = 'Unknown'\n        \n        if doc_coverage is None or (isinstance(doc_coverage, str) and '12690' in doc_coverage):\n            doc_coverage = 'Unknown'\n        \n        # Return metrics dict with all values\n        return {\n            'total_functions': total_functions if total_functions is not None else 'Unknown',\n            'moderate': moderate if moderate is not None else 'Unknown',\n            'high': high if high is not None else 'Unknown',\n            'critical': critical if critical is not None else 'Unknown',\n            'doc_coverage': doc_coverage\n        }\n\n    def _load_tool_data(self, tool_name: str, domain: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Unified data loading helper with consistent fallback chain.\n        \n        Loads tool data from multiple sources in order of preference:\n        1. results_cache (in-memory, fastest)\n        2. load_tool_result() (standardized storage)\n        3. Central aggregation file (analysis_detailed_results.json)\n        \n        All data is normalized to standard format before returning.\n        \n        Args:\n            tool_name: Name of the tool (e.g., 'analyze_functions')\n            domain: Domain directory (e.g., 'functions'). If None, inferred from tool_name\n            \n        Returns:\n            Dict containing tool data in standard format, or empty dict if not found\n        \"\"\"\n        # Step 1: Check results_cache (in-memory, fastest)\n        if hasattr(self, 'results_cache') and self.results_cache:\n            cached_data = self.results_cache.get(tool_name)\n            if cached_data and isinstance(cached_data, dict):\n                logger.debug(f\"Loaded {tool_name} from results_cache\")\n                # Normalize before returning\n                from .result_format import normalize_to_standard_format\n                normalized = normalize_to_standard_format(tool_name, cached_data)\n                return normalized\n        \n        # Step 2: Fallback to standardized storage\n        try:\n            from .output_storage import load_tool_result\n            stored_data = load_tool_result(tool_name, domain, project_root=self.project_root, normalize=True)\n            if stored_data and isinstance(stored_data, dict):\n                logger.debug(f\"Loaded {tool_name} from standardized storage\")\n                # Store normalized format in cache for future use\n                if not hasattr(self, 'results_cache'):\n                    self.results_cache = {}\n                self.results_cache[tool_name] = stored_data\n                return stored_data\n        except Exception as e:\n            logger.debug(f\"Failed to load {tool_name} from standardized storage: {e}\")\n        \n        # Step 3: Fallback to central aggregation file\n        try:\n            import json\n            results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n            if results_file.exists():\n                with open(results_file, 'r', encoding='utf-8') as f:\n                    cached_data = json.load(f)\n                \n                if 'results' in cached_data and tool_name in cached_data['results']:\n                    tool_data = cached_data['results'][tool_name]\n                    # Handle nested data structure: results.tool_name.data\n                    if 'data' in tool_data:\n                        data = tool_data['data']\n                        logger.debug(f\"Loaded {tool_name} from central aggregation file\")\n                        # Normalize before returning\n                        from .result_format import normalize_to_standard_format\n                        normalized = normalize_to_standard_format(tool_name, data)\n                        # Store normalized format in cache for future use\n                        if not hasattr(self, 'results_cache'):\n                            self.results_cache = {}\n                        self.results_cache[tool_name] = normalized\n                        return normalized\n                    else:\n                        # Some tools store data directly without 'data' wrapper\n                        logger.debug(f\"Loaded {tool_name} from central aggregation file (direct)\")\n                        # Normalize before returning\n                        from .result_format import normalize_to_standard_format\n                        normalized = normalize_to_standard_format(tool_name, tool_data)\n                        if not hasattr(self, 'results_cache'):\n                            self.results_cache = {}\n                        self.results_cache[tool_name] = normalized\n                        return normalized\n        except Exception as e:\n            logger.debug(f\"Failed to load {tool_name} from central aggregation file: {e}\")\n        \n        # No data found in any source\n        logger.debug(f\"No data found for {tool_name} in any source\")\n        return {}\n\n    def _extract_actionable_insights(self, output: str) -> str:\n\n        \"\"\"Extract and format actionable insights from raw output.\"\"\"\n\n        if not isinstance(output, str):\n\n            return 'No specific actionable insights found.'\n\n        lines = output.split('\\n')\n\n        insights = []\n\n        for line in lines:\n\n            if any(keyword in line.lower() for keyword in ['suggest', 'recommend', 'next step', 'action']):\n\n                insights.append(line.strip())\n\n        if insights:\n\n            return '\\n'.join(insights[:10])\n\n        return 'No specific actionable insights found.'\n\n    def _save_audit_results_aggregated(self, tier: int):\n        \"\"\"Save aggregated audit results from all tool result files.\n        \n        Args:\n            tier: Audit tier (1=quick, 2=standard, 3=full)\n        \"\"\"\n        # Get all tool results from standardized storage\n        all_results = get_all_tool_results(project_root=self.project_root)\n        \n        # Convert to expected format\n        enhanced_results = {}\n        successful = []\n        failed = []\n        \n        for tool_name, result_data in all_results.items():\n            # Extract data from standardized format\n            if isinstance(result_data, dict):\n                tool_data = result_data.get('data', result_data)\n                enhanced_results[tool_name] = {\n                    'success': True,\n                    'data': tool_data,\n                    'timestamp': result_data.get('timestamp', datetime.now().isoformat())\n                }\n                successful.append(tool_name)\n            else:\n                enhanced_results[tool_name] = {\n                    'success': False,\n                    'data': {},\n                    'error': 'Invalid result format'\n                }\n                failed.append(tool_name)\n        \n        # Also include results from results_cache that might not be in files yet\n        for tool_name, data in self.results_cache.items():\n            if tool_name not in enhanced_results:\n                enhanced_results[tool_name] = {\n                    'success': True,\n                    'data': data,\n                    'timestamp': datetime.now().isoformat()\n                }\n                if tool_name not in successful:\n                    successful.append(tool_name)\n        \n        # Determine source command based on tier\n        if tier == 1:\n            source_cmd = 'python development_tools/run_development_tools.py audit --quick'\n        elif tier == 3:\n            source_cmd = 'python development_tools/run_development_tools.py audit --full'\n        else:\n            source_cmd = 'python development_tools/run_development_tools.py audit'\n        \n        timestamp_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        timestamp_iso = datetime.now().isoformat()\n        audit_data = {\n            'generated_by': 'run_development_tools.py - AI Development Tools Runner',\n            'last_generated': timestamp_str,\n            'source': source_cmd,\n            'audit_tier': tier,\n            'note': 'This file is auto-generated. Do not edit manually.',\n            'timestamp': timestamp_iso,\n            'successful': successful,\n            'failed': failed,\n            'results': enhanced_results\n        }\n\n        # Save to central aggregation file\n        results_file_path = self.audit_config.get('results_file', 'development_tools/reports/analysis_detailed_results.json')\n        results_file = (self.project_root / results_file_path).resolve()\n\n        # Ensure results_file is a Path object, not a string\n        if isinstance(results_file, str):\n            results_file = Path(results_file)\n        \n        # Import json if not already imported\n        import json\n        create_output_file(str(results_file), json.dumps(audit_data, indent=2), project_root=self.project_root)\n\n    def _generate_audit_report(self):\n\n        \"\"\"Generate comprehensive audit report\"\"\"\n\n        report_lines = []\n\n        report_lines.append(\"COMPREHENSIVE AUDIT REPORT\")\n\n        report_lines.append(\"=\" * 60)\n\n        report_lines.append(f\"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n\n        report_lines.append(\"\")\n\n        # Add detailed results for each component\n\n        for script_name, metrics in self.results_cache.items():\n\n            if metrics:\n\n                report_lines.append(f\"[{script_name.upper()}]\")\n\n                report_lines.append(\"-\" * 40)\n\n                if isinstance(metrics, dict):\n\n                    for key, value in metrics.items():\n\n                        report_lines.append(f\"  {key}: {value}\")\n\n                elif isinstance(metrics, list):\n\n                    for item in metrics:\n\n                        report_lines.append(f\"  {item}\")\n\n                report_lines.append(\"\")\n\n        # Add system information\n\n        report_lines.append(\"[SYSTEM INFO]\")\n\n        report_lines.append(\"-\" * 40)\n\n        report_lines.append(f\"Python version: {sys.version}\")\n\n        report_lines.append(f\"Working directory: {os.getcwd()}\")\n\n        report_lines.append(f\"Timestamp: {datetime.now().isoformat()}\")\n\n        return \"\\n\".join(report_lines)\n\n    def _resolve_report_path(self, report_path: str) -> Path:\n        \"\"\"Helper to resolve relative report paths to absolute paths.\"\"\"\n        if isinstance(report_path, str):\n            # If it's a relative path, make it absolute\n            if not Path(report_path).is_absolute():\n                return self.project_root / report_path\n            else:\n                return Path(report_path)\n        else:\n            return Path(report_path) if not isinstance(report_path, Path) else report_path\n\n    def _generate_ai_status_document(self) -> str:\n\n        \"\"\"Generate AI-optimized status document.\"\"\"\n        \n        # Check if this is a mid-audit write (not the legitimate end-of-audit write)\n        # Only warn if audit is in progress AND we're not in the legitimate end-of-audit context\n        # (indicated by current_audit_tier being set, which means we're in run_audit()'s finally block)\n        instance_flag = hasattr(self, '_audit_in_progress') and self._audit_in_progress\n        audit_in_progress = instance_flag or _is_audit_in_progress(self.project_root)\n        is_legitimate_end_write = hasattr(self, 'current_audit_tier') and self.current_audit_tier is not None\n        \n        if audit_in_progress and not is_legitimate_end_write:\n            # This is a mid-audit write from a new instance (likely from tests or separate process)\n            if not instance_flag:\n                logger.warning(\"_generate_ai_status_document() called from NEW instance during audit! This should only happen at the end.\")\n            else:\n                logger.warning(\"_generate_ai_status_document() called during audit! This should only happen at the end.\")\n            import traceback\n            logger.debug(f\"Call stack:\\n{''.join(traceback.format_stack())}\")\n\n        lines: List[str] = []\n\n        lines.append(\"# AI Status - Current Codebase State\")\n\n        lines.append(\"\")\n\n        lines.append(\"> **File**: `development_tools/AI_STATUS.md`\")\n        lines.append(\"> **Generated**: This file is auto-generated. Do not edit manually.\")\n        lines.append(f\"> **Last Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        # Determine source command based on audit tier\n        # If audit is in progress but tier is not set, log a warning\n        if hasattr(self, '_audit_in_progress') and self._audit_in_progress and self.current_audit_tier is None:\n            logger.warning(\"_generate_ai_status_document() called during audit but current_audit_tier is None!\")\n        \n        if self.current_audit_tier == 1:\n            source_cmd = \"python development_tools/run_development_tools.py audit --quick\"\n            tier_name = \"Tier 1 (Quick Audit)\"\n        elif self.current_audit_tier == 3:\n            source_cmd = \"python development_tools/run_development_tools.py audit --full\"\n            tier_name = \"Tier 3 (Full Audit)\"\n        elif self.current_audit_tier == 2:\n            source_cmd = \"python development_tools/run_development_tools.py audit\"\n            tier_name = \"Tier 2 (Standard Audit)\"\n        else:\n            source_cmd = \"python development_tools/run_development_tools.py status\"\n            tier_name = \"Status Check (cached data)\"\n        lines.append(f\"> **Source**: `{source_cmd}`\")\n        if self.current_audit_tier:\n            lines.append(f\"> **Last Audit Tier**: {tier_name}\")\n        lines.append(\"> **Generated by**: run_development_tools.py - AI Development Tools Runner\")\n        lines.append(\"\")\n\n        def percent_text(value: Any, decimals: int = 1) -> str:\n\n            if value is None:\n\n                return \"Unknown\"\n\n            if isinstance(value, str):\n\n                return value if value.strip().endswith('%') else f\"{value}%\"\n\n            return self._format_percentage(value, decimals)\n\n        def to_int(value: Any) -> Optional[int]:\n            if isinstance(value, int):\n                return value\n            if isinstance(value, float):\n                return int(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return int(float(stripped))\n                except ValueError:\n                    return None\n            if isinstance(value, dict):\n                count = value.get('count')\n                return to_int(count)\n            return None\n\n        def to_float(value: Any) -> Optional[float]:\n            if isinstance(value, (int, float)):\n                return float(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return float(stripped)\n                except ValueError:\n                    return None\n            return None\n\n        metrics = self._get_canonical_metrics()\n        if not isinstance(metrics, dict):\n            metrics = {}\n\n        # Load all tool data using unified loader\n        doc_metrics = self._load_tool_data('analyze_function_registry', 'functions')\n        error_metrics = self._load_tool_data('analyze_error_handling', 'error_handling')\n        function_metrics = self._load_tool_data('analyze_functions', 'functions')\n        analyze_docs_data = self._load_tool_data('analyze_documentation', 'docs')\n        # Load additional documentation analysis tools\n        ascii_data = self._load_tool_data('analyze_ascii_compliance', 'docs')\n        heading_data = self._load_tool_data('analyze_heading_numbering', 'docs')\n        missing_addresses_data = self._load_tool_data('analyze_missing_addresses', 'docs')\n        unconverted_links_data = self._load_tool_data('analyze_unconverted_links', 'docs')\n        \n        # Extract overlap analysis data\n        # Check if overlap analysis was run (indicated by presence of these keys, even if empty)\n        # If keys don't exist, overlap analysis wasn't run\n        # If keys exist but are None/empty, analysis was run but found nothing\n        # Check both top level and details section (normalization may move data to details)\n        details = analyze_docs_data.get('details', {})\n        overlap_analysis_ran = (\n            'section_overlaps' in analyze_docs_data or \n            'consolidation_recommendations' in analyze_docs_data or\n            'section_overlaps' in details or \n            'consolidation_recommendations' in details\n        )\n        \n        # Get from top level first, then fall back to details\n        section_overlaps = (\n            analyze_docs_data.get('section_overlaps') or \n            details.get('section_overlaps', {})\n        ) if overlap_analysis_ran else {}\n        consolidation_recs = (\n            analyze_docs_data.get('consolidation_recommendations') or \n            details.get('consolidation_recommendations', [])\n        ) if overlap_analysis_ran else []\n        \n        # Normalize to empty dict/list if None\n        if section_overlaps is None:\n            section_overlaps = {}\n        if consolidation_recs is None:\n            consolidation_recs = []\n        \n        doc_coverage = doc_metrics.get('doc_coverage', metrics.get('doc_coverage', 'Unknown'))\n\n        missing_docs = doc_metrics.get('missing_docs') or doc_metrics.get('missing_items')\n\n        missing_files = self._get_missing_doc_files(limit=4)\n\n        # Helper to access error metrics - checks details first (normalized), then top level (backward compat)\n        def get_error_field(field_name, default=None):\n            error_details = error_metrics.get('details', {})\n            return error_details.get(field_name, error_metrics.get(field_name, default))\n\n        # Access error metrics - check standard format first, then fall back to details/old format\n        error_summary = error_metrics.get('summary', {})\n        error_details = error_metrics.get('details', {})\n        \n        # Use standard format summary for total issues (missing error handlers)\n        missing_error_handlers = to_int(error_summary.get('total_issues'))\n        # Always check details as well, since normalization might have put it there\n        if missing_error_handlers is None:\n            # Fallback to old format in details or top level\n            missing_error_handlers = to_int(error_details.get('functions_missing_error_handling')) or to_int(error_metrics.get('functions_missing_error_handling')) or 0\n        # Also check if details has it even if summary says 0 (data might be inconsistent)\n        details_missing = to_int(error_details.get('functions_missing_error_handling'))\n        if details_missing is not None and details_missing > 0 and (missing_error_handlers is None or missing_error_handlers == 0):\n            missing_error_handlers = details_missing\n        \n        # Get other fields - check details first (normalized), then top level (backward compat)\n        error_coverage = error_details.get('analyze_error_handling') or error_details.get('error_handling_coverage') or error_metrics.get('analyze_error_handling') or error_metrics.get('error_handling_coverage')\n        error_total = error_details.get('total_functions') or error_metrics.get('total_functions')\n        error_with_handling = error_details.get('functions_with_error_handling') or error_metrics.get('functions_with_error_handling')\n        canonical_total = metrics.get('total_functions')\n        \n        # Calculate coverage using error_total (actual functions analyzed), not canonical_total\n        # This ensures accuracy - error handling analysis may analyze fewer functions than total\n        if error_total and error_with_handling:\n            calc_coverage = (error_with_handling / error_total) * 100\n            if 0 <= calc_coverage <= 100:\n                error_coverage = calc_coverage\n        elif error_coverage is None and error_total and error_with_handling:\n            # If coverage not provided, calculate it\n            error_coverage = (error_with_handling / error_total) * 100\n\n        worst_error_modules = error_details.get('worst_modules') or error_metrics.get('worst_modules') or []\n        if worst_error_modules is None or not isinstance(worst_error_modules, (list, tuple)):\n            worst_error_modules = []\n\n        coverage_summary = self._load_coverage_summary() or {}\n        \n        # Load dev tools coverage if not already loaded\n        if not hasattr(self, 'dev_tools_coverage_results') or not self.dev_tools_coverage_results:\n            self._load_dev_tools_coverage()\n\n        # Load doc sync and legacy data using unified loader\n        doc_sync_data = self._load_tool_data('analyze_documentation_sync', 'docs')\n        doc_sync_summary = self.docs_sync_summary or doc_sync_data or {}\n        if not isinstance(doc_sync_summary, dict):\n            doc_sync_summary = {}\n\n        legacy_data = self._load_tool_data('analyze_legacy_references', 'legacy')\n        legacy_summary = self.legacy_cleanup_summary or legacy_data or {}\n\n        lines.append(\"## Snapshot\")\n\n        # Try to load cached audit results if not available in memory\n        total_functions = metrics.get('total_functions', 'Unknown') if metrics else 'Unknown'\n        moderate = metrics.get('moderate', 'Unknown') if metrics else 'Unknown'\n        high = metrics.get('high', 'Unknown') if metrics else 'Unknown'\n        critical = metrics.get('critical', 'Unknown') if metrics else 'Unknown'\n        \n        # If metrics are Unknown, try loading from cache\n        if total_functions == 'Unknown' or moderate == 'Unknown':\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    \n                    # Try analyze_functions first\n                    if 'results' in cached_data and 'analyze_functions' in cached_data['results']:\n                        func_data = cached_data['results']['analyze_functions']\n                        if 'data' in func_data:\n                            cached_metrics = func_data['data']\n                            if total_functions == 'Unknown':\n                                total_functions = cached_metrics.get('total_functions', 'Unknown')\n                            if moderate == 'Unknown':\n                                moderate = cached_metrics.get('moderate_complexity', 'Unknown')\n                            if high == 'Unknown':\n                                high = cached_metrics.get('high_complexity', 'Unknown')\n                            if critical == 'Unknown':\n                                critical = cached_metrics.get('critical_complexity', 'Unknown')\n                    \n                    # Fallback to decision_support if still Unknown\n                    if (total_functions == 'Unknown' or moderate == 'Unknown') and 'results' in cached_data:\n                        # Check if decision_support was run and metrics extracted\n                        if 'decision_support' in cached_data['results']:\n                            ds_data = cached_data['results']['decision_support']\n                            if 'data' in ds_data and 'decision_support_metrics' in ds_data['data']:\n                                ds_metrics = ds_data['data']['decision_support_metrics']\n                                if total_functions == 'Unknown':\n                                    total_functions = ds_metrics.get('total_functions', 'Unknown')\n                                if moderate == 'Unknown':\n                                    moderate = ds_metrics.get('moderate_complexity', 'Unknown')\n                                if high == 'Unknown':\n                                    high = ds_metrics.get('high_complexity', 'Unknown')\n                                if critical == 'Unknown':\n                                    critical = ds_metrics.get('critical_complexity', 'Unknown')\n            except Exception as e:\n                logger.debug(f\"Failed to load metrics from cache: {e}\")\n                pass\n        \n        if total_functions == 'Unknown':\n            lines.append(\"- **Total Functions**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n        else:\n            lines.append(f\"- **Total Functions**: {total_functions} (Moderate: {moderate}, High: {high}, Critical: {critical})\")\n\n        # Use analyze_functions for docstring coverage (consistent source)\n        # This measures actual docstrings in code, not registry documentation\n        doc_coverage = metrics.get('doc_coverage', 'Unknown')\n        functions_without_docstrings = None\n        missing_docs = None\n        missing_files = []\n        \n        # If doc_coverage is Unknown, try to calculate from analyze_functions data\n        if doc_coverage == 'Unknown' or doc_coverage is None:\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    # Use analyze_functions data for docstring coverage\n                    if 'results' in cached_data and 'analyze_functions' in cached_data['results']:\n                        func_data = cached_data['results']['analyze_functions']\n                        if 'data' in func_data:\n                            func_metrics = func_data['data']\n                            func_total = func_metrics.get('total_functions')\n                            func_undocumented = func_metrics.get('undocumented', 0)\n                            if func_total is not None and func_total > 0:\n                                func_documented = func_total - func_undocumented\n                                coverage_pct = (func_documented / func_total) * 100\n                                doc_coverage = f\"{coverage_pct:.2f}%\"\n                                functions_without_docstrings = func_undocumented\n            except Exception as e:\n                logger.debug(f\"Failed to load doc_coverage from cache in status: {e}\")\n                pass\n        \n        # If still unknown, try to get from results cache\n        if (doc_coverage == 'Unknown' or doc_coverage is None) and total_functions is not None:\n            func_cache = self.results_cache.get('analyze_functions', {})\n            if isinstance(func_cache, dict):\n                func_undocumented = func_cache.get('undocumented', 0)\n                if isinstance(func_undocumented, (int, float)) and total_functions > 0:\n                    func_documented = total_functions - func_undocumented\n                    coverage_pct = (func_documented / total_functions) * 100\n                    doc_coverage = f\"{coverage_pct:.2f}%\"\n                    functions_without_docstrings = int(func_undocumented)\n        \n        # Also check registry for missing items (separate metric - registry completeness)\n        try:\n            import json\n            results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n            if results_file.exists():\n                with open(results_file, 'r', encoding='utf-8') as f:\n                    cached_data = json.load(f)\n                if 'results' in cached_data and 'analyze_function_registry' in cached_data['results']:\n                    func_reg_data = cached_data['results']['analyze_function_registry']\n                    if 'data' in func_reg_data:\n                        cached_metrics = func_reg_data['data']\n                        missing_docs = cached_metrics.get('missing') or cached_metrics.get('missing_docs') or cached_metrics.get('missing_items')\n                        missing_files = cached_metrics.get('missing_files', [])\n        except Exception as e:\n            logger.debug(f\"Failed to load registry missing data: {e}\")\n            pass\n        \n        doc_line = f\"- **Docstring Coverage**: {percent_text(doc_coverage, 2)}\"\n        \n        # Show registry gaps count (items missing from registry) in the docstring coverage line\n        missing_count = 0\n        if missing_docs:\n            # Extract count if missing_docs is a dictionary, otherwise use it as-is\n            if isinstance(missing_docs, dict):\n                missing_count = missing_docs.get('count', 0)\n            else:\n                missing_count = to_int(missing_docs) or 0\n        \n        # Always show registry gaps count (even when 0)\n        doc_line += f\" ({missing_count} items missing from registry)\"\n\n        lines.append(doc_line)\n\n        if missing_files:\n\n            lines.append(f\"- **Missing Documentation Files**: {self._format_list_for_display(missing_files, limit=4)}\")\n\n        # Try to load error handling coverage from cached data\n        # NOTE: missing_error_handlers is already calculated above from standard format (lines 5416-5424)\n        # Preserve the value calculated earlier - don't reset it\n        error_coverage_from_cache = 'Unknown'\n        error_total = None\n        error_with_handling = None\n        if not error_metrics or error_coverage == 'Unknown':\n            try:\n                import json\n                results_file = Path(\"development_tools/reports/analysis_detailed_results.json\")\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'analyze_error_handling' in cached_data['results']:\n                        error_data = cached_data['results']['analyze_error_handling']\n                        if 'data' in error_data:\n                            cached_metrics = error_data['data']\n                            # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n                            error_coverage_from_cache = cached_metrics.get('analyze_error_handling') or cached_metrics.get('error_handling_coverage', 'Unknown')\n                            # Only set missing_error_handlers from cache if not already set from standard format above\n                            if missing_error_handlers is None or missing_error_handlers == 0:\n                                missing_error_handlers = to_int(cached_metrics.get('functions_missing_error_handling'))\n                            error_total = cached_metrics.get('total_functions')\n                            error_with_handling = cached_metrics.get('functions_with_error_handling')\n                            if error_coverage_from_cache != 'Unknown':\n                                error_coverage = error_coverage_from_cache\n            except Exception:\n                pass\n        \n        # Use the actual count from error analysis, not a recalculation\n        # Only overwrite if we don't already have a value from the standard format access above\n        if missing_error_handlers is None or missing_error_handlers == 0:\n            # Fallback to old format access\n            if error_metrics:\n                error_details = error_metrics.get('details', {})\n                missing_error_handlers = to_int(error_details.get('functions_missing_error_handling')) or to_int(error_metrics.get('functions_missing_error_handling')) or 0\n        \n        # Only recalculate coverage if totals differ, but keep the actual missing count\n        canonical_total = metrics.get('total_functions')\n        if error_coverage is not None and canonical_total and error_total and error_with_handling:\n            if error_total != canonical_total:\n                recalc_coverage = (error_with_handling / canonical_total) * 100\n                if 0 <= recalc_coverage <= 100:\n                    error_coverage = recalc_coverage\n\n        lines.append(\n\n            f\"- **Error Handling Coverage**: {percent_text(error_coverage, 1)}\"\n\n            + (f\" ({missing_error_handlers} functions without handlers)\" if missing_error_handlers is not None else \"\")\n\n        )\n\n        # Try to load doc sync data from cached data\n        if not doc_sync_summary:\n            try:\n                import json\n                results_file = Path(\"development_tools/reports/analysis_detailed_results.json\")\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'analyze_documentation' in cached_data['results']:\n                        doc_sync_data = cached_data['results']['analyze_documentation']\n                        if 'data' in doc_sync_data:\n                            cached_metrics = doc_sync_data['data']\n                            # Create a doc_sync_summary from the cached data\n                            doc_sync_summary = {\n                                'status': 'GOOD' if not cached_metrics.get('artifacts') else 'NEEDS REVIEW',\n                                'total_issues': len(cached_metrics.get('artifacts', []))\n                            }\n            except Exception:\n                pass\n\n        if doc_sync_summary:\n            # Helper to extract doc sync field (handles both standard and old format)\n            def get_doc_sync_field(data, field_name, default=None):\n                if not data or not isinstance(data, dict):\n                    return default\n                # Check standard format first\n                if 'summary' in data and isinstance(data.get('summary'), dict):\n                    # Standard format - check details for specific fields, summary for status\n                    if field_name == 'status':\n                        return data['summary'].get('status', default)\n                    else:\n                        return data.get('details', {}).get(field_name, default)\n                else:\n                    # Old format - direct access\n                    return data.get(field_name, default)\n            \n            sync_status = get_doc_sync_field(doc_sync_summary, 'status', 'Unknown')\n            total_issues = get_doc_sync_field(doc_sync_summary, 'total_issues')\n            # Also check path_drift_issues as total_issues might not be set\n            if total_issues is None or total_issues == 0:\n                path_drift_issues = get_doc_sync_field(doc_sync_summary, 'path_drift_issues', 0)\n                paired_doc_issues = get_doc_sync_field(doc_sync_summary, 'paired_doc_issues', 0)\n                ascii_issues = get_doc_sync_field(doc_sync_summary, 'ascii_issues', 0)\n                total_issues = (path_drift_issues or 0) + (paired_doc_issues or 0) + (ascii_issues or 0)\n\n            sync_line = f\"- **Doc Sync**: {sync_status}\"\n\n            if total_issues is not None and total_issues > 0:\n\n                sync_line += f\" ({total_issues} tracked issues)\"\n\n            lines.append(sync_line)\n\n        else:\n\n            lines.append(\"- **Doc Sync**: Not collected in this run (pending doc-sync refresh)\")\n\n        # Add test coverage to snapshot\n        if coverage_summary and isinstance(coverage_summary, dict):\n            overall = coverage_summary.get('overall') or {}\n            if overall.get('coverage') is not None:\n                lines.append(\n                    f\"- **Test Coverage**: {percent_text(overall.get('coverage'), 1)} \"\n                    f\"({overall.get('covered')} of {overall.get('statements')} statements)\"\n                )\n\n        lines.append(\"\")\n\n        lines.append(\"## Documentation Signals\")\n\n        # Helper to extract doc sync field (handles both standard and old format)\n        def get_doc_sync_field(data, field_name, default=None):\n            if not data or not isinstance(data, dict):\n                return default\n            # Check standard format first\n            if 'summary' in data and isinstance(data.get('summary'), dict):\n                # Standard format - check details for specific fields, summary for status\n                if field_name == 'status':\n                    return data['summary'].get('status', default)\n                else:\n                    return data.get('details', {}).get(field_name, default)\n            else:\n                # Old format - direct access\n                return data.get(field_name, default)\n        \n        # Use aggregated doc sync summary from current run first, then fall back to cache\n        doc_sync_summary_for_signals = None\n        if self.docs_sync_summary and isinstance(self.docs_sync_summary, dict):\n            # Use the aggregated summary from _run_doc_sync_check() - use helper to handle both formats\n            doc_sync_summary_for_signals = {\n                'status': get_doc_sync_field(self.docs_sync_summary, 'status', 'UNKNOWN'),\n                'path_drift_issues': get_doc_sync_field(self.docs_sync_summary, 'path_drift_issues', 0),\n                'paired_doc_issues': get_doc_sync_field(self.docs_sync_summary, 'paired_doc_issues', 0),\n                'ascii_issues': get_doc_sync_field(self.docs_sync_summary, 'ascii_issues', 0),\n                'heading_numbering_issues': get_doc_sync_field(self.docs_sync_summary, 'heading_numbering_issues', 0),\n                'missing_address_issues': get_doc_sync_field(self.docs_sync_summary, 'missing_address_issues', 0),\n                'unconverted_link_issues': get_doc_sync_field(self.docs_sync_summary, 'unconverted_link_issues', 0),\n                'path_drift_files': get_doc_sync_field(self.docs_sync_summary, 'path_drift_files', [])\n            }\n        \n        # Fall back to cache if not available in memory\n        if not doc_sync_summary_for_signals:\n            # Load doc sync data using unified loader (returns standard format)\n            doc_sync_result = self._load_tool_data('analyze_documentation_sync', 'docs')\n            if doc_sync_result:\n                doc_sync_summary_for_signals = {\n                    'status': get_doc_sync_field(doc_sync_result, 'status', 'UNKNOWN'),\n                    'path_drift_issues': get_doc_sync_field(doc_sync_result, 'path_drift_issues', 0),\n                    'paired_doc_issues': get_doc_sync_field(doc_sync_result, 'paired_doc_issues', 0),\n                    'ascii_issues': get_doc_sync_field(doc_sync_result, 'ascii_issues', 0),\n                    'heading_numbering_issues': get_doc_sync_field(doc_sync_result, 'heading_numbering_issues', 0),\n                    'missing_address_issues': get_doc_sync_field(doc_sync_result, 'missing_address_issues', 0),\n                    'unconverted_link_issues': get_doc_sync_field(doc_sync_result, 'unconverted_link_issues', 0),\n                    'path_drift_files': get_doc_sync_field(doc_sync_result, 'path_drift_files', [])\n                }\n\n        if doc_sync_summary_for_signals:\n            \n            path_drift = get_doc_sync_field(doc_sync_summary_for_signals, 'path_drift_issues', 0)\n            if path_drift is None:\n                path_drift = 0\n\n            paired = get_doc_sync_field(doc_sync_summary_for_signals, 'paired_doc_issues', 0)\n            if paired is None:\n                paired = 0\n\n            ascii_issues = get_doc_sync_field(doc_sync_summary_for_signals, 'ascii_issues', 0)\n            if ascii_issues is None:\n                ascii_issues = 0\n\n            # Check for path validation issues first (separate from path_drift - checks if referenced paths exist)\n            # Path validation is more critical than path drift\n            path_val_issues = None\n            path_val_status = None\n            if hasattr(self, 'path_validation_result') and self.path_validation_result:\n                if isinstance(self.path_validation_result, dict):\n                    path_val_status = self.path_validation_result.get('status')\n                    path_val_issues = self.path_validation_result.get('issues_found', 0)\n                    # Also check if issues_found is in the result but status might be different\n                    if path_val_issues is None or path_val_issues == 0:\n                        # Try to get issues from details if available\n                        details = self.path_validation_result.get('details', {})\n                        if details and isinstance(details, dict):\n                            # Count total issues from details\n                            total_issues = sum(len(issues) if isinstance(issues, (list, dict)) else 1 for issues in details.values())\n                            if total_issues > 0:\n                                path_val_issues = total_issues\n                                if path_val_status != 'ok':\n                                    path_val_status = 'fail'\n            \n            # Then check path drift (documentation path changes)\n            # Path drift checks for documentation path inconsistencies\n            # Path validation checks if referenced paths actually exist\n            # Use helper to extract doc sync field (handles both standard and old format)\n            def get_doc_sync_field(data, field_name, default=None):\n                if not data or not isinstance(data, dict):\n                    return default\n                # Check standard format first\n                if 'summary' in data and isinstance(data.get('summary'), dict):\n                    # Standard format - check details for specific fields, summary for status\n                    if field_name == 'status':\n                        return data['summary'].get('status', default)\n                    else:\n                        return data.get('details', {}).get(field_name, default)\n                else:\n                    # Old format - direct access\n                    return data.get(field_name, default)\n            \n            # Get path_drift using helper to handle standard format\n            path_drift = get_doc_sync_field(doc_sync_summary_for_signals, 'path_drift_issues', 0)\n            if path_drift is None:\n                path_drift = 0\n            # They can have different issues, but if path validation found issues, we show those under Path Drift\n            # to avoid duplication\n            if path_drift is not None:\n                if path_drift == 0:\n                    # Path drift tool found 0 issues\n                    if path_val_issues is None:\n                        # Path validation didn't run, so trust path drift\n                        severity = \"CLEAN\"\n                        lines.append(f\"- **Path Drift**: {severity} ({path_drift} issues)\")\n                    elif path_val_issues == 0:\n                        # Both path drift and path validation found 0 issues\n                        severity = \"CLEAN\"\n                        lines.append(f\"- **Path Drift**: {severity} ({path_drift} issues)\")\n                    else:\n                        # Path drift found 0, but path validation found issues - show path validation issues\n                        # Don't duplicate by showing both Path Validation and Path Drift\n                        severity = \"NEEDS ATTENTION\"\n                        lines.append(f\"- **Path Drift**: {severity} ({path_val_issues} referenced paths don't exist)\")\n                else:\n                    # Path drift found issues - show those\n                    severity = \"NEEDS ATTENTION\"\n                    lines.append(f\"- **Path Drift**: {severity} ({path_drift} issues)\")\n            elif path_val_issues is not None and path_val_issues > 0:\n                # Path drift didn't run, but path validation found issues\n                lines.append(f\"- **Path Drift**: NEEDS ATTENTION ({path_val_issues} referenced paths don't exist)\")\n            else:\n                # If neither path_drift nor path_validation ran, show unknown\n                lines.append(\"- **Path Drift**: Unknown (run `audit` to check)\")\n\n            # Drift Hotspots removed from AI_STATUS (detailed info in consolidated_report.txt)\n\n            if paired is not None:\n                status_label = \"SYNCHRONIZED\" if paired == 0 else \"NEEDS ATTENTION\"\n                lines.append(f\"- **Paired Docs**: {status_label} ({paired} issues)\")\n                # Add details about paired doc issues if available\n                if paired > 0 and doc_sync_summary_for_signals:\n                    paired_docs_data = doc_sync_summary_for_signals.get('paired_docs', {})\n                    if isinstance(paired_docs_data, dict):\n                        content_sync_issues = paired_docs_data.get('content_sync', [])\n                        if content_sync_issues:\n                            # Show first 2-3 issues\n                            for issue in content_sync_issues[:3]:\n                                lines.append(f\"  - {issue}\")\n                            if len(content_sync_issues) > 3:\n                                lines.append(f\"  - ...and {len(content_sync_issues) - 3} more issue(s)\")\n        \n        # Add ASCII Compliance to Documentation Signals\n        # First check doc_sync_summary (aggregated), then check direct tool result\n        if ascii_issues is not None and ascii_issues > 0:\n            lines.append(f\"- **ASCII Compliance**: {ascii_issues} files contain non-ASCII characters\")\n        elif ascii_data and isinstance(ascii_data, dict):\n            # Use standard format\n            summary = ascii_data.get('summary', {})\n            ascii_total = summary.get('total_issues', 0)\n            ascii_file_count = summary.get('files_affected', 0)\n            if ascii_total > 0 or ascii_file_count > 0:\n                lines.append(f\"- **ASCII Compliance**: {ascii_total} issues in {ascii_file_count} files\")\n            else:\n                lines.append(\"- **ASCII Compliance**: CLEAN (all files are ASCII-compliant)\")\n        \n        # Add Heading Numbering to Documentation Signals\n        if heading_data and isinstance(heading_data, dict):\n            # Use standard format\n            summary = heading_data.get('summary', {})\n            heading_total = summary.get('total_issues', 0)\n            heading_file_count = summary.get('files_affected', 0)\n            if heading_total > 0 or heading_file_count > 0:\n                lines.append(f\"- **Heading Numbering**: {heading_total} issues in {heading_file_count} files\")\n            else:\n                lines.append(\"- **Heading Numbering**: CLEAN (all headings properly numbered)\")\n        \n        # Add Missing Addresses to Documentation Signals\n        if missing_addresses_data and isinstance(missing_addresses_data, dict):\n            # Use standard format\n            summary = missing_addresses_data.get('summary', {})\n            missing_total = summary.get('total_issues', 0)\n            missing_file_count = summary.get('files_affected', 0)\n            if missing_total > 0 or missing_file_count > 0:\n                lines.append(f\"- **Missing Addresses**: {missing_total} issues in {missing_file_count} files\")\n            else:\n                lines.append(\"- **Missing Addresses**: CLEAN (all documentation addresses present)\")\n        \n        # Add Unconverted Links to Documentation Signals\n        if unconverted_links_data and isinstance(unconverted_links_data, dict):\n            # Use standard format\n            summary = unconverted_links_data.get('summary', {})\n            links_total = summary.get('total_issues', 0)\n            links_file_count = summary.get('files_affected', 0)\n            if links_total > 0 or links_file_count > 0:\n                lines.append(f\"- **Unconverted Links**: {links_total} issues in {links_file_count} files\")\n            else:\n                lines.append(\"- **Unconverted Links**: CLEAN (all links properly converted)\")\n        \n        # Add Dependency Docs to Documentation Signals\n        dependency_summary = self.module_dependency_summary or self.results_cache.get('analyze_module_dependencies')\n        if dependency_summary:\n            missing_deps = dependency_summary.get('missing_dependencies')\n            if missing_deps:\n                lines.append(f\"- **Dependency Docs**: {missing_deps} undocumented references detected\")\n                # Top files removed from AI_STATUS (detailed info in consolidated_report.txt)\n            else:\n                lines.append(\"- **Dependency Docs**: CLEAN (no undocumented dependencies)\")\n        \n        if not doc_sync_summary_for_signals:\n            lines.append(\"- Run `python development_tools/run_development_tools.py doc-sync` for drift details\")\n        \n        # Add config validation status\n        config_validation_summary = self._load_config_validation_summary()\n        if config_validation_summary:\n            config_valid = config_validation_summary.get('config_valid', False)\n            config_complete = config_validation_summary.get('config_complete', False)\n            total_recommendations = config_validation_summary.get('total_recommendations', 0)\n            if config_valid and config_complete and total_recommendations == 0:\n                lines.append(\"- **Config Validation**: CLEAN (no issues)\")\n            elif total_recommendations > 0:\n                lines.append(f\"- **Config Validation**: {total_recommendations} recommendations\")\n            else:\n                lines.append(\"- **Config Validation**: Needs attention\")\n        \n        # Add TODO sync status\n        todo_sync_result = getattr(self, 'todo_sync_result', None)\n        if todo_sync_result and isinstance(todo_sync_result, dict):\n            completed_entries = todo_sync_result.get('completed_entries', 0)\n            if completed_entries > 0:\n                lines.append(f\"- **TODO Sync**: {completed_entries} completed entries need review\")\n            else:\n                lines.append(\"- **TODO Sync**: CLEAN (no completed entries)\")\n        \n        # Add overlap analysis summary (always show, even if no overlaps found)\n        lines.append(\"\")\n        lines.append(\"## Documentation Overlap\")\n        overlap_count = len(section_overlaps) if section_overlaps else 0\n        consolidation_count = len(consolidation_recs) if consolidation_recs else 0\n        \n        if overlap_count > 0 or consolidation_count > 0:\n            if section_overlaps and overlap_count > 0:\n                lines.append(f\"- **Section Overlaps**: {overlap_count} sections duplicated across files\")\n                # Show first few overlaps\n                top_overlaps = sorted(section_overlaps.items(), key=lambda x: len(x[1]), reverse=True)[:3]\n                for section, files in top_overlaps:\n                    lines.append(f\"  - `{section}` appears in: {', '.join(files[:3])}{'...' if len(files) > 3 else ''}\")\n            # Consolidation opportunities moved to AI_PRIORITIES (not shown in AI_STATUS)\n        else:\n            if overlap_analysis_ran:\n                lines.append(\"- **Status**: No overlaps detected (analysis performed)\")\n                lines.append(\"  - Overlap analysis ran but found no section overlaps or consolidation opportunities\")\n            else:\n                lines.append(\"- **Status**: Overlap analysis not run (use `audit --full` or `--overlap` flag)\")\n                lines.append(\"  - Standard audits skip overlap analysis by default; run `audit --full` or use `--overlap` flag to include it\")\n\n        doc_artifacts = analyze_docs_data.get('artifacts') if isinstance(analyze_docs_data, dict) else None\n\n        if doc_artifacts:\n\n            primary_artifact = doc_artifacts[0]\n\n            file_name = primary_artifact.get('file')\n\n            line_no = primary_artifact.get('line')\n\n            pattern = primary_artifact.get('pattern')\n\n            lines.append(\n\n                f\"- **Content Cleanup**: {file_name} line {line_no} flagged for {pattern.replace('_', ' ')}\"\n\n            )\n\n            if len(doc_artifacts) > 1:\n\n                lines.append(f\"- Additional documentation artifacts: {len(doc_artifacts) - 1} more findings\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Error Handling\")\n\n        if error_metrics:\n\n            if missing_error_handlers is not None and missing_error_handlers > 0:\n\n                lines.append(f\"- **Missing Error Handling**: {missing_error_handlers} functions lack protections\")\n\n            decorated = error_metrics.get('functions_with_decorators')\n\n            if decorated is not None:\n\n                lines.append(f\"- **@handle_errors Usage**: {decorated} functions already use the decorator\")\n\n            # Phase 1: Candidates for decorator replacement\n            # Use helper to access from details or top level\n            error_details = error_metrics.get('details', {})\n            phase1_total = error_details.get('phase1_total', error_metrics.get('phase1_total', 0))\n\n            if phase1_total > 0:\n                phase1_by_priority = error_details.get('phase1_by_priority', error_metrics.get('phase1_by_priority', {})) or {}\n                if not isinstance(phase1_by_priority, dict):\n                    phase1_by_priority = {}\n\n                priority_counts = []\n\n                if phase1_by_priority.get('high', 0) > 0:\n\n                    priority_counts.append(f\"{phase1_by_priority['high']} high\")\n\n                if phase1_by_priority.get('medium', 0) > 0:\n\n                    priority_counts.append(f\"{phase1_by_priority['medium']} medium\")\n\n                if phase1_by_priority.get('low', 0) > 0:\n\n                    priority_counts.append(f\"{phase1_by_priority['low']} low\")\n\n                priority_text = ', '.join(priority_counts) if priority_counts else '0'\n\n                lines.append(f\"- **Phase 1 Candidates**: {phase1_total} functions need decorator replacement ({priority_text} priority)\")\n\n            # Phase 2: Generic exception raises\n            # Use helper to access from details or top level\n            error_details = error_metrics.get('details', {})\n            phase2_total = error_details.get('phase2_total', error_metrics.get('phase2_total', 0))\n\n            if phase2_total > 0:\n                phase2_by_type = error_details.get('phase2_by_type', error_metrics.get('phase2_by_type', {})) or {}\n                if not isinstance(phase2_by_type, dict):\n                    phase2_by_type = {}\n\n                type_counts = [f\"{count} {exc_type}\" for exc_type, count in sorted(phase2_by_type.items(), key=lambda x: x[1], reverse=True)[:3]]\n\n                type_text = ', '.join(type_counts) if type_counts else '0'\n\n                if len(phase2_by_type) > 3:\n\n                    type_text += f\", ... +{len(phase2_by_type) - 3} more\"\n\n                lines.append(f\"- **Phase 2 Exceptions**: {phase2_total} generic exception raises need categorization ({type_text})\")\n\n            if worst_error_modules:\n\n                module_descriptions = []\n\n                # Filter out 100% modules (missing 0) - they don't need attention\n                # Convert coverage to float for comparison (handles both string and numeric values)\n                modules_needing_attention = []\n                if worst_error_modules and isinstance(worst_error_modules, (list, tuple)):\n                    for m in worst_error_modules[:5]:\n                        missing = m.get('missing', 0)\n                        coverage_val = m.get('coverage', 100)\n                        if isinstance(coverage_val, str):\n                            coverage_val = to_float(coverage_val) or 100\n                        elif not isinstance(coverage_val, (int, float)):\n                            coverage_val = 100\n                        if missing > 0 and coverage_val < 100:\n                            modules_needing_attention.append(m)\n                \n                for module in modules_needing_attention[:3]:\n                    module_name = module.get('module', 'Unknown')\n                    coverage_value = module.get('coverage')\n                    coverage_text = percent_text(coverage_value, 1)\n                    missing = module.get('missing')\n                    total = module.get('total')\n\n                    detail = f\"{module_name} ({coverage_text}\"\n\n                    if missing is not None and total is not None:\n                        detail += f\", missing {missing}/{total}\"\n\n                    detail += \")\"\n\n                    module_descriptions.append(detail)\n                \n                # Modules to Prioritize removed from AI_STATUS (detailed info in consolidated_report.txt)\n\n        else:\n            # Try to load cached error handling data\n            try:\n                import json\n                results_file = Path(\"development_tools/reports/analysis_detailed_results.json\")\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'analyze_error_handling' in cached_data['results']:\n                        error_data = cached_data['results']['analyze_error_handling']\n                        if 'data' in error_data:\n                            error_metrics = error_data['data']\n                        else:\n                            # Try reading from the file if 'data' key is missing\n                            # LEGACY COMPATIBILITY: Reading from old file location for backward compatibility\n                            # New standardized storage location: error_handling/jsons/analyze_error_handling_results.json\n                            try:\n                                # Try new location first, then fallback to old location\n                                json_file = self.project_root / 'development_tools' / 'error_handling' / 'jsons' / 'error_handling_details.json'\n                                if not json_file.exists():\n                                    # Fallback to old location\n                                    json_file = self.project_root / 'development_tools' / 'error_handling' / 'error_handling_details.json'\n                                if json_file.exists():\n                                    with open(json_file, 'r', encoding='utf-8') as f:\n                                        file_data = json.load(f)\n                                    # Handle new structure with metadata wrapper\n                                    if 'error_handling_results' in file_data:\n                                        error_metrics = file_data['error_handling_results']\n                                    else:\n                                        # Fallback to old structure (direct results)\n                                        error_metrics = file_data\n                                else:\n                                    # Try new standardized storage location\n                                    from .output_storage import load_tool_result\n                                    loaded_data = load_tool_result('analyze_error_handling', 'error_handling', project_root=self.project_root)\n                                    if loaded_data:\n                                        error_metrics = loaded_data\n                                    else:\n                                        error_metrics = None\n                            except (OSError, json.JSONDecodeError):\n                                error_metrics = None\n                        \n                        if error_metrics:\n                            # Access error metrics - check details first (normalized), then top level (backward compat)\n                            error_details = error_metrics.get('details', {})\n                            def get_error_field(field_name, default=None):\n                                return error_details.get(field_name, error_metrics.get(field_name, default))\n                            \n                            # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n                            coverage = get_error_field('analyze_error_handling') or get_error_field('error_handling_coverage', 'Unknown')\n                            if coverage != 'Unknown':\n                                lines.append(f\"- **Error Handling Coverage**: {coverage:.1f}%\")\n                                lines.append(f\"- **Functions with Error Handling**: {get_error_field('functions_with_error_handling', 'Unknown')}\")\n                                lines.append(f\"- **Functions Missing Error Handling**: {get_error_field('functions_missing_error_handling', 'Unknown')}\")\n                                \n                                # Add Phase 1 and Phase 2 if available\n                                phase1_total = get_error_field('phase1_total', 0)\n                                if phase1_total > 0:\n                                    phase1_by_priority = get_error_field('phase1_by_priority', {}) or {}\n                                    if not isinstance(phase1_by_priority, dict):\n                                        phase1_by_priority = {}\n                                    priority_counts = []\n                                    if phase1_by_priority.get('high', 0) > 0:\n                                        priority_counts.append(f\"{phase1_by_priority['high']} high\")\n                                    if phase1_by_priority.get('medium', 0) > 0:\n                                        priority_counts.append(f\"{phase1_by_priority['medium']} medium\")\n                                    if phase1_by_priority.get('low', 0) > 0:\n                                        priority_counts.append(f\"{phase1_by_priority['low']} low\")\n                                    priority_text = ', '.join(priority_counts) if priority_counts else '0'\n                                    lines.append(f\"- **Phase 1 Candidates**: {phase1_total} functions need decorator replacement ({priority_text} priority)\")\n                                \n                                phase2_total = get_error_field('phase2_total', 0)\n                                if phase2_total > 0:\n                                    phase2_by_type = get_error_field('phase2_by_type', {}) or {}\n                                    if not isinstance(phase2_by_type, dict):\n                                        phase2_by_type = {}\n                                    type_counts = [f\"{count} {exc_type}\" for exc_type, count in sorted(phase2_by_type.items(), key=lambda x: x[1], reverse=True)[:3]]\n                                    type_text = ', '.join(type_counts) if type_counts else '0'\n                                    if len(phase2_by_type) > 3:\n                                        type_text += f\", ... +{len(phase2_by_type) - 3} more\"\n                                    lines.append(f\"- **Phase 2 Exceptions**: {phase2_total} generic exception raises need categorization ({type_text})\")\n                            else:\n                                lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n                        else:\n                            lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n                    else:\n                        lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n                else:\n                    lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n            except Exception:\n                lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Test Coverage\")\n\n        dev_tools_insights = self._get_dev_tools_coverage_insights()\n\n        if coverage_summary and isinstance(coverage_summary, dict):\n\n            overall = coverage_summary.get('overall') or {}\n\n            lines.append(\n\n                f\"- **Overall Coverage**: {percent_text(overall.get('coverage'), 1)} \"\n\n                f\"({overall.get('covered')} of {overall.get('statements')} statements)\"\n\n            )\n\n            generated = overall.get('generated')\n\n            if generated:\n                pass  # Generated timestamp available\n\n            # Domains with Lowest Coverage removed from AI_STATUS (detailed info in consolidated_report.txt)\n\n            # Modules with Lowest Coverage removed from AI_STATUS (detailed info in consolidated_report.txt)\n            \n            # Add report link for test coverage\n            coverage_report_path = self.project_root / \"development_docs\" / \"TEST_COVERAGE_REPORT.md\"\n            if coverage_report_path.exists():\n                lines.append(f\"    - **Detailed Report**: [TEST_COVERAGE_REPORT.md](development_docs/TEST_COVERAGE_REPORT.md)\")\n            \n            # Add development tools coverage BEFORE test markers (inside coverage_summary block)\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                dev_statements = dev_tools_insights.get('statements')\n                dev_covered = dev_tools_insights.get('covered')\n                summary_line = f\"- **Development Tools Coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_statements is not None and dev_covered is not None:\n                    summary_line += f\" ({dev_covered} of {dev_statements} statements)\"\n                lines.append(summary_line)\n                # Modules with Lowest Coverage removed from AI_STATUS (detailed info in consolidated_report.txt)\n\n        else:\n\n            lines.append(\"- Coverage data unavailable; run `audit --full` to regenerate metrics\")\n            # Add development tools coverage even if overall coverage is unavailable\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                dev_statements = dev_tools_insights.get('statements')\n                dev_covered = dev_tools_insights.get('covered')\n                summary_line = f\"- **Development Tools Coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_statements is not None and dev_covered is not None:\n                    summary_line += f\" ({dev_covered} of {dev_statements} statements)\"\n                lines.append(summary_line)\n                # Modules with Lowest Coverage removed from AI_STATUS (detailed info in consolidated_report.txt)\n        \n        # Add test markers status\n        test_markers_data = self._load_tool_data('analyze_test_markers', 'tests')\n        if test_markers_data and isinstance(test_markers_data, dict):\n            # Handle both standard format and old format\n            if 'summary' in test_markers_data:\n                summary = test_markers_data.get('summary', {})\n                missing_count = summary.get('total_issues', 0)\n                details = test_markers_data.get('details', {})\n                missing_list = details.get('missing', [])\n            else:\n                # Old format\n                missing_count = test_markers_data.get('missing_count', 0)\n                missing_list = test_markers_data.get('missing', [])\n            \n            if missing_count > 0 or (missing_list and len(missing_list) > 0):\n                lines.append(\"## Test Markers\")\n                # Use len(missing_list) if missing_count is 0 but list has items\n                actual_count = missing_count if missing_count > 0 else len(missing_list) if missing_list else 0\n                lines.append(f\"- **Missing Category Markers**: {actual_count} tests missing pytest category markers\")\n                # Group by file\n                from collections import defaultdict\n                files_with_missing = defaultdict(list)\n                for item in missing_list:\n                    if isinstance(item, dict):\n                        file_path = item.get('file', '')\n                        test_name = item.get('name', '')\n                        if file_path:\n                            files_with_missing[file_path].append(test_name)\n                \n                # Top files removed from AI_STATUS (detailed info in consolidated_report.txt)\n            else:\n                lines.append(\"## Test Markers\")\n                lines.append(\"- **Status**: CLEAN (all tests have category markers)\")\n\n        lines.append(\"\")\n\n        # Add unused imports status\n        # Load unused imports data using unified loader (returns standard format)\n        unused_imports_data = self._load_tool_data('analyze_unused_imports', 'imports')\n        \n        if unused_imports_data and isinstance(unused_imports_data, dict):\n            summary = unused_imports_data.get('summary', {})\n            total_unused = summary.get('total_issues', 0)\n            files_with_issues = summary.get('files_affected', 0)\n            status = summary.get('status', 'GOOD')\n            \n            if total_unused > 0 or files_with_issues > 0:\n                lines.append(\"## Unused Imports\")\n                lines.append(f\"- **Total Unused**: {total_unused} imports across {files_with_issues} files\")\n                if status:\n                    lines.append(f\"- **Status**: {status}\")\n                # Add category breakdown from details\n                details = unused_imports_data.get('details', {})\n                by_category = details.get('by_category') or {}\n                if by_category:\n                    obvious = by_category.get('obvious_unused', 0)\n                    type_only = by_category.get('type_hints_only', 0)\n                    if obvious > 0:\n                        lines.append(f\"    - **Obvious Removals**: {obvious} imports\")\n                    if type_only > 0:\n                        lines.append(f\"    - **Type-Only Imports**: {type_only} imports\")\n            else:\n                lines.append(\"## Unused Imports\")\n                lines.append(\"- **Status**: CLEAN (no unused imports detected)\")\n            \n            # Add report link for unused imports\n            unused_imports_report_path = self.project_root / \"development_docs\" / \"UNUSED_IMPORTS_REPORT.md\"\n            if unused_imports_report_path.exists():\n                lines.append(f\"- **Detailed Report**: [UNUSED_IMPORTS_REPORT.md](development_docs/UNUSED_IMPORTS_REPORT.md)\")\n        else:\n            lines.append(\"## Unused Imports\")\n            lines.append(\"- **Status**: Data unavailable (run `audit --full` for latest scan)\")\n        \n        lines.append(\"\")\n\n        lines.append(\"## Legacy References\")\n\n        if legacy_summary:\n            # Check if legacy_summary is in standard format\n            if 'summary' in legacy_summary and isinstance(legacy_summary.get('summary'), dict):\n                # Standard format\n                summary = legacy_summary['summary']\n                legacy_issues = summary.get('files_affected', 0)\n                details = legacy_summary.get('details', {})\n                report_path = details.get('report_path') or legacy_summary.get('report_path')\n            else:\n                # Old format (backward compatibility during migration)\n                legacy_issues = legacy_summary.get('files_with_issues')\n                report_path = legacy_summary.get('report_path')\n\n            if legacy_issues == 0:\n                lines.append(\"- **Legacy References**: CLEAN (0 files flagged)\")\n            elif legacy_issues is not None:\n                lines.append(f\"- **Legacy References**: {legacy_issues} files still reference legacy patterns\")\n\n            if report_path:\n                # Convert to markdown link if it's a valid path\n                # Handle both relative and absolute paths\n                if isinstance(report_path, str):\n                    # If it's a relative path, make it absolute\n                    if not Path(report_path).is_absolute():\n                        report_path_obj = self.project_root / report_path\n                    else:\n                        report_path_obj = Path(report_path)\n                else:\n                    report_path_obj = report_path\n                \n                if report_path_obj.exists():\n                    rel_path = report_path_obj.relative_to(self.project_root)\n                    lines.append(f\"- **Detailed Report**: [LEGACY_REFERENCE_REPORT.md]({rel_path.as_posix()})\")\n                else:\n                    # If file doesn't exist, just show the path as-is\n                    lines.append(f\"- **Detailed Report**: {report_path}\")\n\n        else:\n            # Load legacy data using unified loader (returns standard format)\n            if not legacy_summary:\n                legacy_summary = legacy_data\n            if legacy_summary:\n                # Check if in standard format\n                if 'summary' in legacy_summary and isinstance(legacy_summary.get('summary'), dict):\n                    summary = legacy_summary['summary']\n                    legacy_issues = summary.get('files_affected', 0)\n                    details = legacy_summary.get('details', {})\n                    report_path = details.get('report_path') or 'development_docs/LEGACY_REFERENCE_REPORT.md'\n                else:\n                    # Old format fallback\n                    legacy_issues = legacy_summary.get('files_with_issues')\n                    report_path = legacy_summary.get('report_path') or 'development_docs/LEGACY_REFERENCE_REPORT.md'\n                \n                if legacy_issues is not None:\n                    if legacy_issues == 0:\n                        lines.append(\"- **Legacy References**: CLEAN (0 files flagged)\")\n                    else:\n                        lines.append(f\"- **Legacy References**: {legacy_issues} files still reference legacy patterns\")\n                    if report_path:\n                        report_path_obj = self._resolve_report_path(report_path)\n                        if report_path_obj.exists():\n                            rel_path = report_path_obj.relative_to(self.project_root)\n                            lines.append(f\"- **Detailed Report**: [LEGACY_REFERENCE_REPORT.md]({rel_path.as_posix()})\")\n                else:\n                    lines.append(\"- Legacy reference data unavailable (run `audit --full` for latest scan)\")\n            else:\n                lines.append(\"- Legacy reference data unavailable (run `audit --full` for latest scan)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Validation Status\")\n\n        # Load validation data using unified loader\n        validation_output = ''\n        if hasattr(self, 'validation_results') and self.validation_results:\n            validation_output = self.validation_results.get('output', '')\n        \n        if not validation_output:\n            validation_data = self._load_tool_data('analyze_ai_work', 'ai_work')\n            if validation_data:\n                validation_output = validation_data.get('output', '') or ''\n        \n        if validation_output:\n            # Parse text output for status\n            if 'POOR' in validation_output:\n                lines.append(\"- **AI Work Validation**: POOR - documentation or tests missing\")\n            elif 'GOOD' in validation_output:\n                lines.append(\"- **AI Work Validation**: GOOD - keep current standards\")\n            elif 'NEEDS ATTENTION' in validation_output or 'FAIR' in validation_output:\n                lines.append(\"- **AI Work Validation**: NEEDS ATTENTION - see consolidated report for details\")\n            else:\n                lines.append(\"- **AI Work Validation**: Status available (see consolidated report)\")\n        else:\n            lines.append(\"- Validation results unavailable (run `audit` for latest validation)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## System Signals\")\n\n        if hasattr(self, 'system_signals') and self.system_signals:\n\n            system_health = self.system_signals.get('system_health', {})\n\n            overall_status = system_health.get('overall_status')\n\n            if overall_status:\n\n                lines.append(f\"- **System Health**: {overall_status}\")\n\n            missing_core = [\n\n                name for name, state in (system_health.get('core_files') or {}).items()\n\n                if state != 'OK'\n\n            ]\n\n            if missing_core:\n\n                lines.append(f\"- **Core File Issues**: {self._format_list_for_display(missing_core, limit=3)}\")\n\n            recent_activity = self.system_signals.get('recent_activity', {})\n\n            last_audit = recent_activity.get('last_audit')\n\n            if last_audit:\n\n                lines.append(f\"- **Last Audit**: {last_audit}\")\n\n            recent_changes = recent_activity.get('recent_changes') or []\n\n            if recent_changes:\n\n                lines.append(f\"- **Recent Changes**: {self._format_list_for_display(recent_changes, limit=3)}\")\n\n            # Add critical alerts if any\n            critical_alerts = self.system_signals.get('critical_alerts', [])\n            if critical_alerts:\n                lines.append(f\"- **Critical Alerts**: {len(critical_alerts)} active alert(s)\")\n                # Show first few alerts\n                for alert in critical_alerts[:3]:\n                    alert_text = alert if isinstance(alert, str) else alert.get('message', str(alert))\n                    lines.append(f\"  - {alert_text}\")\n\n        else:\n            # Try to load cached system signals if not available in memory\n            signals_loaded = False\n            system_signals = None\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'system_signals' in cached_data['results']:\n                        signals_data = cached_data['results']['system_signals']\n                        # Handle both 'data' wrapper and direct signals\n                        if 'data' in signals_data:\n                            system_signals = signals_data['data']\n                        else:\n                            system_signals = signals_data\n                        \n                        if system_signals:\n                            signals_loaded = True\n                            system_health = system_signals.get('system_health', {})\n                            overall_status = system_health.get('overall_status')\n                            if overall_status:\n                                lines.append(f\"- **System Health**: {overall_status}\")\n                            \n                            missing_core = [\n                                name for name, state in (system_health.get('core_files') or {}).items()\n                                if state != 'OK'\n                            ]\n                            if missing_core:\n                                lines.append(f\"- **Core File Issues**: {self._format_list_for_display(missing_core, limit=3)}\")\n                            \n                            recent_activity = system_signals.get('recent_activity', {})\n                            last_audit = recent_activity.get('last_audit')\n                            if last_audit:\n                                lines.append(f\"- **Last Audit**: {last_audit}\")\n                            \n                            recent_changes = recent_activity.get('recent_changes') or []\n                            if recent_changes:\n                                lines.append(f\"- **Recent Changes**: {self._format_list_for_display(recent_changes, limit=3)}\")\n                            \n                            critical_alerts = system_signals.get('critical_alerts', [])\n                            if critical_alerts:\n                                lines.append(f\"- **Critical Alerts**: {len(critical_alerts)} active alerts\")\n                            \n                            signals_loaded = True\n            except Exception as e:\n                logger.debug(f\"Failed to load system signals from cache: {e}\")\n            \n            if not signals_loaded:\n                lines.append(\"- System signals data unavailable (run `system-signals` command)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Quick Commands\")\n\n        lines.append(\"- `python development_tools/run_development_tools.py status` - Refresh this snapshot\")\n\n        lines.append(\"- `python development_tools/run_development_tools.py audit --full` - Regenerate all metrics\")\n\n        lines.append(\"- `python development_tools/run_development_tools.py doc-sync` - Update documentation pairing data\")\n\n        lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def _generate_ai_priorities_document(self) -> str:\n        \"\"\"Generate AI-optimized priorities document with immediate next steps.\"\"\"\n        \n        # Check if this is a mid-audit write (not the legitimate end-of-audit write)\n        # Only warn if audit is in progress AND we're not in the legitimate end-of-audit context\n        instance_flag = hasattr(self, '_audit_in_progress') and self._audit_in_progress\n        audit_in_progress = instance_flag or _is_audit_in_progress(self.project_root)\n        is_legitimate_end_write = hasattr(self, 'current_audit_tier') and self.current_audit_tier is not None\n        \n        if audit_in_progress and not is_legitimate_end_write:\n            # This is a mid-audit write from a new instance (likely from tests or separate process)\n            if not instance_flag:\n                logger.warning(\"_generate_ai_priorities_document() called from NEW instance during audit! This should only happen at the end.\")\n            else:\n                logger.warning(\"_generate_ai_priorities_document() called during audit! This should only happen at the end.\")\n            import traceback\n            logger.debug(f\"Call stack:\\n{''.join(traceback.format_stack())}\")\n        \n        lines: List[str] = []\n        lines.append(\"# AI Priorities - Immediate Next Steps\")\n        lines.append(\"\")\n        lines.append(\"> **File**: `development_tools/AI_PRIORITIES.md`\")\n        lines.append(\"> **Generated**: This file is auto-generated. Do not edit manually.\")\n        lines.append(f\"> **Last Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        # Determine source command based on audit tier\n        if self.current_audit_tier == 1:\n            source_cmd = \"python development_tools/run_development_tools.py audit --quick\"\n            tier_name = \"Tier 1 (Quick Audit)\"\n        elif self.current_audit_tier == 3:\n            source_cmd = \"python development_tools/run_development_tools.py audit --full\"\n            tier_name = \"Tier 3 (Full Audit)\"\n        elif self.current_audit_tier == 2:\n            source_cmd = \"python development_tools/run_development_tools.py audit\"\n            tier_name = \"Tier 2 (Standard Audit)\"\n        else:\n            source_cmd = \"python development_tools/run_development_tools.py status\"\n            tier_name = \"Status Check (cached data)\"\n        lines.append(f\"> **Source**: `{source_cmd}`\")\n        if self.current_audit_tier:\n            lines.append(f\"> **Last Audit Tier**: {tier_name}\")\n        lines.append(\"> **Generated by**: run_development_tools.py - AI Development Tools Runner\")\n        lines.append(\"\")\n\n        def percent_text(value: Any, decimals: int = 1) -> str:\n            if value is None:\n                return \"Unknown\"\n            if isinstance(value, str):\n                trimmed = value.strip()\n                return trimmed if trimmed.endswith('%') else f\"{trimmed}%\"\n            return self._format_percentage(value, decimals)\n\n        def to_int(value: Any) -> Optional[int]:\n            if isinstance(value, int):\n                return value\n            if isinstance(value, float):\n                return int(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return int(float(stripped))\n                except ValueError:\n                    return None\n            if isinstance(value, dict):\n                count = value.get('count')\n                return to_int(count)\n            return None\n\n        def to_float(value: Any) -> Optional[float]:\n            if isinstance(value, (int, float)):\n                return float(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return float(stripped)\n                except ValueError:\n                    return None\n            return None\n\n        metrics = self._get_canonical_metrics()\n        # Load all tool data using unified loader\n        doc_metrics = self._load_tool_data('analyze_function_registry', 'functions')\n        error_metrics = self._load_tool_data('analyze_error_handling', 'error_handling')\n        function_metrics = self._load_tool_data('analyze_functions', 'functions')\n        doc_sync_data = self._load_tool_data('analyze_documentation_sync', 'docs')\n        doc_sync_summary = self.docs_sync_summary or doc_sync_data or {}\n        legacy_data = self._load_tool_data('analyze_legacy_references', 'legacy')\n        legacy_summary = self.legacy_cleanup_summary or legacy_data or {}\n        coverage_summary = self._load_coverage_summary()\n        \n        # Load dev tools coverage if not already loaded\n        if not hasattr(self, 'dev_tools_coverage_results') or not self.dev_tools_coverage_results:\n            self._load_dev_tools_coverage()\n        \n        # Load documentation analysis data using unified loader\n        analyze_data = self._load_tool_data('analyze_documentation', 'docs')\n        \n        # Load additional documentation analysis tools for recommendations\n        ascii_data = self._load_tool_data('analyze_ascii_compliance', 'docs')\n        heading_data = self._load_tool_data('analyze_heading_numbering', 'docs')\n        missing_addresses_data = self._load_tool_data('analyze_missing_addresses', 'docs')\n        unconverted_links_data = self._load_tool_data('analyze_unconverted_links', 'docs')\n        \n        # Extract overlap analysis data\n        section_overlaps = analyze_data.get('section_overlaps', {})\n        consolidation_recs = analyze_data.get('consolidation_recommendations', [])\n\n        # Access doc_metrics - check details first (normalized), then top level (backward compat)\n        doc_metrics_details = doc_metrics.get('details', {})\n        \n        # Get doc coverage from canonical metrics first (most accurate)\n        doc_coverage_value = metrics.get('doc_coverage')\n        if doc_coverage_value is None or doc_coverage_value == 'Unknown':\n            # Fallback to doc_metrics (check details first, then top level)\n            doc_coverage_value = doc_metrics_details.get('doc_coverage') or doc_metrics.get('doc_coverage')\n\n        missing_docs_count = to_int(doc_metrics_details.get('missing_docs') or doc_metrics_details.get('missing_items') or doc_metrics.get('missing_docs') or doc_metrics.get('missing_items'))\n        missing_doc_files = doc_metrics_details.get('missing_files') or doc_metrics.get('missing_files') or self._get_missing_doc_files(limit=5)\n        \n        # Calculate missing documentation count from total functions and documented functions\n        total_funcs = metrics.get('total_functions')\n        doc_totals = doc_metrics_details.get('totals') or doc_metrics.get('totals') or {}\n        documented_funcs = doc_totals.get('functions_documented') if isinstance(doc_totals, dict) else None\n        if total_funcs and documented_funcs is not None:\n            missing_docs_calculated = total_funcs - documented_funcs\n            if missing_docs_count is None or missing_docs_count == 0:\n                missing_docs_count = missing_docs_calculated\n\n        # Access error metrics - check details first (normalized), then top level (backward compat)\n        error_details = error_metrics.get('details', {})\n        def get_error_field(field_name, default=None):\n            return error_details.get(field_name, error_metrics.get(field_name, default))\n        \n        # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n        error_coverage = get_error_field('analyze_error_handling') or get_error_field('error_handling_coverage')\n        \n        # Recalculate error handling coverage using canonical function count for consistency\n        error_total = get_error_field('total_functions')\n        error_with_handling = get_error_field('functions_with_error_handling')\n        canonical_total = metrics.get('total_functions')\n        \n        # Use the actual count from error analysis, not a recalculation\n        # The error analysis tool knows which functions actually need error handling\n        # Recalculating based on different totals can give incorrect results\n        missing_error_handlers = to_int(get_error_field('functions_missing_error_handling'))\n        \n        # Calculate coverage using error_total (actual functions analyzed), not canonical_total\n        # This ensures accuracy - error handling analysis may analyze fewer functions than total\n        if error_total and error_with_handling:\n            calc_coverage = (error_with_handling / error_total) * 100\n            if 0 <= calc_coverage <= 100:\n                error_coverage = calc_coverage\n        elif error_coverage is None and error_total and error_with_handling:\n            # If coverage not provided, calculate it\n            error_coverage = (error_with_handling / error_total) * 100\n        \n        worst_error_modules = get_error_field('worst_modules', []) or []\n        if worst_error_modules is None or not isinstance(worst_error_modules, (list, tuple)):\n            worst_error_modules = []\n\n        # Helper to extract doc sync field (handles both standard and old format)\n        def get_doc_sync_field(data, field_name, default=None):\n            if not data or not isinstance(data, dict):\n                return default\n            # Check standard format first\n            if 'summary' in data and isinstance(data.get('summary'), dict):\n                # Standard format - check details for specific fields, summary for status\n                if field_name == 'status':\n                    return data['summary'].get('status', default)\n                else:\n                    return data.get('details', {}).get(field_name, default)\n            else:\n                # Old format - direct access\n                return data.get(field_name, default)\n        \n        path_drift_count = to_int(get_doc_sync_field(doc_sync_summary, 'path_drift_issues')) if doc_sync_summary else None\n        path_drift_files = get_doc_sync_field(doc_sync_summary, 'path_drift_files', []) if doc_sync_summary else []\n        if path_drift_files is None or not isinstance(path_drift_files, list):\n            path_drift_files = []\n        # Filter out section headers that were incorrectly parsed as file names\n        path_drift_files = [f for f in path_drift_files if f and isinstance(f, str) and not (f.isupper() and ('ISSUES' in f or 'COMPLIANCE' in f or 'DOCUMENTATION' in f or 'NUMBERING' in f))]\n        paired_doc_issues = to_int(get_doc_sync_field(doc_sync_summary, 'paired_doc_issues')) if doc_sync_summary else None\n        ascii_issues = to_int(get_doc_sync_field(doc_sync_summary, 'ascii_issues')) if doc_sync_summary else None\n\n        # Get legacy data - check standard format first\n        if legacy_summary and isinstance(legacy_summary, dict):\n            if 'summary' in legacy_summary and isinstance(legacy_summary.get('summary'), dict):\n                # Standard format\n                legacy_files = to_int(legacy_summary['summary'].get('files_affected', 0))\n                legacy_details = legacy_summary.get('details', {})\n                legacy_markers = to_int(legacy_details.get('legacy_markers', 0))\n                legacy_report = legacy_details.get('report_path')\n            else:\n                # Old format\n                legacy_files = to_int(legacy_summary.get('files_with_issues'))\n                legacy_markers = to_int(legacy_summary.get('legacy_markers'))\n                legacy_report = legacy_summary.get('report_path')\n        else:\n            legacy_files = None\n            legacy_markers = None\n            legacy_report = None\n\n        low_coverage_modules: List[Dict[str, Any]] = []\n        coverage_overall = None\n        worst_coverage_files: List[Dict[str, Any]] = []\n        if coverage_summary:\n            coverage_overall = (coverage_summary or {}).get('overall')\n            module_entries = (coverage_summary or {}).get('modules') or []\n            for module in module_entries:\n                coverage_value = to_float(module.get('coverage'))\n                # Convert coverage to float for comparison (handles both string and numeric values)\n                coverage_float = to_float(coverage_value) if coverage_value is not None else None\n                if coverage_float is not None and coverage_float < 80:\n                    low_coverage_modules.append(module)\n            low_coverage_modules = low_coverage_modules[:3]\n            worst_coverage_files = (coverage_summary or {}).get('worst_files') or []\n        \n        # Get dev tools coverage if available\n        dev_tools_coverage_overall = None\n        if hasattr(self, 'dev_tools_coverage_results') and self.dev_tools_coverage_results:\n            dev_tools_coverage_overall = self.dev_tools_coverage_results.get('overall', {})\n        dev_tools_insights = self._get_dev_tools_coverage_insights()\n\n        analyze_artifacts = analyze_data.get('artifacts') or []\n        analyze_duplicates = analyze_data.get('duplicates') or []\n        analyze_placeholders = analyze_data.get('placeholders') or []\n\n        # Get examples from function_metrics, ensuring we have the latest data\n        critical_examples = function_metrics.get('critical_complexity_examples') or []\n        high_examples = function_metrics.get('high_complexity_examples') or []\n        \n        # Also check decision_support_metrics for examples (extracted from text output)\n        decision_metrics = self.results_cache.get('decision_support_metrics', {})\n        if decision_metrics:\n            if not critical_examples and 'critical_complexity_examples' in decision_metrics:\n                critical_examples = decision_metrics.get('critical_complexity_examples', [])\n                function_metrics['critical_complexity_examples'] = critical_examples\n            if not high_examples and 'high_complexity_examples' in decision_metrics:\n                high_examples = decision_metrics.get('high_complexity_examples', [])\n                function_metrics['high_complexity_examples'] = high_examples\n        \n        # If examples are still missing, reload function metrics using unified loader\n        if not critical_examples and not high_examples:\n            func_result = self._load_tool_data('analyze_functions', 'functions')\n            if func_result and isinstance(func_result, dict):\n                if 'critical_complexity_examples' in func_result:\n                    critical_examples = func_result.get('critical_complexity_examples', [])\n                    function_metrics['critical_complexity_examples'] = critical_examples\n                if 'high_complexity_examples' in func_result:\n                    high_examples = func_result.get('high_complexity_examples', [])\n                    function_metrics['high_complexity_examples'] = high_examples\n        \n        # Get complexity metrics from canonical metrics or decision_support\n        moderate_complex = to_int(metrics.get('moderate'))\n        high_complex = to_int(metrics.get('high'))\n        critical_complex = to_int(metrics.get('critical'))\n        \n        # If not in metrics, try loading from decision_support_metrics\n        if moderate_complex is None or high_complex is None or critical_complex is None:\n            decision_metrics = self.results_cache.get('decision_support_metrics', {})\n            if decision_metrics:\n                if moderate_complex is None:\n                    moderate_complex = to_int(decision_metrics.get('moderate_complexity'))\n                if high_complex is None:\n                    high_complex = to_int(decision_metrics.get('high_complexity'))\n                if critical_complex is None:\n                    critical_complex = to_int(decision_metrics.get('critical_complexity'))\n\n        priority_items: List[Dict[str, Any]] = []\n        \n        # Fixed priority tiers (simplified from dynamic ordering)\n        # Tier 1 (Critical): Path drift, missing error handling, missing docs\n        TIER_1_CRITICAL = 1\n        # Tier 2 (High): Error handling improvements, test coverage\n        TIER_2_HIGH = 4\n        # Tier 3 (Medium): Legacy cleanup, complexity refactoring\n        TIER_3_MEDIUM = 7\n        # Tier 4 (Low): Documentation consolidation, config updates\n        TIER_4_LOW = 9\n        \n        # Track current order within each tier\n        tier_1_counter = TIER_1_CRITICAL\n        tier_2_counter = TIER_2_HIGH\n        tier_3_counter = TIER_3_MEDIUM\n        tier_4_counter = TIER_4_LOW\n\n        def add_priority(tier: int, title: str, reason: str, bullets: List[str]) -> None:\n            \"\"\"Add priority with fixed tier-based ordering.\n            \n            Args:\n                tier: Priority tier (1=Critical, 2=High, 3=Medium, 4=Low)\n                title: Priority title\n                reason: Priority reason\n                bullets: List of bullet points\n            \"\"\"\n            nonlocal tier_1_counter, tier_2_counter, tier_3_counter, tier_4_counter\n            if not reason:\n                return\n            # Map tier to order value\n            if tier == 1:\n                order = tier_1_counter\n                tier_1_counter += 1\n            elif tier == 2:\n                order = tier_2_counter\n                tier_2_counter += 1\n            elif tier == 3:\n                order = tier_3_counter\n                tier_3_counter += 1\n            elif tier == 4:\n                order = tier_4_counter\n                tier_4_counter += 1\n            else:\n                # Default to tier 4 for unknown tiers\n                order = tier_4_counter\n                tier_4_counter += 1\n            \n            priority_items.append({\n                'order': order,\n                'title': title,\n                'reason': reason,\n                'bullets': [bullet for bullet in bullets if bullet]\n            })\n\n        if path_drift_count and path_drift_count > 0:\n            drift_details: List[str] = []\n            if path_drift_files:\n                drift_details.append(\n                    f\"Top offenders: {self._format_list_for_display(path_drift_files, limit=3)}\"\n                )\n            if paired_doc_issues:\n                drift_details.append(\n                    f\"{paired_doc_issues} paired documentation sets affected alongside drift.\"\n                )\n            drift_details.append(\n                \"Action: Fix broken paths in top offender files, then run `python development_tools/run_development_tools.py doc-sync --fix`\"\n            )\n            drift_details.append(\n                \"Effort: Small (update file paths in documentation, run automated fix tool)\"\n            )\n            drift_details.append(\n                \"Why this matters: Broken paths in documentation reduce trust and make navigation difficult\"\n            )\n            add_priority(\n                tier=1,  # Tier 1: Critical\n                title=\"Stabilize documentation drift\",\n                reason=f\"{path_drift_count} documentation paths are out of sync.\",\n                bullets=drift_details\n            )\n\n        if missing_docs_count and missing_docs_count > 0:\n            doc_bullets: List[str] = []\n            # Show first few functions or modules that need documentation\n            if missing_doc_files:\n                doc_bullets.append(\n                    f\"Start with: {self._format_list_for_display(list(missing_doc_files)[:3], limit=3)}\"\n                )\n            # Try to get examples of undocumented functions\n            # Access function_metrics - check details first (normalized), then top level (backward compat)\n            function_metrics_details = function_metrics.get('details', {})\n            undocumented_examples = function_metrics_details.get('undocumented_examples') or function_metrics.get('undocumented_examples') or []\n            if undocumented_examples and isinstance(undocumented_examples, list):\n                example_names = [ex.get('name', ex) if isinstance(ex, dict) else str(ex) for ex in undocumented_examples[:3]]\n                if example_names:\n                    doc_bullets.append(\n                        f\"Example functions needing docstrings: {self._format_list_for_display(example_names, limit=3)}\"\n                    )\n            doc_bullets.append(\n                \"Action: Add docstrings to functions missing them. Regenerate registry entries via `python development_tools/run_development_tools.py docs`.\"\n            )\n            doc_bullets.append(\n                \"Effort: Medium (requires understanding each function's purpose and parameters)\"\n            )\n            doc_bullets.append(\n                \"Why this matters: Documentation helps AI collaborators and future developers understand code intent\"\n            )\n            # Calculate total and documented for better context\n            total_funcs = metrics.get('total_functions')\n            doc_totals = doc_metrics_details.get('totals') or doc_metrics.get('totals') or {}\n            documented_funcs = doc_totals.get('functions_documented') if isinstance(doc_totals, dict) else None\n            reason_text = f\"{missing_docs_count} functions are missing documentation\"\n            if total_funcs and documented_funcs is not None:\n                reason_text += f\" ({total_funcs} total, {documented_funcs} documented)\"\n            reason_text += \".\"\n            add_priority(\n                tier=1,  # Tier 1: Critical\n                title=\"Add documentation to missing functions\",\n                reason=reason_text,\n                bullets=doc_bullets\n            )\n\n        # Add error handling to missing functions FIRST (before Phase 1/2, as it's more critical)\n        # This should be ranked higher than Phase 1/2 because functions with NO error handling are more critical\n        # than functions that have basic error handling that needs upgrading\n        if missing_error_handlers and missing_error_handlers > 0:\n            error_handling_bullets: List[str] = []\n            \n            # List modules with function counts\n            if worst_error_modules:\n                module_list = []\n                for module in worst_error_modules[:10]:  # Show up to 10 modules\n                    module_name = module.get('module', 'Unknown')\n                    missing_count = module.get('missing', 0)\n                    if missing_count > 0:\n                        module_list.append(f\"{module_name}: {missing_count} functions\")\n                \n                if module_list:\n                    module_list_str = self._format_list_for_display(module_list, limit=10)\n                    error_handling_bullets.append(module_list_str)\n            \n            error_handling_bullets.append(\n                \"Add error handling decorators or try-except blocks to protect these functions.\"\n            )\n            # Add specific file paths and line numbers if available\n            missing_error_list = get_error_field('missing_error_handling', []) or []\n            if missing_error_list and isinstance(missing_error_list, list):\n                specific_functions = []\n                for func_info in missing_error_list[:3]:\n                    if isinstance(func_info, dict):\n                        file_path = func_info.get('file', '')\n                        func_name = func_info.get('function', '')\n                        line_num = func_info.get('line', '')\n                        if file_path and func_name:\n                            if line_num:\n                                specific_functions.append(f\"{file_path}:{line_num} ({func_name})\")\n                            else:\n                                specific_functions.append(f\"{file_path} ({func_name})\")\n                if specific_functions:\n                    error_handling_bullets.append(\n                        f\"Specific functions: {self._format_list_for_display(specific_functions, limit=3)}\"\n                    )\n            error_handling_bullets.append(\n                \"Effort: Small (add @handle_errors decorator or wrap in try-except)\"\n            )\n            error_handling_bullets.append(\n                \"Why this matters: Functions without error handling can crash the application on unexpected errors\"\n            )\n            \n            add_priority(\n                tier=1,  # Tier 1: Critical\n                title=\"Add error handling to missing functions\",\n                reason=f\"{missing_error_handlers} functions have no error handling.\",\n                bullets=error_handling_bullets\n            )\n        \n        # Phase 1: Decorator replacement candidates (after missing error handlers)\n        phase1_total = to_int(get_error_field('phase1_total', 0))\n        phase1_by_priority = get_error_field('phase1_by_priority', {}) or {}\n        phase1_high = to_int(phase1_by_priority.get('high', 0))\n        \n        if phase1_total and phase1_total > 0:\n            phase1_bullets: List[str] = []\n            # Get phase1 candidates to group by module\n            phase1_candidates = get_error_field('phase1_candidates', []) or []\n            if not isinstance(phase1_candidates, list):\n                phase1_candidates = []\n            \n            # Group by module (file_path) and priority\n            if phase1_candidates:\n                from collections import defaultdict\n                high_by_module = defaultdict(int)\n                medium_by_module = defaultdict(int)\n                \n                for candidate in phase1_candidates:\n                    if isinstance(candidate, dict):\n                        file_path = candidate.get('file_path', '')\n                        priority = candidate.get('priority', '').lower()\n                        if file_path:\n                            # Extract module name (file path without extension)\n                            module = file_path.replace('\\\\', '/')\n                            if priority == 'high':\n                                high_by_module[module] += 1\n                            elif priority == 'medium':\n                                medium_by_module[module] += 1\n                \n                # Show top modules with high-priority candidates, or medium if no high\n                if phase1_high and phase1_high > 0:\n                    phase1_bullets.append(\n                        f\"Start with {phase1_high} high-priority candidates (entry points and critical operations).\"\n                    )\n                    if high_by_module:\n                        # Sort by count and show top 3\n                        top_modules = sorted(high_by_module.items(), key=lambda x: x[1], reverse=True)[:3]\n                        module_list = [f\"{Path(m).name} ({count})\" for m, count in top_modules]\n                        if module_list:\n                            phase1_bullets.append(f\"Top modules: {self._format_list_for_display(module_list, limit=3)}\")\n                else:\n                    # No high priority, show medium priority modules\n                    phase1_medium = to_int(phase1_by_priority.get('medium', 0))\n                    if phase1_medium and phase1_medium > 0:\n                        phase1_bullets.append(\n                            f\"Process {phase1_medium} medium-priority functions.\"\n                        )\n                        if medium_by_module:\n                            top_modules = sorted(medium_by_module.items(), key=lambda x: x[1], reverse=True)[:3]\n                            module_list = [f\"{Path(m).name} ({count})\" for m, count in top_modules]\n                            if module_list:\n                                phase1_bullets.append(f\"Top modules: {self._format_list_for_display(module_list, limit=3)}\")\n            \n            phase1_medium = to_int(phase1_by_priority.get('medium', 0))\n            if phase1_medium and phase1_medium > 0 and phase1_high and phase1_high > 0:\n                phase1_bullets.append(\n                    f\"Then process {phase1_medium} medium-priority functions.\"\n                )\n            phase1_bullets.append(\n                \"Apply `@handle_errors` decorator to replace basic try-except blocks.\"\n            )\n            # Add effort estimate and context\n            phase1_bullets.append(\n                \"Effort: Medium (requires reviewing each function's error handling needs)\"\n            )\n            phase1_bullets.append(\n                \"Why this matters: Centralized error handling provides consistent logging and recovery patterns\"\n            )\n            add_priority(\n                tier=2,  # Tier 2: High\n                title=\"Phase 1: Replace basic try-except with decorators\",\n                reason=f\"{phase1_total} functions have try-except blocks that should use `@handle_errors` decorator.\",\n                bullets=phase1_bullets\n            )\n        \n        # Phase 2: Generic exception categorization (after Phase 1)\n        phase2_total = to_int(get_error_field('phase2_total', 0))\n        phase2_by_type = get_error_field('phase2_by_type', {}) or {}\n        \n        if phase2_total and phase2_total > 0:\n            phase2_bullets: List[str] = []\n            top_exceptions = sorted(phase2_by_type.items(), key=lambda x: x[1], reverse=True)[:3]\n            if top_exceptions:\n                exc_details = [f\"{count} {exc_type}\" for exc_type, count in top_exceptions]\n                phase2_bullets.append(\n                    f\"Most common: {self._format_list_for_display(exc_details, limit=3)}\"\n                )\n            \n            # Get phase2 exceptions to group by module\n            phase2_exceptions = get_error_field('phase2_exceptions', []) or []\n            if not isinstance(phase2_exceptions, list):\n                phase2_exceptions = []\n            if phase2_exceptions:\n                from collections import defaultdict\n                exceptions_by_module = defaultdict(int)\n                \n                for exc in phase2_exceptions:\n                    if isinstance(exc, dict):\n                        file_path = exc.get('file_path', '')\n                        if file_path:\n                            module = file_path.replace('\\\\', '/')\n                            exceptions_by_module[module] += 1\n                \n                if exceptions_by_module:\n                    # Sort by count and show top 3\n                    top_modules = sorted(exceptions_by_module.items(), key=lambda x: x[1], reverse=True)[:3]\n                    module_list = [f\"{Path(m).name} ({count})\" for m, count in top_modules]\n                    if module_list:\n                        phase2_bullets.append(f\"Top modules: {self._format_list_for_display(module_list, limit=3)}\")\n            \n            phase2_bullets.append(\n                \"Replace generic exceptions (ValueError, Exception, KeyError, TypeError) with specific project error classes.\"\n            )\n            phase2_bullets.append(\n                \"See `ai_development_docs/AI_ERROR_HANDLING_GUIDE.md` for categorization rules.\"\n            )\n            phase2_bullets.append(\n                \"Effort: Small (replace exception class names, update imports)\"\n            )\n            phase2_bullets.append(\n                \"Why this matters: Specific error classes enable targeted error handling and better debugging\"\n            )\n            add_priority(\n                tier=2,  # Tier 2: High\n                title=\"Phase 2: Categorize generic exceptions\",\n                reason=f\"{phase2_total} generic exception raises need categorization into project-specific error classes.\",\n                bullets=phase2_bullets\n            )\n        \n        # Legacy error handling priority removed - now handled above with proper ordering\n\n        # Use fixed tier-based ordering (no dynamic calculation needed)\n        if low_coverage_modules:\n            coverage_highlights = [\n                f\"{module.get('module', 'module')} ({percent_text(module.get('coverage'), 1)}, {module.get('missed')} lines missing)\"\n                for module in low_coverage_modules\n            ]\n            coverage_bullets = [\n                f\"Target domains: {self._format_list_for_display(coverage_highlights, limit=3)}\",\n                \"Add scenario tests before the next full audit to lift domain coverage above 80%.\"\n            ]\n            add_priority(\n                tier=2,  # Tier 2: High\n                title=\"Raise coverage for domains below target\",\n                reason=f\"{len(low_coverage_modules)} key domains remain below the 80% target.\",\n                bullets=coverage_bullets\n            )\n\n        if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n            dev_pct = dev_tools_insights['overall_pct']\n            low_dev_modules = dev_tools_insights.get('low_modules') or []\n            if dev_pct < 60 or low_dev_modules:\n                dev_bullets: List[str] = []\n                if low_dev_modules:\n                    highlights = [\n                        f\"{Path(item['path']).name} ({percent_text(item.get('coverage'), 1)})\"\n                        for item in low_dev_modules\n                    ]\n                    dev_bullets.append(f\"Focus on: {self._format_list_for_display(highlights, limit=3)}\")\n                if dev_tools_insights.get('html'):\n                    dev_bullets.append(f\"Review HTML report at {dev_tools_insights['html']}\")\n                dev_bullets.append(\"Strengthen tests in `tests/development_tools/` for fragile helpers.\")\n                add_priority(\n                    tier=2,  # Tier 2: High\n                    title=\"Raise development tools coverage\",\n                    reason=f\"Development tools coverage is {percent_text(dev_pct, 1)} (target 60%+).\",\n                    bullets=dev_bullets\n                )\n\n        dependency_summary = self.module_dependency_summary or self.results_cache.get('analyze_module_dependencies')\n\n        if dependency_summary and dependency_summary.get('missing_dependencies'):\n\n            missing = dependency_summary['missing_dependencies']\n\n            dep_bullets = []\n\n            files = dependency_summary.get('missing_files') or dependency_summary.get('missing_sections') or []\n\n            if files:\n\n                dep_bullets.append(f\"Affected files: {self._format_list_for_display(files, limit=3)}\")\n\n            dep_bullets.append(\"Regenerate dependencies via `python development_tools/run_development_tools.py docs` and rerun the audit.\")\n\n            # Don't add as priority - move to Quick Wins instead\n            # Store for Quick Wins section\n            if not hasattr(self, '_quick_wins_dependency'):\n                self._quick_wins_dependency = {\n                    'missing': missing,\n                    'files': files\n                }\n\n        if legacy_files and legacy_files > 0:\n            legacy_bullets: List[str] = []\n            if legacy_markers:\n                legacy_bullets.append(f\"{legacy_markers} legacy markers still surface during scans.\")\n            if legacy_report:\n                legacy_bullets.append(f\"Review {legacy_report} for exact locations.\")\n            legacy_bullets.append(\n                \"Use `python development_tools/run_development_tools.py legacy` to scan for legacy references.\"\n            )\n            add_priority(\n                tier=3,  # Tier 3: Medium\n                title=\"Retire remaining legacy references\",\n                reason=f\"{legacy_files} files still depend on legacy compatibility markers.\",\n                bullets=legacy_bullets\n            )\n        \n        # Add config validation recommendations to Immediate Focus (before complexity)\n        config_validation_summary = self._load_config_validation_summary()\n        if config_validation_summary:\n            total_recommendations = config_validation_summary.get('total_recommendations', 0)\n            recommendations = config_validation_summary.get('recommendations', [])\n            if total_recommendations > 0 and recommendations:\n                # Use the config_order calculated above (after dev tools coverage, before legacy)\n                config_bullets: List[str] = []\n                # Show top 2-3 recommendations, removing duplicates\n                seen_messages = set()\n                unique_recs = []\n                for rec in recommendations:\n                    rec_text = rec if isinstance(rec, str) else rec.get('message', str(rec))\n                    # Normalize to check for duplicates (case-insensitive, ignore \"Update\" vs \"Fix\" prefix)\n                    # Also normalize tool names and common phrases to catch semantic duplicates\n                    normalized = rec_text.lower()\n                    # Remove prefixes\n                    normalized = normalized.replace('update ', '').replace('fix ', '').replace('fixes ', '')\n                    # Normalize \"import config module\" variations\n                    normalized = normalized.replace('does not import config', 'import config').replace('to import config module', 'import config')\n                    # Extract tool name and core message for better duplicate detection\n                    if ':' in normalized:\n                        # For \"Fix issues in X: Y\" format, check if Y is already covered\n                        parts = normalized.split(':', 1)\n                        if len(parts) == 2:\n                            tool_part = parts[0].strip()\n                            issue_part = parts[1].strip()\n                            # Check if issue is about config import (already covered by \"Update X to import config\")\n                            if 'import config' in issue_part:\n                                # Skip this recommendation if we already have \"Update X to import config\"\n                                skip = False\n                                for seen in seen_messages:\n                                    if tool_part in seen and 'import config' in seen:\n                                        skip = True\n                                        break\n                                if skip:\n                                    continue\n                    if normalized not in seen_messages:\n                        seen_messages.add(normalized)\n                        unique_recs.append(rec_text)\n                    if len(unique_recs) >= 3:\n                        break\n                for rec_text in unique_recs:\n                    config_bullets.append(rec_text)\n                if len(recommendations) > len(unique_recs):\n                    config_bullets.append(f\"...and {len(recommendations) - len(unique_recs)} more recommendation(s)\")\n                add_priority(\n                    tier=4,  # Tier 4: Low\n                    title=\"Update tools to use centralized config\",\n                    reason=f\"{total_recommendations} config validation recommendation(s) pending review.\",\n                    bullets=config_bullets\n                )\n        \n        # Add test markers priority (Tier 2: High - test quality)\n        test_markers_data = self._load_tool_data('analyze_test_markers', 'tests')\n        if test_markers_data and isinstance(test_markers_data, dict):\n            # Handle both standard format and old format\n            if 'summary' in test_markers_data:\n                missing_markers = test_markers_data['summary'].get('total_issues', 0)\n                details = test_markers_data.get('details', {})\n                missing_list = details.get('missing', [])\n            else:\n                missing_markers = test_markers_data.get('missing_count', 0)\n                missing_list = test_markers_data.get('missing', [])\n            \n            if missing_markers and missing_markers > 0:\n                test_markers_bullets: List[str] = []\n                # Get unique files with missing markers\n                if missing_list:\n                    files_with_missing = set()\n                    for item in missing_list:\n                        if isinstance(item, dict):\n                            file_path = item.get('file', '')\n                            if file_path:\n                                files_with_missing.add(file_path)\n                    if files_with_missing:\n                        files_list = list(files_with_missing)[:3]\n                        test_markers_bullets.append(\n                            f\"Top files: {self._format_list_for_display(files_list, limit=3)}\"\n                        )\n                test_markers_bullets.append(\n                    \"Add category markers to test functions using `development_tools/tests/fix_test_markers.py`.\"\n                )\n                add_priority(\n                    tier=2,  # Tier 2: High\n                    title=\"Add test category markers\",\n                    reason=f\"{missing_markers} tests missing category markers.\",\n                    bullets=test_markers_bullets\n                )\n        \n        # Add function patterns (handlers without docs) as priority or quick win\n        function_patterns_data = self._load_tool_data('analyze_function_patterns', 'functions')\n        if function_patterns_data and isinstance(function_patterns_data, dict):\n            # Handle both standard format and old format\n            if 'details' in function_patterns_data:\n                handlers = function_patterns_data['details'].get('handlers', [])\n            else:\n                handlers = function_patterns_data.get('handlers', [])\n            \n            if handlers:\n                handlers_no_doc = [h for h in handlers if not h.get('has_doc', True)]\n                if handlers_no_doc:\n                    # Add as quick win if small, otherwise as priority\n                    if len(handlers_no_doc) <= 5:\n                        if not hasattr(self, '_quick_wins_handlers'):\n                            handler_examples = []\n                            for h in handlers_no_doc[:3]:\n                                class_name = h.get('class', 'Unknown')\n                                file_path = h.get('file', '')\n                                if file_path:\n                                    handler_examples.append(f\"{class_name} ({file_path})\")\n                                else:\n                                    handler_examples.append(class_name)\n                            self._quick_wins_handlers = {\n                                'count': len(handlers_no_doc),\n                                'examples': handler_examples\n                            }\n                    else:\n                        # Add as priority item\n                        handlers_bullets: List[str] = []\n                        handler_examples = []\n                        for h in handlers_no_doc[:3]:\n                            class_name = h.get('class', 'Unknown')\n                            file_path = h.get('file', '')\n                            if file_path:\n                                handler_examples.append(f\"{class_name} ({file_path})\")\n                            else:\n                                handler_examples.append(class_name)\n                        if handler_examples:\n                            handlers_bullets.append(\n                                f\"Examples: {self._format_list_for_display(handler_examples, limit=3)}\"\n                            )\n                        handlers_bullets.append(\n                            \"Add docstrings to handler classes to improve code documentation.\"\n                        )\n                        add_priority(\n                            tier=1,  # Tier 1: Critical (documentation)\n                            title=\"Add documentation to handler classes\",\n                            reason=f\"{len(handlers_no_doc)} handler classes missing documentation.\",\n                            bullets=handlers_bullets\n                        )\n        \n        # Add complexity refactoring priority if there are critical or high complexity functions\n        if critical_complex and critical_complex > 0:\n            complexity_bullets: List[str] = []\n            if critical_examples:\n                # Get top 3 functions with highest complexity\n                # Sort by complexity if available, otherwise use first 3\n                sorted_examples = sorted(\n                    critical_examples[:10],  # Check first 10 for sorting\n                    key=lambda x: x.get('complexity', 0) if isinstance(x, dict) else 0,\n                    reverse=True\n                )[:3]\n                example_names = []\n                for ex in sorted_examples:\n                    if isinstance(ex, dict):\n                        func_name = ex.get('name', ex.get('function', 'unknown'))\n                        file_name = ex.get('file', '')\n                        if file_name:\n                            example_names.append(f\"{func_name} ({file_name})\")\n                        else:\n                            example_names.append(func_name)\n                    else:\n                        example_names.append(str(ex))\n                if example_names:\n                    complexity_bullets.append(\n                        f\"Highest complexity: {self._format_list_for_display(example_names, limit=3)}\"\n                    )\n            if high_complex and high_complex > 0 and critical_complex <= 10:  # Only show if critical count is low\n                complexity_bullets.append(\n                    f\"Then address {high_complex} high-complexity functions (100-199 nodes).\"\n                )\n            add_priority(\n                tier=3,  # Tier 3: Medium\n                title=\"Refactor high-complexity functions\",\n                reason=f\"{critical_complex} critical-complexity functions (>199 nodes) need immediate attention.\",\n                bullets=complexity_bullets\n            )\n        elif high_complex and high_complex > 0:\n            complexity_bullets: List[str] = []\n            if high_examples:\n                # Get top 3 functions with highest complexity\n                sorted_examples = sorted(\n                    high_examples[:10],\n                    key=lambda x: x.get('complexity', 0) if isinstance(x, dict) else 0,\n                    reverse=True\n                )[:3]\n                example_names = []\n                for ex in sorted_examples:\n                    if isinstance(ex, dict):\n                        func_name = ex.get('name', ex.get('function', 'unknown'))\n                        file_name = ex.get('file', '')\n                        if file_name:\n                            example_names.append(f\"{func_name} ({file_name})\")\n                        else:\n                            example_names.append(func_name)\n                    else:\n                        example_names.append(str(ex))\n                if example_names:\n                    complexity_bullets.append(\n                        f\"Highest complexity: {self._format_list_for_display(example_names, limit=3)}\"\n                    )\n            add_priority(\n                tier=3,  # Tier 3: Medium\n                title=\"Refactor high-complexity functions\",\n                reason=f\"{high_complex} high-complexity functions (100-199 nodes) should be simplified.\",\n                bullets=complexity_bullets\n            )\n\n        # Store TODO sync for Quick Wins instead of Immediate Focus\n        todo_sync_result = getattr(self, 'todo_sync_result', None)\n        if todo_sync_result and isinstance(todo_sync_result, dict):\n            completed_entries = todo_sync_result.get('completed_entries', 0)\n            if completed_entries > 0:\n                if not hasattr(self, '_quick_wins_todo'):\n                    # Get line numbers from entries if available\n                    entries = todo_sync_result.get('entries', [])\n                    line_numbers = [str(entry.get('line_number', '')) for entry in entries if entry.get('line_number')]\n                    self._quick_wins_todo = {\n                        'count': completed_entries,\n                        'line_numbers': line_numbers\n                    }\n        \n        lines.append(\"## Immediate Focus (Ranked)\")\n        if priority_items:\n            for idx, item in enumerate(sorted(priority_items, key=lambda entry: entry['order']), start=1):\n                lines.append(f\"{idx}. **{item['title']}**  -  {item['reason']}\")\n                for bullet in item['bullets']:\n                    lines.append(f\"   - {bullet}\")\n        else:\n            lines.append(\"All signals are green. Re-run `python development_tools/run_development_tools.py status` to monitor.\")\n        lines.append(\"\")\n\n        quick_wins: List[str] = []\n        if ascii_issues is not None and ascii_issues > 0:\n            quick_wins.append(f\"Normalize {ascii_issues} file(s) with non-ASCII characters via doc-fix.\")\n        \n        # Add dependency documentation refresh to Quick Wins\n        if hasattr(self, '_quick_wins_dependency') and self._quick_wins_dependency:\n            dep_info = self._quick_wins_dependency\n            missing = dep_info.get('missing', 0)\n            files = dep_info.get('files', [])\n            if missing > 0:\n                files_str = self._format_list_for_display(files, limit=2) if files else \"affected files\"\n                quick_wins.append(f\"Refresh dependency documentation: {missing} module dependencies are undocumented ({files_str}). Regenerate via `python development_tools/run_development_tools.py docs`.\")\n        \n        # Add handler classes without docs to Quick Wins (if small count)\n        if hasattr(self, '_quick_wins_handlers') and self._quick_wins_handlers:\n            handler_info = self._quick_wins_handlers\n            count = handler_info.get('count', 0)\n            examples = handler_info.get('examples', [])\n            if count > 0:\n                examples_str = self._format_list_for_display(examples, limit=2) if examples else \"\"\n                quick_wins.append(f\"Add documentation to {count} handler class(es) missing docs{(' (' + examples_str + ')') if examples_str else ''}.\")\n        \n        # Add TODO sync to Quick Wins\n        if hasattr(self, '_quick_wins_todo') and self._quick_wins_todo:\n            if isinstance(self._quick_wins_todo, dict):\n                count = self._quick_wins_todo.get('count', 0)\n                line_numbers = self._quick_wins_todo.get('line_numbers', [])\n                if line_numbers:\n                    lines_str = ', '.join(line_numbers[:5])  # Show up to 5 line numbers\n                    if len(line_numbers) > 5:\n                        lines_str += f\", ... +{len(line_numbers) - 5}\"\n                    quick_wins.append(f\"Review {count} completed TODO entry/entries (lines {lines_str}) - if documented in changelogs, remove from TODO.md; otherwise move to CHANGELOG_DETAIL.md and AI_CHANGELOG.md first.\")\n                else:\n                    quick_wins.append(f\"Review {count} completed TODO entry/entries - if documented in changelogs, remove from TODO.md; otherwise move to CHANGELOG_DETAIL.md and AI_CHANGELOG.md first.\")\n            else:\n                # Backward compatibility\n                quick_wins.append(f\"Review {self._quick_wins_todo} completed TODO entry/entries - if documented in changelogs, remove from TODO.md; otherwise move to CHANGELOG_DETAIL.md and AI_CHANGELOG.md first.\")\n        \n        if paired_doc_issues and not (path_drift_count and path_drift_count > 0):\n            # Add actionable details about paired doc issues\n            if doc_sync_summary:\n                paired_docs_data = doc_sync_summary.get('paired_docs', {})\n                if isinstance(paired_docs_data, dict):\n                    content_sync_issues = paired_docs_data.get('content_sync', [])\n                    if content_sync_issues:\n                        # Show total count and first actionable issue\n                        quick_wins.append(f\"Resolve {paired_doc_issues} paired doc sync issue(s). Start with: {content_sync_issues[0]}\")\n                        if len(content_sync_issues) > 1:\n                            quick_wins.append(f\"  - Plus {len(content_sync_issues) - 1} more issue(s) to address\")\n                    else:\n                        quick_wins.append(f\"Resolve {paired_doc_issues} unpaired documentation sets flagged by doc-sync.\")\n                else:\n                    quick_wins.append(f\"Resolve {paired_doc_issues} unpaired documentation sets flagged by doc-sync.\")\n            else:\n                quick_wins.append(f\"Resolve {paired_doc_issues} unpaired documentation sets flagged by doc-sync.\")\n        if analyze_artifacts:\n            artifact = analyze_artifacts[0]\n            location = artifact.get('file', 'unknown')\n            line_number = artifact.get('line')\n            if line_number:\n                location = f\"{location}:{line_number}\"\n            pattern = artifact.get('pattern', 'lint issue')\n            quick_wins.append(f\"Clean `{pattern}` marker in {location}.\")\n        if analyze_duplicates:\n            quick_wins.append(f\"Merge {len(analyze_duplicates)} duplicate documentation block(s).\")\n        if analyze_placeholders:\n            quick_wins.append(f\"Replace {len(analyze_placeholders)} placeholder section(s) flagged by docs scan.\")\n        \n        # Add documentation analysis quick wins\n        if ascii_data and isinstance(ascii_data, dict):\n            # Use standard format\n            summary = ascii_data.get('summary', {})\n            ascii_total = summary.get('total_issues', 0)\n            ascii_file_count = summary.get('files_affected', 0)\n            if ascii_total > 0:\n                quick_wins.append(f\"Fix {ascii_total} ASCII compliance issue(s) in {ascii_file_count} file(s) - run `python development_tools/run_development_tools.py doc-fix --fix-ascii`\")\n        \n        if heading_data and isinstance(heading_data, dict):\n            # Use standard format\n            summary = heading_data.get('summary', {})\n            heading_total = summary.get('total_issues', 0)\n            heading_file_count = summary.get('files_affected', 0)\n            if heading_total > 0:\n                quick_wins.append(f\"Fix {heading_total} heading numbering issue(s) in {heading_file_count} file(s) - run `python development_tools/run_development_tools.py doc-fix --number-headings`\")\n        \n        if missing_addresses_data and isinstance(missing_addresses_data, dict):\n            # Use standard format\n            summary = missing_addresses_data.get('summary', {})\n            missing_total = summary.get('total_issues', 0)\n            missing_file_count = summary.get('files_affected', 0)\n            if missing_total > 0:\n                quick_wins.append(f\"Add file address metadata to {missing_file_count} file(s) missing addresses - run `python development_tools/run_development_tools.py doc-fix --add-addresses`\")\n        \n        if unconverted_links_data and isinstance(unconverted_links_data, dict):\n            # Use standard format\n            summary = unconverted_links_data.get('summary', {})\n            links_total = summary.get('total_issues', 0)\n            links_file_count = summary.get('files_affected', 0)\n            if links_total > 0:\n                quick_wins.append(f\"Convert {links_total} unconverted link(s) in {links_file_count} file(s) - run `python development_tools/run_development_tools.py doc-fix --convert-links`\")\n        \n        # Add unused imports to quick wins if available\n        # Load unused imports data from standardized storage (simplified fallback chain)\n        unused_imports_data = {}\n        try:\n            # First try results_cache (in-memory, fastest)\n            cached = self.results_cache.get('analyze_unused_imports')\n            if cached and isinstance(cached, dict):\n                unused_imports_data = cached\n            else:\n                # Fallback to standardized storage\n                from .output_storage import load_tool_result\n                unused_result = load_tool_result('analyze_unused_imports', 'imports', project_root=self.project_root)\n                if unused_result and isinstance(unused_result, dict):\n                    unused_imports_data = unused_result\n        except Exception as e:\n            logger.debug(f\"Failed to load unused imports for AI_PRIORITIES: {e}\")\n            unused_imports_data = {}\n        \n        if unused_imports_data and isinstance(unused_imports_data, dict):\n            # Access standard format\n            summary = unused_imports_data.get('summary', {})\n            details = unused_imports_data.get('details', {})\n            total_unused = summary.get('total_issues', 0) or unused_imports_data.get('total_unused', 0)\n            files_with_issues = summary.get('files_affected', 0) or unused_imports_data.get('files_with_issues', 0)\n            if total_unused > 0 and files_with_issues > 0:\n                by_category = details.get('by_category') or unused_imports_data.get('by_category') or {}\n                obvious = by_category.get('obvious_unused', 0)\n                # Removed from Quick Wins - unused imports cleanup is not a quick win\n                # (it requires careful review to avoid breaking code)\n\n        lines.append(\"## Quick Wins\")\n        if quick_wins:\n            for win in quick_wins:\n                lines.append(f\"- {win}\")\n        else:\n            lines.append(\"- No immediate quick wins identified. Re-run doc-sync after tackling focus items.\")\n        \n        # Add overlap analysis information only if there are issues to prioritize\n        consolidation_count = len(consolidation_recs) if consolidation_recs else 0\n        overlap_count = len(section_overlaps) if section_overlaps else 0\n        \n        # Add consolidation opportunities as priority items\n        if consolidation_recs and consolidation_count > 0:\n            # Use tier 4 for consolidation (low priority)\n            consolidation_bullets: List[str] = []\n            for rec in consolidation_recs[:3]:  # Show top 3\n                category = rec.get('category', 'Unknown')\n                files = rec.get('files', [])\n                suggestion = rec.get('suggestion', '')\n                if files and len(files) > 1:\n                    consolidation_bullets.append(f\"{category}: {len(files)} files - {suggestion}\")\n                    consolidation_bullets.append(f\"  Files: {', '.join(files[:3])}{'...' if len(files) > 3 else ''}\")\n            add_priority(\n                tier=4,  # Tier 4: Low\n                title=\"Consolidate documentation files\",\n                reason=f\"{consolidation_count} file groups could be consolidated to reduce redundancy.\",\n                bullets=consolidation_bullets\n            )\n        elif overlap_count > 0:\n            # If only overlaps (no consolidation recs), add as lower priority\n            # Use tier 4 for overlap (low priority)\n            overlap_bullets = [f\"{overlap_count} section overlaps detected - review for consolidation opportunities\"]\n            add_priority(\n                tier=4,  # Tier 4: Low\n                title=\"Review documentation overlaps\",\n                reason=f\"{overlap_count} section overlaps detected across documentation files.\",\n                bullets=overlap_bullets\n            )\n        \n        lines.append(\"\")\n\n        watch_list: List[str] = []\n        # Only add doc coverage to watch list if below threshold (90%)\n        # Convert coverage to float for comparison (handles both string and numeric values)\n        doc_coverage_float = to_float(doc_coverage_value) if doc_coverage_value is not None else None\n        if doc_coverage_float is not None and doc_coverage_float < 90:\n            watch_list.append(f\"Documentation coverage sits at {percent_text(doc_coverage_value, 2)} (target 90%).\")\n        if coverage_overall:\n            coverage_pct = coverage_overall.get('coverage', 0)\n            target = 80  # Standard target for test coverage\n            watch_list.append(\n                f\"Overall test coverage is {percent_text(coverage_pct, 1)} (target {target}%) \"\n                f\"({coverage_overall.get('covered')} / {coverage_overall.get('statements')} statements).\"\n            )\n        if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n            dev_pct = dev_tools_insights['overall_pct']\n            detail = f\"Development tools coverage is {percent_text(dev_pct, 1)} (target 60%+).\"\n            # Note: Specific modules to focus on are listed in priorities, not watchlist\n            watch_list.append(detail)\n        dependency_summary = self.module_dependency_summary or self.results_cache.get('analyze_module_dependencies')\n        # Removed dependency docs and TODO sync from watchlist per user feedback\n        # (these belong in priorities, not watchlist)\n        \n        # Add high complexity monitoring to watchlist if there are high complexity functions\n        if high_examples:\n            high_focus = [\n                f\"{entry['function']} ({entry['file']})\"\n                for entry in high_examples[:3]  # Show top 3\n            ]\n            if high_focus:\n                watch_list.append(f\"Monitor high complexity functions: {self._format_list_for_display(high_focus, limit=3)}.\")\n        \n        if legacy_markers and (not legacy_files or legacy_files == 0):\n            watch_list.append(f\"{legacy_markers} legacy markers remain; schedule periodic cleanup post-sprint.\")\n        \n        # Add AI work validation to watch list (lightweight structural validation only)\n        validation_output = ''\n        if hasattr(self, 'validation_results') and self.validation_results:\n            validation_output = self.validation_results.get('output', '')\n        \n        if not validation_output:\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'analyze_ai_work' in cached_data['results']:\n                        validation_result = cached_data['results']['analyze_ai_work']\n                        if 'data' in validation_result:\n                            data = validation_result['data']\n                            validation_output = data.get('output', '') or ''\n            except Exception:\n                pass\n        \n        if validation_output and ('POOR' in validation_output or 'NEEDS ATTENTION' in validation_output or 'FAIR' in validation_output):\n            watch_list.append(\"AI Work Validation: Structural validation issues detected (see consolidated report)\")\n\n        lines.append(\"## Watch List\")\n        if watch_list:\n            for item in watch_list:\n                lines.append(f\"- {item}\")\n        else:\n            lines.append(\"- No outstanding watch items. Continue regular audits to maintain signal quality.\")\n        lines.append(\"\")\n\n        lines.append(\"## Follow-up Commands\")\n        lines.append(\"- `python development_tools/run_development_tools.py doc-sync`  -  refresh drift, pairing, and ASCII metrics.\")\n        lines.append(\"- `python development_tools/run_development_tools.py audit --full`  -  rebuild coverage and hygiene data after fixes.\")\n        lines.append(\"- `python development_tools/run_development_tools.py status`  -  confirm the latest health snapshot.\")\n\n        return '\\n'.join(lines)\n    def _generate_consolidated_report(self) -> str:\n\n        \"\"\"Generate comprehensive consolidated report combining all tool outputs.\"\"\"\n        \n        # Check if this is a mid-audit write (not the legitimate end-of-audit write)\n        # Only warn if audit is in progress AND we're not in the legitimate end-of-audit context\n        instance_flag = hasattr(self, '_audit_in_progress') and self._audit_in_progress\n        audit_in_progress = instance_flag or _is_audit_in_progress(self.project_root)\n        is_legitimate_end_write = hasattr(self, 'current_audit_tier') and self.current_audit_tier is not None\n        \n        if audit_in_progress and not is_legitimate_end_write:\n            # This is a mid-audit write from a new instance (likely from tests or separate process)\n            if not instance_flag:\n                logger.warning(\"_generate_consolidated_report() called from NEW instance during audit! This should only happen at the end.\")\n            else:\n                logger.warning(\"_generate_consolidated_report() called during audit! This should only happen at the end.\")\n            import traceback\n            logger.debug(f\"Call stack:\\n{''.join(traceback.format_stack())}\")\n\n        lines: List[str] = []\n\n        lines.append(\"# Comprehensive AI Development Tools Report\")\n        lines.append(\"\")\n        lines.append(\"> **Generated**: This file is auto-generated. Do not edit manually.\")\n        lines.append(f\"> **Last Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        # Determine source command based on audit tier\n        if self.current_audit_tier == 1:\n            source_cmd = \"python development_tools/run_development_tools.py audit --quick\"\n            tier_name = \"Tier 1 (Quick Audit)\"\n        elif self.current_audit_tier == 3:\n            source_cmd = \"python development_tools/run_development_tools.py audit --full\"\n            tier_name = \"Tier 3 (Full Audit)\"\n        elif self.current_audit_tier == 2:\n            source_cmd = \"python development_tools/run_development_tools.py audit\"\n            tier_name = \"Tier 2 (Standard Audit)\"\n        else:\n            source_cmd = \"python development_tools/run_development_tools.py status\"\n            tier_name = \"Status Check (cached data)\"\n        lines.append(f\"> **Source**: `{source_cmd}`\")\n        if self.current_audit_tier:\n            lines.append(f\"> **Last Audit Tier**: {tier_name}\")\n        lines.append(\"> **Generated by**: run_development_tools.py - AI Development Tools Runner\")\n        lines.append(\"\")\n\n        def percent_text(value: Any, decimals: int = 1) -> str:\n\n            if value is None:\n\n                return \"Unknown\"\n\n            if isinstance(value, str):\n\n                return value if value.strip().endswith('%') else f\"{value}%\"\n\n            return self._format_percentage(value, decimals)\n\n        def to_int(value: Any) -> Optional[int]:\n            if isinstance(value, int):\n                return value\n            if isinstance(value, float):\n                return int(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return int(float(stripped))\n                except ValueError:\n                    return None\n            if isinstance(value, dict):\n                count = value.get('count')\n                return to_int(count)\n            return None\n\n        def to_float(value: Any) -> Optional[float]:\n            if isinstance(value, (int, float)):\n                return float(value)\n            if isinstance(value, str):\n                stripped = value.strip().rstrip('%')\n                try:\n                    return float(stripped)\n                except ValueError:\n                    return None\n            return None\n\n        metrics = self._get_canonical_metrics()\n\n        # Load all tool data using unified loader (returns standard format)\n        doc_metrics = self._load_tool_data('analyze_function_registry', 'functions')\n        # Access doc_metrics - check details first (normalized), then top level (backward compat)\n        doc_metrics_details = doc_metrics.get('details', {})\n        doc_coverage = doc_metrics_details.get('doc_coverage') or doc_metrics.get('doc_coverage', metrics.get('doc_coverage'))\n        missing_docs_raw = doc_metrics_details.get('missing_docs') or doc_metrics_details.get('missing_items') or doc_metrics.get('missing_docs') or doc_metrics.get('missing_items')\n        # Extract count if missing_docs is a dictionary, otherwise use it as-is\n        if isinstance(missing_docs_raw, dict):\n            missing_docs_count = missing_docs_raw.get('count', 0)\n            missing_docs_list = missing_docs_raw.get('files', {})  # Dictionary of file -> list of functions\n        else:\n            missing_docs_count = to_int(missing_docs_raw) or 0\n            missing_docs_list = {}\n        doc_totals = doc_metrics_details.get('totals') or doc_metrics.get('totals') or {}\n        documented_functions = doc_totals.get('functions_documented') if isinstance(doc_totals, dict) else None\n\n        doc_sync_data = self._load_tool_data('analyze_documentation_sync', 'docs')\n        doc_sync_summary = self.docs_sync_summary or doc_sync_data or {}\n\n        # Load unused imports data using unified loader (returns standard format)\n        unused_imports_data = self._load_tool_data('analyze_unused_imports', 'imports')\n\n        # Load documentation analysis data using unified loader\n        analyze_docs_data = self._load_tool_data('analyze_documentation', 'docs')\n        # Load additional documentation analysis tools\n        ascii_data = self._load_tool_data('analyze_ascii_compliance', 'docs')\n        heading_data = self._load_tool_data('analyze_heading_numbering', 'docs')\n        missing_addresses_data = self._load_tool_data('analyze_missing_addresses', 'docs')\n        unconverted_links_data = self._load_tool_data('analyze_unconverted_links', 'docs')\n        \n        # Load function metrics (returns standard format)\n        function_metrics = self._load_tool_data('analyze_functions', 'functions')\n        # Access function_metrics - check details first (normalized), then top level (backward compat)\n        function_metrics_details = function_metrics.get('details', {})\n\n        doc_artifacts = analyze_docs_data.get('artifacts') if isinstance(analyze_docs_data, dict) else None\n        \n        # Extract overlap analysis data\n        # Check if overlap analysis was run (indicated by presence of these keys, even if empty)\n        # Check both top level and details section (normalization may move data to details)\n        details = analyze_docs_data.get('details', {})\n        overlap_analysis_ran = (\n            'section_overlaps' in analyze_docs_data or \n            'consolidation_recommendations' in analyze_docs_data or\n            'section_overlaps' in details or \n            'consolidation_recommendations' in details\n        )\n        \n        # Get from top level first, then fall back to details\n        section_overlaps = (\n            analyze_docs_data.get('section_overlaps') or \n            details.get('section_overlaps', {})\n        ) if overlap_analysis_ran else {}\n        consolidation_recs = (\n            analyze_docs_data.get('consolidation_recommendations') or \n            details.get('consolidation_recommendations', [])\n        ) if overlap_analysis_ran else []\n        file_purposes = (\n            analyze_docs_data.get('file_purposes') or \n            details.get('file_purposes', {})\n        )\n        \n        # Normalize to empty dict/list if None\n        if section_overlaps is None:\n            section_overlaps = {}\n        if consolidation_recs is None:\n            consolidation_recs = []\n\n        # Load error handling data using unified loader (returns standard format)\n        error_metrics = self._load_tool_data('analyze_error_handling', 'error_handling')\n        # Access standard format\n        error_summary = error_metrics.get('summary', {})\n        error_details = error_metrics.get('details', {})\n        missing_error_handlers = to_int(error_summary.get('total_issues'))\n        # Always check details as well, since normalization might have put it there\n        if missing_error_handlers is None:\n            missing_error_handlers = to_int(error_details.get('functions_missing_error_handling')) or 0\n        # Also check if details has it even if summary says 0 (data might be inconsistent)\n        details_missing = to_int(error_details.get('functions_missing_error_handling'))\n        if details_missing is not None and details_missing > 0 and (missing_error_handlers is None or missing_error_handlers == 0):\n            missing_error_handlers = details_missing\n        error_recommendations = error_details.get('recommendations') or []\n        worst_error_modules = error_details.get('worst_modules') or []\n        if worst_error_modules is None or not isinstance(worst_error_modules, (list, tuple)):\n            worst_error_modules = []\n\n        coverage_summary = self._load_coverage_summary()\n        \n        # Load dev tools coverage if not already loaded\n        if not hasattr(self, 'dev_tools_coverage_results') or not self.dev_tools_coverage_results:\n            self._load_dev_tools_coverage()\n\n        # Load legacy data using unified loader\n        legacy_data = self._load_tool_data('analyze_legacy_references', 'legacy')\n        legacy_summary = self.legacy_cleanup_summary or legacy_data or {}\n        if not legacy_summary and isinstance(legacy_data, dict):\n            legacy_summary = {\n                'files_with_issues': legacy_data.get('files_with_issues', 0),\n                'legacy_markers': legacy_data.get('legacy_markers', 0),\n                'report_path': legacy_data.get('report_path', 'development_docs/LEGACY_REFERENCE_REPORT.md')\n            }\n\n        # Load function metrics using unified loader, ensuring examples are included\n        function_metrics = self._load_tool_data('analyze_functions', 'functions')\n        # If examples are missing, reload to ensure we have them\n        if not function_metrics.get('critical_complexity_examples') and not function_metrics.get('high_complexity_examples'):\n            func_result = self._load_tool_data('analyze_functions', 'functions')\n            if func_result and isinstance(func_result, dict):\n                if 'critical_complexity_examples' in func_result:\n                    function_metrics['critical_complexity_examples'] = func_result.get('critical_complexity_examples', [])\n                if 'high_complexity_examples' in func_result:\n                    function_metrics['high_complexity_examples'] = func_result.get('high_complexity_examples', [])\n\n        decision_metrics = self.results_cache.get('decision_support_metrics', {}) or {}\n\n        # Load validation data using unified loader\n        validation_output = \"\"\n        if hasattr(self, 'validation_results') and self.validation_results:\n            validation_output = self.validation_results.get('output', '') or \"\"\n        else:\n            validation_data = self._load_tool_data('analyze_ai_work', 'ai_work')\n            if validation_data:\n                validation_output = validation_data.get('output', '') or ''\n\n        results_file = self.audit_config.get('results_file', 'development_tools/reports/analysis_detailed_results.json')\n\n        issues_file_str = self.audit_config.get('issues_file', 'development_tools/critical_issues.txt')\n        # Convert to Path object for .exists() check\n        issues_file = self.project_root / issues_file_str if isinstance(issues_file_str, str) else Path(issues_file_str)\n\n        # Load missing_docs data from cache if not already loaded\n        if missing_docs_count == 0 and missing_docs_list == {}:\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'analyze_function_registry' in cached_data['results']:\n                        func_reg_data = cached_data['results']['analyze_function_registry']\n                        if 'data' in func_reg_data:\n                            cached_metrics = func_reg_data['data']\n                            missing_docs_raw = cached_metrics.get('missing') or cached_metrics.get('missing_docs') or cached_metrics.get('missing_items')\n                            if missing_docs_raw:\n                                if isinstance(missing_docs_raw, dict):\n                                    missing_docs_count = missing_docs_raw.get('count', 0)\n                                    missing_docs_list = missing_docs_raw.get('files', {})\n                                else:\n                                    missing_docs_count = to_int(missing_docs_raw) or 0\n            except Exception as e:\n                logger.debug(f\"Failed to load registry missing data in consolidated report: {e}\")\n                pass\n        \n        # Recalculate doc_coverage if Unknown (same logic as Documentation Findings section)\n        # Do this BEFORE Executive Summary so it's available for display\n        if doc_coverage == 'Unknown' or doc_coverage is None:\n            # Use already loaded doc_metrics\n            audit_data = doc_metrics\n            audit_totals = audit_data.get('totals') if isinstance(audit_data, dict) else {}\n            if audit_totals is None or not isinstance(audit_totals, dict):\n                audit_totals = {}\n            documented = audit_totals.get('functions_documented', 0)\n            total_funcs = metrics.get('total_functions')\n            if total_funcs and isinstance(total_funcs, (int, float)) and total_funcs > 0 and documented > 0:\n                coverage_pct = (documented / total_funcs) * 100\n                if 0 <= coverage_pct <= 100:\n                    doc_coverage = f\"{coverage_pct:.2f}%\"\n\n        lines.append(\"## Executive Summary\")\n\n        # Get complexity metrics, trying multiple sources\n        total_funcs = metrics.get('total_functions', 'Unknown')\n        moderate = metrics.get('moderate', 'Unknown')\n        high = metrics.get('high', 'Unknown')\n        critical = metrics.get('critical', 'Unknown')\n        \n        # If still Unknown, try loading from analyze_functions or decision_support cache\n        if moderate == 'Unknown' or high == 'Unknown':\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    # Try analyze_functions first\n                    if 'results' in cached_data and 'analyze_functions' in cached_data['results']:\n                        func_data = cached_data['results']['analyze_functions']\n                        if 'data' in func_data:\n                            cached_metrics = func_data['data']\n                            if moderate == 'Unknown':\n                                moderate = cached_metrics.get('moderate_complexity', 'Unknown')\n                            if high == 'Unknown':\n                                high = cached_metrics.get('high_complexity', 'Unknown')\n                            if critical == 'Unknown':\n                                critical = cached_metrics.get('critical_complexity', 'Unknown')\n                            if total_funcs == 'Unknown':\n                                total_funcs = cached_metrics.get('total_functions', 'Unknown')\n                    # Fallback to decision_support\n                    if (moderate == 'Unknown' or high == 'Unknown') and 'results' in cached_data and 'decision_support' in cached_data['results']:\n                        ds_data = cached_data['results']['decision_support']\n                        if 'data' in ds_data and 'decision_support_metrics' in ds_data['data']:\n                            ds_metrics = ds_data['data']['decision_support_metrics']\n                            if moderate == 'Unknown':\n                                moderate = ds_metrics.get('moderate_complexity', 'Unknown')\n                            if high == 'Unknown':\n                                high = ds_metrics.get('high_complexity', 'Unknown')\n                            if critical == 'Unknown':\n                                critical = ds_metrics.get('critical_complexity', 'Unknown')\n                            if total_funcs == 'Unknown':\n                                total_funcs = ds_metrics.get('total_functions', 'Unknown')\n            except Exception as e:\n                logger.debug(f\"Failed to load complexity from cache in consolidated report: {e}\")\n                pass\n\n        # Add Total Functions to Executive Summary\n        if total_funcs == 'Unknown':\n            lines.append(\"- **Total Functions**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n        else:\n            # Order: Critical, High, Moderate (most critical first)\n            lines.append(f\"- **Total Functions**: {total_funcs} (Critical: {critical}, High: {high}, Moderate: {moderate})\")\n\n        # Docstring Coverage moved to its own section (removed from Executive Summary)\n        \n        # Add test markers to executive summary\n        test_markers_data = self._load_tool_data('analyze_test_markers', 'tests')\n        if test_markers_data and isinstance(test_markers_data, dict):\n            if 'summary' in test_markers_data:\n                missing_markers = test_markers_data['summary'].get('total_issues', 0)\n            else:\n                missing_markers = test_markers_data.get('missing_count', 0)\n            if missing_markers > 0:\n                lines.append(f\"- Test markers: {missing_markers} tests missing category markers\")\n\n        # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n        error_cov = error_metrics.get('analyze_error_handling') or error_metrics.get('error_handling_coverage')\n        \n        # Calculate error handling coverage using error_total (actual functions analyzed)\n        # Use the actual count from error analysis, not a recalculation\n        missing_error_handlers = to_int(error_metrics.get('functions_missing_error_handling', 0))\n        \n        # Calculate coverage using error_total (actual functions analyzed), not canonical_total\n        error_total = error_metrics.get('total_functions')\n        error_with_handling = error_metrics.get('functions_with_error_handling')\n        \n        if error_total and error_with_handling:\n            calc_coverage = (error_with_handling / error_total) * 100\n            if 0 <= calc_coverage <= 100:\n                error_cov = calc_coverage\n        elif error_cov is None and error_total and error_with_handling:\n            # If coverage not provided, calculate it\n            error_cov = (error_with_handling / error_total) * 100\n\n        if error_cov is not None:\n\n            lines.append(f\"- Error handling coverage {percent_text(error_cov, 1)}; {missing_error_handlers or 0} functions need protection\")\n\n        dev_tools_insights = self._get_dev_tools_coverage_insights()\n\n        if coverage_summary:\n\n            overall = coverage_summary.get('overall') or {}\n            overall_cov = overall.get('coverage')\n\n            lines.append(f\"- **Overall test coverage**: {percent_text(overall_cov, 1)} across {overall.get('statements', 0)} statements\")\n            \n            # Add development tools coverage summary (details appear in Test Coverage section)\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                summary_line = f\"- **Development tools coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_tools_insights.get('covered') is not None and dev_tools_insights.get('statements') is not None:\n                    summary_line += f\" ({dev_tools_insights['covered']} of {dev_tools_insights['statements']} statements)\"\n                lines.append(summary_line)\n                # Modules with Lowest Coverage removed from Executive Summary (detailed info in Test Coverage section)\n\n        elif hasattr(self, 'coverage_results') and self.coverage_results:\n\n            lines.append(\"- Coverage regeneration flagged issues; inspect coverage.json for details\")\n            # Add development tools coverage summary (details appear in Test Coverage section)\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                summary_line = f\"- **Development tools coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_tools_insights.get('covered') is not None and dev_tools_insights.get('statements') is not None:\n                    summary_line += f\" ({dev_tools_insights['covered']} of {dev_tools_insights['statements']} statements)\"\n                lines.append(summary_line)\n                # Modules with Lowest Coverage removed from Executive Summary (detailed info in Test Coverage section)\n        else:\n            # Add development tools coverage summary (details appear in Test Coverage section)\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                summary_line = f\"- **Development tools coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_tools_insights.get('covered') is not None and dev_tools_insights.get('statements') is not None:\n                    summary_line += f\" ({dev_tools_insights['covered']} of {dev_tools_insights['statements']} statements)\"\n                lines.append(summary_line)\n                # Modules with Lowest Coverage removed from Executive Summary (detailed info in Test Coverage section)\n\n        # Get path_drift - check standard format first\n        path_drift = None\n        if doc_sync_summary and isinstance(doc_sync_summary, dict):\n            if 'summary' in doc_sync_summary and isinstance(doc_sync_summary.get('summary'), dict):\n                # Standard format - check details\n                path_drift = doc_sync_summary.get('details', {}).get('path_drift_issues', 0)\n            else:\n                # Old format\n                path_drift = doc_sync_summary.get('path_drift_issues')\n\n        if path_drift is not None:\n\n            lines.append(f\"- **Documentation path drift**: {path_drift} issues need sync\")\n\n        # Get legacy_issues - check standard format first\n        legacy_issues = None\n        if legacy_summary and isinstance(legacy_summary, dict):\n            if 'summary' in legacy_summary and isinstance(legacy_summary.get('summary'), dict):\n                legacy_issues = legacy_summary['summary'].get('files_affected', 0)\n            else:\n                legacy_issues = legacy_summary.get('files_with_issues')\n\n        if legacy_issues is not None:\n\n            lines.append(f\"- **Legacy references**: {legacy_issues} files still reference legacy patterns\")\n\n        lines.append(\"\")\n\n        # Documentation Coverage section\n        lines.append(\"## Documentation Coverage\")\n        lines.append(f\"- **Docstring Coverage**: {percent_text(doc_coverage, 2)}\")\n        # Note: Docstring coverage measures functions with docstrings in code (from analyze_functions)\n        # Registry gaps measures functions missing from FUNCTION_REGISTRY_DETAIL.md (from analyze_function_registry)\n        # These are different metrics: a function can have a docstring but not be in the registry, or vice versa\n        \n        if missing_docs_count > 0:\n            lines.append(f\"- **Registry Gaps**: {missing_docs_count} items missing from registry\")\n            # Build list of top missing items\n            if missing_docs_list and isinstance(missing_docs_list, dict):\n                # Sort files by number of missing functions (descending)\n                sorted_files = sorted(\n                    missing_docs_list.items(), \n                    key=lambda x: len(x[1]) if isinstance(x[1], list) else 1, \n                    reverse=True\n                )[:5]\n                \n                if sorted_files:\n                    item_list = []\n                    for file_path, funcs in sorted_files:\n                        func_count = len(funcs) if isinstance(funcs, list) else 1\n                        file_name = Path(file_path).name if file_path else 'Unknown'\n                        if func_count == 1 and isinstance(funcs, list) and funcs:\n                            func_name = funcs[0] if funcs else 'Unknown'\n                            item_list.append(f\"{func_name} ({file_name})\")\n                        else:\n                            item_list.append(f\"{file_name} ({func_count} functions)\")\n                    \n                    if len(sorted_files) < len(missing_docs_list) if isinstance(missing_docs_list, dict) else False:\n                        total_files = len(missing_docs_list)\n                        item_list.append(f\"... +{total_files - len(sorted_files)} more\")\n                    \n                    if item_list:\n                        lines.append(f\"    - **Top items**: {', '.join(item_list)}\")\n        else:\n            lines.append(f\"- **Registry Gaps**: 0 items missing from registry\")\n        \n        lines.append(\"\")\n\n        # Documentation Status section (consolidated from Documentation Signals and Doc Sync Status)\n        lines.append(\"## Documentation Status\")\n        \n        # Use aggregated doc sync summary from current run first, then fall back to cache\n        doc_sync_summary_for_signals = None\n        if self.docs_sync_summary and isinstance(self.docs_sync_summary, dict):\n            # Use the aggregated summary from _run_doc_sync_check()\n            doc_sync_summary_for_signals = {\n                'status': self.docs_sync_summary.get('status', 'UNKNOWN'),\n                'path_drift_issues': self.docs_sync_summary.get('path_drift_issues', 0),\n                'paired_doc_issues': self.docs_sync_summary.get('paired_doc_issues', 0),\n                'ascii_issues': self.docs_sync_summary.get('ascii_issues', 0),\n                'heading_numbering_issues': self.docs_sync_summary.get('heading_numbering_issues', 0),\n                'missing_address_issues': self.docs_sync_summary.get('missing_address_issues', 0),\n                'unconverted_link_issues': self.docs_sync_summary.get('unconverted_link_issues', 0),\n                'path_drift_files': self.docs_sync_summary.get('path_drift_files', [])\n            }\n        \n        # Fall back to cache if not available in memory\n        if not doc_sync_summary_for_signals:\n            # Load doc sync data using unified loader\n            doc_sync_result = self._load_tool_data('analyze_documentation_sync', 'docs')\n            if doc_sync_result:\n                cached_metrics = doc_sync_result if isinstance(doc_sync_result, dict) else {}\n                doc_sync_summary_for_signals = {\n                    'status': cached_metrics.get('status', 'UNKNOWN'),\n                    'path_drift_issues': cached_metrics.get('path_drift_issues', 0),\n                    'paired_doc_issues': cached_metrics.get('paired_doc_issues', 0),\n                    'ascii_issues': cached_metrics.get('ascii_issues', 0),\n                    'path_drift_files': cached_metrics.get('path_drift_files', [])\n                }\n        \n        # Use doc_sync_summary if available, otherwise use doc_sync_summary_for_signals\n        effective_summary = doc_sync_summary if doc_sync_summary else doc_sync_summary_for_signals\n        \n        # Helper to extract doc sync field (handles both standard and old format)\n        def get_doc_sync_field(data, field_name, default=None):\n            if not data or not isinstance(data, dict):\n                return default\n            # Check standard format first\n            if 'summary' in data and isinstance(data.get('summary'), dict):\n                # Standard format - check details for specific fields, summary for status\n                if field_name == 'status':\n                    return data['summary'].get('status', default)\n                else:\n                    return data.get('details', {}).get(field_name, default)\n            else:\n                # Old format - direct access\n                return data.get(field_name, default)\n        \n        # Reformat Documentation Status to be more readable\n        # Note: Documentation Sync includes only path drift and paired docs\n        # ASCII, headings, missing addresses, unconverted links are separate documentation quality issues\n        if effective_summary:\n            # Path Drift\n            path_drift = get_doc_sync_field(effective_summary, 'path_drift_issues', 0)\n            if path_drift is None:\n                path_drift = 0\n            if path_drift > 0:\n                drift_files = get_doc_sync_field(effective_summary, 'path_drift_files', [])\n                if not isinstance(drift_files, list):\n                    drift_files = []\n                lines.append(\"**Path Drift** FAIL\")\n                lines.append(f\"  - {path_drift} problem files (total issues)\")\n                # Show up to 4 files, with correct overflow count based on total path_drift count\n                if len(drift_files) <= 4:\n                    drift_hotspots = ', '.join(drift_files)\n                else:\n                    visible = ', '.join(drift_files[:4])\n                    remaining = path_drift - 4  # Use total path_drift count, not just len(drift_files)\n                    drift_hotspots = f\"{visible}, ... +{remaining}\"\n                lines.append(f\"  - Top files: {drift_hotspots}\")\n            else:\n                lines.append(\"**Path Drift** CLEAN\")\n                lines.append(\"  - 0 problem files\")\n            \n            # Paired Docs\n            paired = get_doc_sync_field(effective_summary, 'paired_doc_issues', 0) or 0\n            if paired == 0:\n                lines.append(\"**Paired Docs** CLEAN\")\n                lines.append(\"  - 0 H2 mismatches\")\n            else:\n                lines.append(\"**Paired Docs** FAIL\")\n                lines.append(f\"  - {paired} H2 mismatches\")\n            \n            # Helper function to extract file paths with issue counts from tool data\n            def extract_files_with_issue_counts(tool_data):\n                \"\"\"Extract file paths with their issue counts from tool data. Handles both standard and old formats.\"\"\"\n                if not tool_data or not isinstance(tool_data, dict):\n                    return {}\n                \n                file_counts = {}\n                \n                # Handle standard format: { \"summary\": {...}, \"files\": {...}, \"details\": {...} }\n                if 'files' in tool_data:\n                    files_dict = tool_data.get('files', {})\n                    if isinstance(files_dict, dict):\n                        for file_path, value in files_dict.items():\n                            if isinstance(file_path, str):\n                                # value can be issue count (int) or dict with results\n                                if isinstance(value, (int, float)):\n                                    file_counts[file_path] = int(value)\n                                elif isinstance(value, dict):\n                                    results = value.get('results', [])\n                                    if isinstance(results, list):\n                                        file_counts[file_path] = len(results)\n                                    else:\n                                        file_counts[file_path] = 1\n                \n                # Handle old format: { \"files\": {...}, \"file_count\": 0, \"total_issues\": 0 }\n                # (same as above, but also check for old format fields)\n                if not file_counts and 'files' in tool_data:\n                    files_dict = tool_data.get('files', {})\n                    if isinstance(files_dict, dict):\n                        for file_path, value in files_dict.items():\n                            if isinstance(file_path, str) and isinstance(value, (int, float)):\n                                file_counts[file_path] = int(value)\n                \n                # Handle cache format: { \"file_path\": { \"mtime\": ..., \"results\": [...] } }\n                # Or wrapped in 'data': { \"data\": { \"file_path\": {...} } }\n                if not file_counts:\n                    data_dict = tool_data.get('data', tool_data) if 'data' in tool_data else tool_data\n                    if isinstance(data_dict, dict):\n                        for f, v in data_dict.items():\n                            if isinstance(f, str) and isinstance(v, dict):\n                                results = v.get('results', [])\n                                if isinstance(results, list) and len(results) > 0:\n                                    file_counts[f] = len(results)\n                \n                return file_counts\n            \n            # Helper function to extract file paths from tool data (handles both cache and results formats)\n            def extract_files_with_issues(tool_data):\n                \"\"\"Extract file paths that have issues from tool data.\"\"\"\n                file_counts = extract_files_with_issue_counts(tool_data)\n                return list(file_counts.keys())\n            \n            # Helper function to get issue count from tool data or summary\n            def get_issue_count(summary_key, tool_data, default=0):\n                \"\"\"Get issue count from summary, or calculate from tool data if not in summary. Handles both standard and old formats.\"\"\"\n                # Check effective_summary first (for doc_sync aggregated data)\n                count = 0\n                if effective_summary:\n                    # Check if effective_summary is in standard format\n                    if 'summary' in effective_summary and isinstance(effective_summary.get('summary'), dict):\n                        # Standard format - check details for the specific field\n                        count = effective_summary.get('details', {}).get(summary_key, 0)\n                    else:\n                        # Old format - direct access\n                        count = effective_summary.get(summary_key, 0)\n                \n                # If not found in summary, try tool_data (standard format first)\n                if count == 0 and tool_data and isinstance(tool_data, dict):\n                    # Check standard format\n                    if 'summary' in tool_data and isinstance(tool_data.get('summary'), dict):\n                        count = tool_data['summary'].get('total_issues', 0)\n                    # Fall back to old format\n                    elif 'total_issues' in tool_data:\n                        count = tool_data.get('total_issues', 0)\n                    elif 'files' in tool_data:\n                        files_dict = tool_data.get('files', {})\n                        if isinstance(files_dict, dict):\n                            # Sum up issue counts if files dict has counts\n                            count = sum(v if isinstance(v, (int, float)) else 1 for v in files_dict.values())\n                    else:\n                        # Try cache format: count files with non-empty results\n                        data_dict = tool_data.get('data', tool_data) if 'data' in tool_data else tool_data\n                        if isinstance(data_dict, dict):\n                            total = 0\n                            for f, v in data_dict.items():\n                                if isinstance(v, dict):\n                                    results = v.get('results', [])\n                                    if isinstance(results, list) and len(results) > 0:\n                                        total += len(results)\n                            if total > 0:\n                                count = total\n                return count if count > 0 else default\n            \n            # ASCII Compliance\n            ascii_issues = get_issue_count('ascii_issues', ascii_data)\n            if ascii_issues > 0:\n                ascii_file_counts = extract_files_with_issue_counts(ascii_data)\n                # Get file count from standard format or old format\n                if ascii_data and isinstance(ascii_data, dict):\n                    if 'summary' in ascii_data:\n                        file_count = ascii_data['summary'].get('files_affected', 0)\n                    else:\n                        file_count = ascii_data.get('file_count', 0)\n                else:\n                    file_count = len(ascii_file_counts)\n                if file_count == 0:\n                    file_count = len(ascii_file_counts)\n                lines.append(\"**ASCII Compliance** FAIL\")\n                lines.append(f\"  - {file_count} files with {ascii_issues} total issues\")\n                if ascii_file_counts:\n                    sorted_files = sorted(ascii_file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{file_path} ({count})\" for file_path, count in sorted_files]\n                    if len(ascii_file_counts) > 5:\n                        file_list.append(f\"... +{len(ascii_file_counts) - 5}\")\n                    lines.append(f\"  - Top files: {', '.join(file_list)}\")\n            else:\n                lines.append(\"**ASCII Compliance** CLEAN\")\n                lines.append(\"  - 0 files with issues\")\n            \n            # Heading Numbering\n            heading_issues = get_issue_count('heading_numbering_issues', heading_data)\n            if heading_issues > 0:\n                heading_file_counts = extract_files_with_issue_counts(heading_data)\n                # Get file count from standard format or old format\n                if heading_data and isinstance(heading_data, dict):\n                    if 'summary' in heading_data:\n                        file_count = heading_data['summary'].get('files_affected', 0)\n                    else:\n                        file_count = heading_data.get('file_count', 0)\n                else:\n                    file_count = len(heading_file_counts)\n                if file_count == 0:\n                    file_count = len(heading_file_counts)\n                lines.append(\"**Heading Numbering** FAIL\")\n                lines.append(f\"  - {file_count} files with {heading_issues} total issues\")\n                if heading_file_counts:\n                    sorted_files = sorted(heading_file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{file_path} ({count})\" for file_path, count in sorted_files]\n                    if len(heading_file_counts) > 5:\n                        file_list.append(f\"... +{len(heading_file_counts) - 5}\")\n                    lines.append(f\"  - Top files: {', '.join(file_list)}\")\n            else:\n                lines.append(\"**Heading Numbering** CLEAN\")\n                lines.append(\"  - 0 files with issues\")\n            \n            # Missing Addresses\n            missing_address_issues = get_issue_count('missing_address_issues', missing_addresses_data)\n            if missing_address_issues > 0:\n                missing_file_counts = extract_files_with_issue_counts(missing_addresses_data)\n                # Get file count from standard format or old format\n                if missing_addresses_data and isinstance(missing_addresses_data, dict):\n                    if 'summary' in missing_addresses_data:\n                        file_count = missing_addresses_data['summary'].get('files_affected', 0)\n                    else:\n                        file_count = missing_addresses_data.get('file_count', 0)\n                else:\n                    file_count = len(missing_file_counts)\n                if file_count == 0:\n                    file_count = len(missing_file_counts)\n                lines.append(\"**Missing Addresses** FAIL\")\n                lines.append(f\"  - {file_count} files with {missing_address_issues} total documentation missing addresses\")\n                if missing_file_counts:\n                    sorted_files = sorted(missing_file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{file_path} ({count})\" for file_path, count in sorted_files]\n                    if len(missing_file_counts) > 5:\n                        file_list.append(f\"... +{len(missing_file_counts) - 5}\")\n                    lines.append(f\"  - Top files: {', '.join(file_list)}\")\n            else:\n                lines.append(\"**Missing Addresses** CLEAN\")\n                lines.append(\"  - 0 files with missing addresses\")\n            \n            # Unconverted Links\n            unconverted_link_issues = get_issue_count('unconverted_link_issues', unconverted_links_data)\n            if unconverted_link_issues > 0:\n                unconverted_file_counts = extract_files_with_issue_counts(unconverted_links_data)\n                # Get file count from standard format or old format\n                if unconverted_links_data and isinstance(unconverted_links_data, dict):\n                    if 'summary' in unconverted_links_data:\n                        file_count = unconverted_links_data['summary'].get('files_affected', 0)\n                    else:\n                        file_count = unconverted_links_data.get('file_count', 0)\n                else:\n                    file_count = len(unconverted_file_counts)\n                if file_count == 0:\n                    file_count = len(unconverted_file_counts)\n                lines.append(\"**Unconverted Links** FAIL\")\n                lines.append(f\"  - {file_count} files with {unconverted_link_issues} total issues\")\n                if unconverted_file_counts:\n                    sorted_files = sorted(unconverted_file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{file_path} ({count})\" for file_path, count in sorted_files]\n                    if len(unconverted_file_counts) > 5:\n                        file_list.append(f\"... +{len(unconverted_file_counts) - 5}\")\n                    lines.append(f\"  - Top files: {', '.join(file_list)}\")\n            else:\n                lines.append(\"**Unconverted Links** CLEAN\")\n                lines.append(\"  - 0 files with unconverted links\")\n            \n            # Dependency Documentation\n            dependency_summary = None\n            if hasattr(self, 'module_dependency_summary') and self.module_dependency_summary:\n                dependency_summary = self.module_dependency_summary\n            elif hasattr(self, 'results_cache') and self.results_cache:\n                dependency_summary = self.results_cache.get('analyze_module_dependencies')\n            if not dependency_summary:\n                dependency_data = self._load_tool_data('analyze_module_dependencies', 'imports')\n                if dependency_data and isinstance(dependency_data, dict):\n                    dependency_summary = dependency_data\n            \n            missing_deps = dependency_summary.get('missing_dependencies') if dependency_summary else None\n            if missing_deps:\n                lines.append(\"**Dependency Documentation** FAIL\")\n                missing_files = dependency_summary.get('missing_files') or dependency_summary.get('missing_sections') or []\n                file_count = len(missing_files) if missing_files else missing_deps\n                lines.append(f\"  - {file_count} files with {missing_deps} total undocumented references detected\")\n                if missing_files:\n                    file_list = []\n                    for i, file_path in enumerate(missing_files[:5]):\n                        file_list.append(f\"{file_path} (1)\")\n                    if len(missing_files) > 5:\n                        file_list.append(f\"... +{len(missing_files) - 5}\")\n                    lines.append(f\"  - Top files: {', '.join(file_list)}\")\n            else:\n                lines.append(\"**Dependency Documentation** CLEAN\")\n                lines.append(\"  - 0 undocumented references\")\n            \n            # TODO.md Status\n            todo_sync_result = getattr(self, 'todo_sync_result', None)\n            if todo_sync_result and isinstance(todo_sync_result, dict):\n                entries = todo_sync_result.get('entries', [])\n                completed_entries = todo_sync_result.get('completed_entries', [])\n                \n                if (entries and isinstance(entries, list) and len(entries) > 0) or (completed_entries and len(completed_entries) > 0):\n                    entry_count = len(entries) if entries else len(completed_entries)\n                    lines.append(\"**TODO.md Status** FAIL\")\n                    lines.append(f\"  - {entry_count} completed entries detected\")\n                else:\n                    lines.append(\"**TODO.md Status** CLEAN\")\n                    lines.append(\"  - 0 completed entries detected\")\n            else:\n                lines.append(\"**TODO.md Status** CLEAN\")\n                lines.append(\"  - 0 completed entries detected\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Documentation Overlap\")\n        overlap_count = len(section_overlaps) if section_overlaps else 0\n        consolidation_count = len(consolidation_recs) if consolidation_recs else 0\n        \n        if overlap_count > 0 or consolidation_count > 0:\n            if section_overlaps and overlap_count > 0:\n                lines.append(f\"- **Section Overlaps**: {overlap_count} sections duplicated across files\")\n                # Show first few overlaps\n                top_overlaps = sorted(section_overlaps.items(), key=lambda x: len(x[1]), reverse=True)[:3]\n                for section, files in top_overlaps:\n                    lines.append(f\"  - `{section}` appears in: {', '.join(files[:3])}{'...' if len(files) > 3 else ''}\")\n            # Consolidation opportunities moved to AI_PRIORITIES (not shown in AI_STATUS)\n            if consolidation_recs:\n                lines.append(f\"- **Consolidation Opportunities**: {consolidation_count} file groups identified for potential consolidation\")\n                for rec in consolidation_recs[:3]:  # Show top 3 recommendations\n                    category = rec.get('category', 'Unknown')\n                    files = rec.get('files', [])\n                    suggestion = rec.get('suggestion', '')\n                    if files:\n                        lines.append(f\"  - {category}: {len(files)} files ({', '.join(files[:2])}{'...' if len(files) > 2 else ''}) - {suggestion}\")\n        else:\n            if overlap_analysis_ran:\n                lines.append(\"- **Status**: No overlaps detected (analysis performed)\")\n                lines.append(\"  - Overlap analysis ran but found no section overlaps or consolidation opportunities\")\n            else:\n                lines.append(\"- **Status**: Overlap analysis not run (use `audit --full` or `--overlap` flag)\")\n                lines.append(\"  - Standard audits skip overlap analysis by default; run `audit --full` or use `--overlap` flag to include it\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Error Handling\")\n\n        if error_metrics and isinstance(error_metrics, dict):\n            # Use recalculated error_cov from Executive Summary section (already calculated above)\n            # If not recalculated, get from error_metrics\n            if 'error_cov' not in locals() or error_cov is None:\n                # Access standard format\n                error_summary = error_metrics.get('summary', {})\n                error_details = error_metrics.get('details', {})\n                # NOTE: 'error_handling_coverage' is a backward compatibility fallback for old JSON format\n                error_cov = error_details.get('analyze_error_handling') or error_details.get('error_handling_coverage') or error_metrics.get('analyze_error_handling') or error_metrics.get('error_handling_coverage')\n                # Use standard format summary for total issues (missing error handlers)\n                missing_error_handlers = to_int(error_summary.get('total_issues'))\n                # Always check details as well, since normalization might have put it there\n                if missing_error_handlers is None:\n                    missing_error_handlers = to_int(error_details.get('functions_missing_error_handling')) or to_int(error_metrics.get('functions_missing_error_handling')) or 0\n                # Also check if details has it even if summary says 0 (data might be inconsistent)\n                details_missing = to_int(error_details.get('functions_missing_error_handling'))\n                if details_missing is not None and details_missing > 0 and (missing_error_handlers is None or missing_error_handlers == 0):\n                    missing_error_handlers = details_missing\n                \n                # Calculate coverage using error_total (actual functions analyzed), not canonical_total\n                error_total = error_metrics.get('total_functions')\n                error_with_handling = error_metrics.get('functions_with_error_handling')\n                if error_total and error_with_handling:\n                    calc_coverage = (error_with_handling / error_total) * 100\n                    if 0 <= calc_coverage <= 100:\n                        error_cov = calc_coverage\n                elif error_cov is None and error_total and error_with_handling:\n                    # If coverage not provided, calculate it\n                    error_cov = (error_with_handling / error_total) * 100\n\n            # Add Missing Error Handling (same as AI_STATUS.md) - this should be first\n            if missing_error_handlers is None:\n                missing_error_handlers = 0\n            lines.append(f\"- **Missing Error Handling**: {missing_error_handlers} functions lack protections\")\n            \n            # Add top candidate modules for missing error handling\n            if worst_error_modules:\n                module_summaries = []\n                # Filter out 100% modules (missing 0) - they don't need attention\n                modules_needing_attention = [\n                    m for m in worst_error_modules[:3] \n                    if m.get('missing', 0) > 0 and m.get('coverage', 100) < 100\n                ]\n                \n                for module in modules_needing_attention:\n                    module_name = module.get('module', 'Unknown')\n                    coverage_pct = percent_text(module.get('coverage'), 1)\n                    missing = module.get('missing')\n                    total = module.get('total')\n                    detail = f\"{module_name} ({coverage_pct}\"\n                    if missing is not None and total is not None:\n                        detail += f\", missing {missing}/{total}\"\n                    detail += \")\"\n                    module_summaries.append(detail)\n                \n                if module_summaries:\n                    lines.append(f\"  - Top candidate modules: {', '.join(module_summaries)}\")\n            \n            # Access error metrics - check details first (normalized), then top level (backward compat)\n            error_details = error_metrics.get('details', {})\n            def get_error_field(field_name, default=None):\n                return error_details.get(field_name, error_metrics.get(field_name, default))\n            \n            # Add @handle_errors Usage (same as AI_STATUS.md)\n            decorated = get_error_field('functions_with_decorators')\n            if decorated is not None:\n                lines.append(f\"- **@handle_errors Usage**: {decorated} functions already use the decorator\")\n\n            # Phase 1: Decorator replacement candidates (enhanced for consolidated report)\n            phase1_total = get_error_field('phase1_total', 0)\n\n            if phase1_total > 0:\n\n                phase1_by_priority = get_error_field('phase1_by_priority', {}) or {}\n                if not isinstance(phase1_by_priority, dict):\n                    phase1_by_priority = {}\n\n                priority_breakdown = []\n\n                if phase1_by_priority.get('high', 0) > 0:\n\n                    priority_breakdown.append(f\"{phase1_by_priority['high']} high\")\n\n                if phase1_by_priority.get('medium', 0) > 0:\n\n                    priority_breakdown.append(f\"{phase1_by_priority['medium']} medium\")\n\n                if phase1_by_priority.get('low', 0) > 0:\n\n                    priority_breakdown.append(f\"{phase1_by_priority['low']} low\")\n\n                priority_text = ', '.join(priority_breakdown) if priority_breakdown else '0'\n\n                lines.append(f\"- **Phase 1 Candidates**: {phase1_total} functions with basic try-except blocks need decorator replacement ({priority_text} priority)\")\n                \n                # Group by module and show top modules\n                phase1_candidates = get_error_field('phase1_candidates', []) or []\n                if not isinstance(phase1_candidates, list):\n                    phase1_candidates = []\n                if phase1_candidates:\n                    from collections import defaultdict\n                    by_module = defaultdict(int)\n                    \n                    for candidate in phase1_candidates:\n                        if isinstance(candidate, dict):\n                            file_path = candidate.get('file_path', '')\n                            if file_path:\n                                # Extract module name (file path without extension)\n                                module = Path(file_path).name\n                                by_module[module] += 1\n                    \n                    if by_module:\n                        top_modules = sorted(by_module.items(), key=lambda x: x[1], reverse=True)[:3]\n                        module_list = [f\"{module} ({count})\" for module, count in top_modules]\n                        if len(by_module) > 3:\n                            module_list.append(f\"... +{len(by_module) - 3}\")\n                        lines.append(f\"  - Top candidate modules with function counts: {', '.join(module_list)}\")\n\n            # Phase 2: Generic exception categorization (enhanced for consolidated report)\n            phase2_total = get_error_field('phase2_total', 0)\n\n            if phase2_total > 0:\n\n                phase2_by_type = get_error_field('phase2_by_type', {}) or {}\n                if not isinstance(phase2_by_type, dict):\n                    phase2_by_type = {}\n\n                type_breakdown = [f\"{count} {exc_type}\" for exc_type, count in sorted(phase2_by_type.items(), key=lambda x: x[1], reverse=True)[:3]]\n\n                type_text = ', '.join(type_breakdown) if type_breakdown else '0'\n\n                if len(phase2_by_type) > 3:\n\n                    type_text += f\", ... +{len(phase2_by_type) - 3} more\"\n\n                lines.append(f\"- **Phase 2 Exceptions**: {phase2_total} generic exception raises need categorization ({type_text})\")\n                \n                # Group by module and show top modules with exception types\n                phase2_exceptions = get_error_field('phase2_exceptions', []) or []\n                if not isinstance(phase2_exceptions, list):\n                    phase2_exceptions = []\n                if phase2_exceptions:\n                    from collections import defaultdict\n                    by_module = defaultdict(lambda: defaultdict(int))\n                    \n                    for exc in phase2_exceptions:\n                        if isinstance(exc, dict):\n                            file_path = exc.get('file_path', '')\n                            exc_type = exc.get('exception_type', 'Unknown')\n                            if file_path:\n                                module = Path(file_path).name\n                                by_module[module][exc_type] += 1\n                    \n                    if by_module:\n                        # Format: module_name (count ExceptionType)\n                        module_list = []\n                        for module, exc_types in sorted(by_module.items(), key=lambda x: sum(x[1].values()), reverse=True)[:3]:\n                            exc_details = [f\"{count} {exc_type}\" for exc_type, count in sorted(exc_types.items(), key=lambda x: x[1], reverse=True)]\n                            module_list.append(f\"{module} ({', '.join(exc_details)})\")\n                        \n                        if len(by_module) > 3:\n                            module_list.append(f\"... +{len(by_module) - 3}\")\n                        lines.append(f\"  - Top candidate modules with function counts and exception types: {', '.join(module_list)}\")\n\n\n        else:\n\n            lines.append(\"- **Error Handling**: Run `python development_tools/run_development_tools.py audit` for detailed metrics\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Test Coverage\")\n        \n        if coverage_summary and isinstance(coverage_summary, dict):\n            overall = coverage_summary.get('overall') or {}\n            lines.append(f\"- **Overall Coverage**: {percent_text(overall.get('coverage'), 1)} ({overall.get('covered')} of {overall.get('statements')} statements)\")\n\n            # Add Domains with Lowest Coverage (same as AI_STATUS.md) - show domains below 80%\n            domain_gaps = []\n            for m in (coverage_summary.get('modules') or []):\n                coverage_val = m.get('coverage', 100)\n                if isinstance(coverage_val, str):\n                    coverage_val = to_float(coverage_val) or 100\n                elif not isinstance(coverage_val, (int, float)):\n                    coverage_val = 100\n                if coverage_val < 80:  # Show domains below 80% target\n                    domain_gaps.append(m)\n            \n            if domain_gaps:\n                domain_descriptions = [\n                    f\"{m['module']} ({percent_text(m.get('coverage'), 1)}, missing {m.get('missed')} lines)\"\n                    for m in domain_gaps[:5]\n                ]\n                lines.append(f\"    - **Domains with Lowest Coverage**: {', '.join(domain_descriptions)}\")\n\n            # Modules with Lowest Coverage should show individual files, not domains\n            worst_files = (coverage_summary or {}).get('worst_files') or []\n\n            if worst_files:\n                file_descriptions = [\n                    f\"{item['path']} ({percent_text(item.get('coverage'), 1)}, missing {item.get('missing', item.get('missed', 0))} lines)\"\n                    for item in worst_files[:5]\n                ]\n                lines.append(f\"    - **Modules with Lowest Coverage**: {', '.join(file_descriptions)}\")\n                lines.append(f\"    - **Detailed Report**: [TEST_COVERAGE_REPORT.md](development_docs/TEST_COVERAGE_REPORT.md)\")\n            \n            # Add development tools coverage\n            dev_tools_insights = self._get_dev_tools_coverage_insights()\n            if dev_tools_insights and dev_tools_insights.get('overall_pct') is not None:\n                dev_pct = dev_tools_insights['overall_pct']\n                dev_statements = dev_tools_insights.get('statements')\n                dev_covered = dev_tools_insights.get('covered')\n                summary_line = f\"- **Development Tools Coverage**: {percent_text(dev_pct, 1)}\"\n                if dev_statements is not None and dev_covered is not None:\n                    summary_line += f\" ({dev_covered} of {dev_statements} statements)\"\n                lines.append(summary_line)\n                low_modules = dev_tools_insights.get('low_modules') or []\n                if low_modules:\n                    dev_descriptions = [\n                        f\"{Path(item['path']).name} ({percent_text(item.get('coverage'), 1)}, missing {item.get('missed')} lines)\"\n                        for item in low_modules[:5]\n                    ]\n                    lines.append(f\"    - **Modules with Lowest Coverage**: {', '.join(dev_descriptions)}\")\n            \n            # Add test markers status\n            test_markers_data = self._load_tool_data('analyze_test_markers', 'tests')\n            if test_markers_data and isinstance(test_markers_data, dict):\n                # Handle both standard format and old format\n                if 'summary' in test_markers_data:\n                    summary = test_markers_data.get('summary', {})\n                    missing_count = summary.get('total_issues', 0)\n                    details = test_markers_data.get('details', {})\n                    missing_list = details.get('missing', [])\n                else:\n                    # Old format\n                    missing_count = test_markers_data.get('missing_count', 0)\n                    missing_list = test_markers_data.get('missing', [])\n                \n                if missing_count > 0 or (missing_list and len(missing_list) > 0):\n                    lines.append(\"## Test Markers\")\n                    # Use len(missing_list) if missing_count is 0 but list has items\n                    actual_count = missing_count if missing_count > 0 else len(missing_list) if missing_list else 0\n                    lines.append(f\"- **Missing Category Markers**: {actual_count} tests missing pytest category markers\")\n                    # Group by file\n                    from collections import defaultdict\n                    files_with_missing = defaultdict(list)\n                    for item in missing_list:\n                        if isinstance(item, dict):\n                            file_path = item.get('file', '')\n                            test_name = item.get('name', '')\n                            if file_path:\n                                files_with_missing[file_path].append(test_name)\n                    \n                    if files_with_missing:\n                        sorted_files = sorted(files_with_missing.items(), key=lambda x: len(x[1]), reverse=True)[:5]\n                        file_list = [f\"{Path(f).name} ({len(tests)} tests)\" for f, tests in sorted_files]\n                        if len(files_with_missing) > 5:\n                            file_list.append(f\"... +{len(files_with_missing) - 5} files\")\n                        lines.append(f\"    - **Top files**: {', '.join(file_list)}\")\n                else:\n                    lines.append(\"## Test Markers\")\n                    lines.append(\"- **Status**: CLEAN (all tests have category markers)\")\n\n            generated = overall.get('generated')\n\n            if generated:\n                pass  # Generated timestamp available\n\n        elif hasattr(self, 'coverage_results') and self.coverage_results:\n\n            lines.append(\"- Coverage regeneration completed with issues; inspect coverage.json for gap details\")\n\n        else:\n\n            lines.append(\"- Run `audit --full` to regenerate coverage metrics\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Unused Imports\")\n\n        # Unused imports data already loaded at top of method using unified loader (returns standard format)\n        if unused_imports_data:\n            # Access standard format\n            summary = unused_imports_data.get('summary', {})\n            details = unused_imports_data.get('details', {})\n            total_unused = summary.get('total_issues', 0) or unused_imports_data.get('total_unused', 0)\n            files_with_issues = summary.get('files_affected', 0) or unused_imports_data.get('files_with_issues', 0)\n            if total_unused > 0 or files_with_issues > 0:\n                lines.append(f\"- **Total Unused**: {total_unused} imports across {files_with_issues} files\")\n                by_category = details.get('by_category') or unused_imports_data.get('by_category') or {}\n                obvious = by_category.get('obvious_unused')\n                if obvious:\n                    lines.append(f\"    - **Obvious Removals**: {obvious} imports\")\n                type_only = by_category.get('type_hints_only')\n                if type_only:\n                    lines.append(f\"    - **Type-Only Imports**: {type_only} imports\")\n                \n                # Add top files with unused imports\n                # Load from cache file which has file-level data\n                from collections import defaultdict\n                import json\n                file_counts = defaultdict(int)\n                \n                # Try to load from cache file (check both possible locations)\n                cache_file = self.project_root / \"development_tools\" / \"imports\" / \"jsons\" / \".analyze_unused_imports_cache.json\"\n                if not cache_file.exists():\n                    # Try legacy location\n                    cache_file = self.project_root / \"development_tools\" / \"imports\" / \".analyze_unused_imports_cache.json\"\n                \n                if cache_file.exists():\n                    try:\n                        with open(cache_file, 'r', encoding='utf-8') as f:\n                            cache_data = json.load(f)\n                        # Cache structure: { \"data\": { \"file_path\": { \"mtime\": ..., \"results\": [...] } } }\n                        # Or direct: { \"file_path\": { \"mtime\": ..., \"results\": [...] } }\n                        if 'data' in cache_data and isinstance(cache_data['data'], dict):\n                            cache_data = cache_data['data']\n                        \n                        for file_path, file_data in cache_data.items():\n                            if isinstance(file_data, dict):\n                                results = file_data.get('results', [])\n                                if isinstance(results, list) and len(results) > 0:\n                                    file_counts[file_path] = len(results)\n                    except Exception:\n                        pass\n                \n                if file_counts:\n                    # Sort by count (descending) and show top 5\n                    sorted_files = sorted(file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{Path(f).name} ({count})\" for f, count in sorted_files]\n                    # Use the actual number of files with issues from the summary, not the cache count\n                    # (cache may include files with 0 unused imports)\n                    # Get files_with_issues from standard format or old format\n                    if unused_imports_data and isinstance(unused_imports_data, dict):\n                        summary = unused_imports_data.get('summary', {})\n                        total_files_with_issues = summary.get('files_affected', 0) or unused_imports_data.get('files_with_issues', len(file_counts))\n                    else:\n                        total_files_with_issues = len(file_counts)\n                    if total_files_with_issues > 5:\n                        file_list.append(f\"... +{total_files_with_issues - 5}\")\n                    lines.append(f\"    - **Top files**: {', '.join(file_list)}\")\n                \n                report_path = self.project_root / 'development_docs' / 'UNUSED_IMPORTS_REPORT.md'\n                # Ensure report_path is a Path object before calling .exists()\n                if isinstance(report_path, Path) and report_path.exists():\n                    rel_path = report_path.relative_to(self.project_root)\n                    lines.append(f\"- **Detailed Report**: [UNUSED_IMPORTS_REPORT.md]({rel_path.as_posix()})\")\n            else:\n                lines.append(\"- **Unused Imports**: CLEAN (no unused imports detected)\")\n        else:\n            lines.append(\"- **Unused Imports**: Data unavailable (run `audit --full` for latest scan)\")\n\n        lines.append(\"\")\n\n        # Legacy References section (renamed from Legacy & Code Hygiene)\n        lines.append(\"## Legacy References\")\n\n        # Legacy data already loaded at top of method using unified loader\n        # If legacy_summary is still empty, try to extract from legacy_data\n        if not legacy_summary and legacy_data:\n            if isinstance(legacy_data, dict):\n                # Calculate files_with_issues from findings structure\n                findings = legacy_data.get('findings', {})\n                if findings:\n                    # Count total files across all pattern types\n                    total_files = sum(len(file_list) for file_list in findings.values())\n                    # Count total markers (matches) across all files\n                    total_markers = 0\n                    for pattern_type, file_list in findings.items():\n                        for file_entry in file_list:\n                            # file_entry is [file_path, content, matches]\n                            if len(file_entry) >= 3:\n                                matches = file_entry[2]\n                                if isinstance(matches, list):\n                                    total_markers += len(matches)\n                    \n                    legacy_issues = legacy_data.get('files_with_issues') or total_files\n                    legacy_markers = legacy_data.get('legacy_markers') or total_markers\n                else:\n                    # Fallback to direct values if findings not present\n                    legacy_issues = legacy_data.get('files_with_issues') or 0\n                    legacy_markers = legacy_data.get('legacy_markers') or 0\n                \n                report_path = legacy_data.get('report_path') or 'development_docs/LEGACY_REFERENCE_REPORT.md'\n                if legacy_issues is not None:\n                    legacy_summary = {\n                        'files_with_issues': legacy_issues,\n                        'legacy_markers': legacy_markers,\n                        'report_path': report_path,\n                        'findings': findings  # Keep findings for top files list\n                    }\n\n        if legacy_summary:\n            # Check standard format first\n            if 'summary' in legacy_summary and isinstance(legacy_summary.get('summary'), dict):\n                # Standard format\n                legacy_issues = legacy_summary['summary'].get('files_affected', 0)\n                details = legacy_summary.get('details', {})\n                legacy_markers = details.get('legacy_markers', 0)\n                findings = details.get('findings', {})\n            else:\n                # Old format\n                legacy_issues = legacy_summary.get('files_with_issues')\n                legacy_markers = legacy_summary.get('legacy_markers')\n                findings = legacy_summary.get('findings', {})\n            \n            if legacy_issues is not None:\n                lines.append(f\"- **Files with Legacy Markers**: {legacy_issues}\")\n            else:\n                lines.append(\"- **Files with Legacy Markers**: Unknown\")\n            \n            if legacy_markers is not None:\n                lines.append(f\"- **Markers Found**: {legacy_markers}\")\n            else:\n                lines.append(\"- **Markers Found**: Unknown\")\n            \n            # Add top files with legacy markers\n            if findings and isinstance(findings, dict):\n                from collections import defaultdict\n                file_counts = defaultdict(int)\n                for pattern_type, file_list in findings.items():\n                    for file_entry in file_list:\n                        if isinstance(file_entry, list) and len(file_entry) >= 3:\n                            file_path = file_entry[0]\n                            matches = file_entry[2]\n                            if isinstance(matches, list):\n                                file_counts[file_path] += len(matches)\n                            else:\n                                file_counts[file_path] += 1\n                \n                if file_counts:\n                    # Sort by count (descending) and show top 5\n                    sorted_files = sorted(file_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                    file_list = [f\"{Path(f).name} ({count})\" for f, count in sorted_files]\n                    if len(file_counts) > 5:\n                        file_list.append(f\"... +{len(file_counts) - 5}\")\n                    lines.append(f\"    - **Top files**: {', '.join(file_list)}\")\n\n            report_path = legacy_summary.get('report_path')\n            if report_path:\n                report_path_obj = self._resolve_report_path(report_path)\n                if report_path_obj.exists():\n                    rel_path = report_path_obj.relative_to(self.project_root)\n                    lines.append(f\"- **Detailed Report**: [LEGACY_REFERENCE_REPORT.md]({rel_path.as_posix()})\")\n                else:\n                    lines.append(f\"- **Detailed Report**: {report_path}\")\n        else:\n            lines.append(\"- **Files with Legacy Markers**: Data unavailable (run `audit --full` for latest scan)\")\n            lines.append(\"- **Markers Found**: Data unavailable\")\n            lines.append(\"- **Detailed Report**: [LEGACY_REFERENCE_REPORT.md](development_docs/LEGACY_REFERENCE_REPORT.md)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Complexity & Refactoring\")\n        \n        # Access function_metrics - check details first (normalized), then top level (backward compat)\n        function_metrics_details = function_metrics.get('details', {})\n        def get_function_field(field_name, default=None):\n            return function_metrics_details.get(field_name, function_metrics.get(field_name, default))\n        \n        # Try to load complexity from decision_support if analyze_functions doesn't have it\n        high_complexity = get_function_field('high_complexity')\n        if high_complexity == 'Unknown' or high_complexity is None:\n            if decision_metrics:\n                high_complexity = decision_metrics.get('high_complexity', 'Unknown')\n                critical_complexity = decision_metrics.get('critical_complexity', 'Unknown')\n                moderate_complexity = decision_metrics.get('moderate_complexity', 'Unknown')\n                function_metrics_details['high_complexity'] = high_complexity\n                function_metrics_details['critical_complexity'] = critical_complexity\n                function_metrics_details['moderate_complexity'] = moderate_complexity\n        \n        # If still unknown, try loading from cache\n        if high_complexity == 'Unknown' or high_complexity is None:\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    # Try analyze_functions first\n                    if 'results' in cached_data and 'analyze_functions' in cached_data['results']:\n                        func_data = cached_data['results']['analyze_functions']\n                        if 'data' in func_data:\n                            cached_metrics = func_data['data']\n                            function_metrics_details['high_complexity'] = cached_metrics.get('high_complexity', 'Unknown')\n                            function_metrics_details['critical_complexity'] = cached_metrics.get('critical_complexity', 'Unknown')\n                            function_metrics_details['moderate_complexity'] = cached_metrics.get('moderate_complexity', 'Unknown')\n                            # Also load examples if available\n                            if 'critical_complexity_examples' in cached_metrics:\n                                function_metrics_details['critical_complexity_examples'] = cached_metrics.get('critical_complexity_examples', [])\n                            if 'high_complexity_examples' in cached_metrics:\n                                function_metrics_details['high_complexity_examples'] = cached_metrics.get('high_complexity_examples', [])\n                    # Fallback to decision_support\n                    if function_metrics.get('high_complexity') == 'Unknown' and 'results' in cached_data and 'decision_support' in cached_data['results']:\n                        ds_data = cached_data['results']['decision_support']\n                        if 'data' in ds_data and 'decision_support_metrics' in ds_data['data']:\n                            ds_metrics = ds_data['data']['decision_support_metrics']\n                            function_metrics_details['high_complexity'] = ds_metrics.get('high_complexity', 'Unknown')\n                            function_metrics_details['critical_complexity'] = ds_metrics.get('critical_complexity', 'Unknown')\n                            function_metrics_details['moderate_complexity'] = ds_metrics.get('moderate_complexity', 'Unknown')\n                            # Also try to load examples from decision_support if available\n                            if 'critical_complexity_examples' in ds_metrics:\n                                function_metrics_details['critical_complexity_examples'] = ds_metrics.get('critical_complexity_examples', [])\n                            if 'high_complexity_examples' in ds_metrics:\n                                function_metrics_details['high_complexity_examples'] = ds_metrics.get('high_complexity_examples', [])\n            except Exception:\n                pass\n\n        # Reorder to show most critical first: Critical, High, Moderate\n        lines.append(f\"- **Critical Complexity Functions**: {get_function_field('critical_complexity', 'Unknown')}\")\n        lines.append(f\"- **High Complexity Functions**: {get_function_field('high_complexity', 'Unknown')}\")\n        lines.append(f\"- **Moderate Complexity Functions**: {get_function_field('moderate_complexity', 'Unknown')}\")\n\n        # Add highest complexity functions list\n        # Try to load examples from multiple sources\n        critical_examples = get_function_field('critical_complexity_examples', [])\n        high_examples = get_function_field('high_complexity_examples', [])\n        \n        # Also check decision_support_metrics for examples\n        decision_metrics = self.results_cache.get('decision_support_metrics', {})\n        if decision_metrics:\n            if not critical_examples and 'critical_complexity_examples' in decision_metrics:\n                critical_examples = decision_metrics.get('critical_complexity_examples', [])\n            if not high_examples and 'high_complexity_examples' in decision_metrics:\n                high_examples = decision_metrics.get('high_complexity_examples', [])\n        \n        # If examples are still missing, try reloading from analyze_functions\n        if not critical_examples and not high_examples:\n            func_result = self._load_tool_data('analyze_functions', 'functions')\n            if func_result and isinstance(func_result, dict):\n                # Check both normalized format (details) and old format\n                func_details = func_result.get('details', {})\n                if 'critical_complexity_examples' in func_details:\n                    critical_examples = func_details.get('critical_complexity_examples', [])\n                elif 'critical_complexity_examples' in func_result:\n                    critical_examples = func_result.get('critical_complexity_examples', [])\n                if 'high_complexity_examples' in func_details:\n                    high_examples = func_details.get('high_complexity_examples', [])\n                elif 'high_complexity_examples' in func_result:\n                    high_examples = func_result.get('high_complexity_examples', [])\n        \n        # Combine and sort by complexity (if available)\n        all_examples = []\n        for item in critical_examples[:5]:\n            if isinstance(item, dict):\n                complexity = item.get('complexity', item.get('nodes', 0))\n                all_examples.append({\n                    'function': item.get('function', 'Unknown'),\n                    'file': item.get('file', 'Unknown'),\n                    'complexity': complexity,\n                    'priority': 'critical'\n                })\n        \n        for item in high_examples[:3]:  # Show fewer high complexity to keep list focused\n            if isinstance(item, dict):\n                complexity = item.get('complexity', item.get('nodes', 0))\n                all_examples.append({\n                    'function': item.get('function', 'Unknown'),\n                    'file': item.get('file', 'Unknown'),\n                    'complexity': complexity,\n                    'priority': 'high'\n                })\n        \n        if all_examples:\n            # Sort by complexity (descending)\n            all_examples.sort(key=lambda x: x.get('complexity', 0), reverse=True)\n            # Show top 5 functions\n            top_functions = all_examples[:5]\n            function_list = []\n            for func_info in top_functions:\n                func_name = func_info.get('function', 'Unknown')\n                file_name = Path(func_info.get('file', 'Unknown')).name\n                complexity = func_info.get('complexity', 0)\n                if complexity > 0:\n                    function_list.append(f\"{func_name} ({file_name}, {complexity} nodes)\")\n                else:\n                    function_list.append(f\"{func_name} ({file_name})\")\n            \n            if function_list:\n                if len(all_examples) > 5:\n                    function_list.append(f\"... +{len(all_examples) - 5} more\")\n                lines.append(f\"    - **Top functions**: {', '.join(function_list)}\")\n\n        undocumented_examples = get_function_field('undocumented_examples', [])\n\n        if undocumented_examples:\n\n            undocumented_items = [\n\n                f\"{item['function']} ({item['file']})\"\n\n                for item in undocumented_examples[:5]\n\n            ]\n\n            lines.append(f\"- **Undocumented Functions**: {', '.join(undocumented_items)}\")\n        \n        lines.append(\"\")\n        \n        # Add function patterns (handlers without docs)\n        function_patterns_data = self._load_tool_data('analyze_function_patterns', 'functions')\n        if function_patterns_data and isinstance(function_patterns_data, dict):\n            # Handle both standard format and old format\n            if 'details' in function_patterns_data:\n                handlers = function_patterns_data['details'].get('handlers', [])\n            else:\n                handlers = function_patterns_data.get('handlers', [])\n            \n            if handlers:\n                handlers_no_doc = [h for h in handlers if not h.get('has_doc', True)]\n                if handlers_no_doc:\n                    lines.append(\"## Function Patterns\")\n                    lines.append(f\"- **Handler Classes Without Documentation**: {len(handlers_no_doc)} of {len(handlers)} handler classes\")\n                    # Show top handlers without docs\n                    top_handlers = sorted(handlers_no_doc, key=lambda x: x.get('methods', 0), reverse=True)[:5]\n                    handler_list = [f\"{h.get('class', 'Unknown')} ({Path(h.get('file', '')).name}, {h.get('methods', 0)} methods)\" for h in top_handlers]\n                    if len(handlers_no_doc) > 5:\n                        handler_list.append(f\"... +{len(handlers_no_doc) - 5} more\")\n                    lines.append(f\"    - **Top handlers**: {', '.join(handler_list)}\")\n\n        # Add package exports analysis\n        package_exports_data = self._load_tool_data('analyze_package_exports', 'functions')\n        if package_exports_data and isinstance(package_exports_data, dict):\n            # Handle both standard format and old format\n            if 'summary' in package_exports_data:\n                summary = package_exports_data.get('summary', {})\n                total_missing = summary.get('total_missing_exports', 0)\n                total_unnecessary = summary.get('total_unnecessary_exports', 0)\n                details = package_exports_data.get('details', {})\n                packages = details.get('packages', {})\n            else:\n                # Old format\n                summary_data = package_exports_data.get('summary', {})\n                total_missing = summary_data.get('total_missing_exports', 0)\n                total_unnecessary = summary_data.get('total_unnecessary_exports', 0)\n                packages = package_exports_data.get('packages', {})\n            \n            if total_missing > 0 or total_unnecessary > 0:\n                lines.append(\"## Package Exports\")\n                lines.append(f\"- **Missing Exports**: {total_missing} items should be exported but aren't\")\n                lines.append(f\"- **Potentially Unnecessary**: {total_unnecessary} items exported but not used\")\n                # Show packages with issues\n                if packages:\n                    packages_with_issues = []\n                    for pkg_name, pkg_report in packages.items():\n                        if isinstance(pkg_report, dict):\n                            missing = len(pkg_report.get('missing_exports', []))\n                            unnecessary = len(pkg_report.get('potentially_unnecessary', []))\n                            if missing > 0 or unnecessary > 0:\n                                issues = []\n                                if missing > 0:\n                                    issues.append(f\"{missing} missing\")\n                                if unnecessary > 0:\n                                    issues.append(f\"{unnecessary} unnecessary\")\n                                packages_with_issues.append(f\"{pkg_name} ({', '.join(issues)})\")\n                    if packages_with_issues:\n                        lines.append(f\"    - **Packages with issues**: {', '.join(packages_with_issues[:3])}\")\n                        if len(packages_with_issues) > 3:\n                            lines.append(f\"    - ... +{len(packages_with_issues) - 3} more\")\n\n        # Add module imports analysis\n        module_imports_data = self._load_tool_data('analyze_module_imports', 'imports')\n        if module_imports_data and isinstance(module_imports_data, dict):\n            # Normalized format has data in details\n            details = module_imports_data.get('details', {})\n            # The actual import data might be in details['data'] or directly in details\n            import_data = details.get('data', details) if 'data' in details else details\n            # If still not found, check top level\n            if not import_data or (isinstance(import_data, dict) and len(import_data) == 0):\n                import_data = module_imports_data.get('data', module_imports_data)\n            \n            # Count files and imports\n            if isinstance(import_data, dict):\n                total_files = len(import_data)\n                total_imports = sum(\n                    v.get('total_imports', 0) if isinstance(v, dict) else 0\n                    for v in import_data.values()\n                )\n            else:\n                total_files = 0\n                total_imports = 0\n            \n            if total_files > 0:\n                lines.append(\"\")\n                lines.append(\"## Module Imports\")\n                lines.append(f\"- **Files Analyzed**: {total_files} Python files\")\n                if total_imports > 0:\n                    lines.append(f\"- **Total Imports**: {total_imports} import statements\")\n\n        lines.append(\"\")\n        \n        # Add dependency patterns analysis\n        dependency_patterns_data = self._load_tool_data('analyze_dependency_patterns', 'imports')\n        if dependency_patterns_data and isinstance(dependency_patterns_data, dict):\n            # Normalized format has data in details\n            details = dependency_patterns_data.get('details', {})\n            # The actual pattern data might be in details['data'] or directly in details\n            patterns_data = details.get('data', details) if 'data' in details else details\n            # If still not found, check top level\n            if not patterns_data or (isinstance(patterns_data, dict) and len(patterns_data) == 0):\n                patterns_data = dependency_patterns_data.get('data', dependency_patterns_data)\n            \n            # Extract counts\n            if isinstance(patterns_data, dict):\n                circular_deps = len(patterns_data.get('circular_dependencies', []))\n                high_coupling = len(patterns_data.get('high_coupling', []))\n            else:\n                circular_deps = 0\n                high_coupling = 0\n            \n            if circular_deps > 0 or high_coupling > 0:\n                lines.append(\"## Dependency Patterns\")\n                if circular_deps > 0:\n                    lines.append(f\"- **Circular Dependencies**: {circular_deps} circular dependency chains detected\")\n                if high_coupling > 0:\n                    lines.append(f\"- **High Coupling**: {high_coupling} modules with high coupling\")\n            elif circular_deps == 0 and high_coupling == 0 and patterns_data:\n                lines.append(\"## Dependency Patterns\")\n                lines.append(\"- **Status**: CLEAN (no circular dependencies or high coupling detected)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Validation Status\")\n\n        if validation_output:\n            # Parse text output for status\n            if 'POOR' in validation_output:\n                lines.append(\"- **AI Work Validation**: POOR - documentation or tests missing\")\n            elif 'GOOD' in validation_output:\n                lines.append(\"- **AI Work Validation**: GOOD - keep current standards\")\n            elif 'NEEDS ATTENTION' in validation_output or 'FAIR' in validation_output:\n                lines.append(\"- **AI Work Validation**: NEEDS ATTENTION - structural validation issues detected\")\n            else:\n                lines.append(\"- **AI Work Validation**: Status available (see validation output)\")\n        else:\n            lines.append(\"- **AI Work Validation**: Data unavailable (run `audit --full` for validation)\")\n        \n        # Add Config Validation to Validation Status\n        config_validation_summary = self._load_config_validation_summary()\n        if config_validation_summary:\n            config_valid = config_validation_summary.get('config_valid', False)\n            config_complete = config_validation_summary.get('config_complete', False)\n            recommendations = config_validation_summary.get('recommendations', [])\n            tools_using_config = config_validation_summary.get('tools_using_config', 0)\n            total_tools = config_validation_summary.get('total_tools', 0)\n            tools_analysis = config_validation_summary.get('tools_analysis', {})\n            \n            lines.append(\"- **Configuration Validation**\")\n            lines.append(f\"  - Config valid: {'Yes' if config_valid else 'No'}\")\n            lines.append(f\"  - Config complete: {'Yes' if config_complete else 'No'}\")\n            if total_tools > 0:\n                lines.append(f\"  - Tools using config: {tools_using_config}/{total_tools}\")\n            \n            # Find tools missing config module import\n            missing_import_tools = []\n            if tools_analysis and isinstance(tools_analysis, dict):\n                for tool_name, tool_data in tools_analysis.items():\n                    if isinstance(tool_data, dict):\n                        # Check if imports_config is False\n                        if not tool_data.get('imports_config', True):\n                            missing_import_tools.append(tool_name)\n                        else:\n                            # Also check issues list for import-related issues\n                            issues = tool_data.get('issues', [])\n                            if isinstance(issues, list):\n                                for issue in issues:\n                                    if isinstance(issue, str) and 'import config' in issue.lower():\n                                        if tool_name not in missing_import_tools:\n                                            missing_import_tools.append(tool_name)\n                                        break\n            \n            if missing_import_tools:\n                lines.append(f\"  - Tools missing config module import: {', '.join(missing_import_tools)}\")\n            \n            # Show recommendations if available and not already covered by missing_import_tools\n            if recommendations and isinstance(recommendations, list) and len(recommendations) > 0:\n                # Filter out recommendations that are already covered by missing_import_tools\n                remaining_recs = [r for r in recommendations if not any(tool in r for tool in missing_import_tools)]\n                if remaining_recs:\n                    lines.append(f\"  - Recommendations: {len(remaining_recs)} additional issue(s) - see analyze_config_results.json for details\")\n        else:\n            lines.append(\"- **Configuration Validation**: Data unavailable (run `audit --full` for validation)\")\n\n        # Add package exports analysis\n        package_exports_data = self._load_tool_data('analyze_package_exports', 'functions')\n        if package_exports_data and isinstance(package_exports_data, dict):\n            # Handle both standard format and old format\n            if 'summary' in package_exports_data:\n                summary = package_exports_data.get('summary', {})\n                total_missing = summary.get('total_missing_exports', 0)\n                total_unnecessary = summary.get('total_unnecessary_exports', 0)\n                packages_with_missing = summary.get('packages_with_missing', 0)\n                details = package_exports_data.get('details', {})\n                packages = details.get('packages', {})\n            else:\n                # Old format\n                summary_data = package_exports_data.get('summary', {})\n                total_missing = summary_data.get('total_missing_exports', 0)\n                total_unnecessary = summary_data.get('total_unnecessary_exports', 0)\n                packages_with_missing = summary_data.get('packages_with_missing', 0)\n                packages = package_exports_data.get('packages', {})\n            \n            if total_missing > 0 or total_unnecessary > 0:\n                lines.append(\"## Package Exports\")\n                lines.append(f\"- **Missing Exports**: {total_missing} items should be exported but aren't\")\n                lines.append(f\"- **Potentially Unnecessary**: {total_unnecessary} items exported but not used\")\n                # Show packages with issues\n                if packages:\n                    packages_with_issues = []\n                    for pkg_name, pkg_report in packages.items():\n                        if isinstance(pkg_report, dict):\n                            missing = len(pkg_report.get('missing_exports', []))\n                            unnecessary = len(pkg_report.get('potentially_unnecessary', []))\n                            if missing > 0 or unnecessary > 0:\n                                issues = []\n                                if missing > 0:\n                                    issues.append(f\"{missing} missing\")\n                                if unnecessary > 0:\n                                    issues.append(f\"{unnecessary} unnecessary\")\n                                packages_with_issues.append(f\"{pkg_name} ({', '.join(issues)})\")\n                    if packages_with_issues:\n                        lines.append(f\"    - **Packages with issues**: {', '.join(packages_with_issues[:3])}\")\n                        if len(packages_with_issues) > 3:\n                            lines.append(f\"    - ... +{len(packages_with_issues) - 3} more\")\n\n        lines.append(\"\")\n\n        lines.append(\"## System Signals\")\n        \n        # Load system signals data (same as AI_STATUS.md)\n        system_signals_data = None\n        # First try in-memory cache\n        if hasattr(self, 'system_signals') and self.system_signals:\n            system_signals_data = self.system_signals\n        else:\n            # Try loading from cache file\n            try:\n                import json\n                results_file = self.project_root / \"development_tools\" / \"reports\" / \"analysis_detailed_results.json\"\n                if results_file.exists():\n                    with open(results_file, 'r', encoding='utf-8') as f:\n                        cached_data = json.load(f)\n                    if 'results' in cached_data and 'system_signals' in cached_data['results']:\n                        signals_result = cached_data['results']['system_signals']\n                        if 'data' in signals_result:\n                            system_signals_data = signals_result['data']\n            except Exception as e:\n                logger.debug(f\"Failed to load system signals from cache: {e}\")\n        \n        if system_signals_data and isinstance(system_signals_data, dict):\n            overall_status = system_signals_data.get('overall_status', 'Unknown')\n            if overall_status and overall_status != 'Unknown':\n                lines.append(f\"- **System Health**: {overall_status}\")\n            else:\n                lines.append(\"- **System Health**: OK\")\n            \n            # Get recent_changes from recent_activity (same as AI_STATUS.md)\n            recent_activity = system_signals_data.get('recent_activity', {})\n            recent_changes = recent_activity.get('recent_changes') or [] if isinstance(recent_activity, dict) else []\n            if recent_changes and isinstance(recent_changes, list):\n                changes_str = self._format_list_for_display(recent_changes, limit=3)\n                lines.append(f\"- **Recent Changes**: {changes_str}\")\n        elif hasattr(self, 'system_signals') and self.system_signals:\n            # Fallback: try to extract from in-memory system_signals attribute (same as AI_STATUS.md)\n            system_health = self.system_signals.get('system_health', {}) if isinstance(self.system_signals, dict) else {}\n            overall_status = system_health.get('overall_status') if isinstance(system_health, dict) else None\n            if overall_status:\n                lines.append(f\"- **System Health**: {overall_status}\")\n            else:\n                lines.append(\"- **System Health**: OK\")\n            \n            # Get recent_changes from recent_activity (same as AI_STATUS.md)\n            recent_activity = self.system_signals.get('recent_activity', {}) if isinstance(self.system_signals, dict) else {}\n            recent_changes = recent_activity.get('recent_changes') or [] if isinstance(recent_activity, dict) else []\n            if recent_changes and isinstance(recent_changes, list):\n                changes_str = self._format_list_for_display(recent_changes, limit=3)\n                lines.append(f\"- **Recent Changes**: {changes_str}\")\n        else:\n            lines.append(\"- **System Health**: OK\")\n            lines.append(\"- **Recent Changes**: Data unavailable (run `system-signals` command)\")\n\n        lines.append(\"\")\n\n        lines.append(\"## Reference Files\")\n\n        # Critical issues summary (if exists)\n        if issues_file.exists():\n            rel_path = issues_file.relative_to(self.project_root)\n            lines.append(f\"- Critical issues summary: [{rel_path.as_posix()}]({rel_path.as_posix()})\")\n\n        lines.append(\"- Latest AI status: [AI_STATUS.md](development_tools/AI_STATUS.md)\")\n        lines.append(\"- Current AI priorities: [AI_PRIORITIES.md](development_tools/AI_PRIORITIES.md)\")\n        lines.append(\"- Detailed JSON results: [analysis_detailed_results.json](development_tools/reports/analysis_detailed_results.json)\")\n        \n        # Legacy reference report\n        legacy_report = self.project_root / 'development_docs' / 'LEGACY_REFERENCE_REPORT.md'\n        if legacy_report.exists():\n            # Use relative path from project root\n            rel_path = legacy_report.relative_to(self.project_root)\n            lines.append(f\"- Legacy reference report: [LEGACY_REFERENCE_REPORT.md]({rel_path.as_posix()})\")\n        \n        # Test coverage report\n        coverage_report = self.project_root / 'development_docs' / 'TEST_COVERAGE_REPORT.md'\n        if coverage_report.exists():\n            rel_path = coverage_report.relative_to(self.project_root)\n            lines.append(f\"- Test coverage report: [TEST_COVERAGE_REPORT.md]({rel_path.as_posix()})\")\n        \n        # Unused imports report\n        unused_imports_report = self.project_root / 'development_docs' / 'UNUSED_IMPORTS_REPORT.md'\n        if unused_imports_report.exists():\n            rel_path = unused_imports_report.relative_to(self.project_root)\n            lines.append(f\"- Unused imports detail: [UNUSED_IMPORTS_REPORT.md]({rel_path.as_posix()})\")\n        \n        # Legacy compatibility check removed - we only add links if files exist, no duplicate fallback text needed\n        \n        # Historical audit data archive\n        archive_dir = self.project_root / 'development_tools' / 'reports' / 'archive'\n        if archive_dir.exists():\n            lines.append(f\"- Historical audit data: development_tools/reports/archive\")\n\n        lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def _identify_critical_issues(self) -> List[str]:\n\n        \"\"\"Identify critical issues from audit results\"\"\"\n\n        issues = []\n\n        # Check function documentation coverage\n\n        if 'analyze_functions' in self.results_cache:\n\n            metrics = self.results_cache['analyze_functions']\n\n            if 'coverage' in metrics:\n\n                try:\n\n                    coverage = float(metrics['coverage'].replace('%', ''))\n\n                    if coverage < 90:\n\n                        issues.append(f\"Low documentation coverage: {coverage}%\")\n\n                except:\n\n                    pass\n\n        # Check for failed audits\n\n        if hasattr(self, '_last_failed_audits'):\n\n            for audit in self._last_failed_audits:\n\n                issues.append(f\"Failed audit: {audit}\")\n\n        return issues\n\n    def _generate_action_items(self) -> List[str]:\n\n        \"\"\"Generate actionable items from audit results\"\"\"\n\n        actions = []\n\n        # Documentation improvements (only if needed)\n\n        if 'analyze_functions' in self.results_cache:\n\n            metrics = self.results_cache['analyze_functions']\n\n            if 'coverage' in metrics:\n\n                try:\n\n                    coverage = float(metrics['coverage'].replace('%', ''))\n\n                    if coverage < 95:\n\n                        actions.append(f\"Improve documentation coverage (currently {coverage}%)\")\n\n                except:\n\n                    pass\n\n        # Complexity management (only if significant)\n\n        if 'decision_support' in self.results_cache:\n\n            insights = self.results_cache['decision_support']\n\n            if isinstance(insights, list) and insights:\n\n                # Look for complexity warnings\n\n                complexity_warnings = [insight for insight in insights if 'complexity' in insight.lower()]\n\n                if complexity_warnings:\n\n                    actions.append(\"Refactor high complexity functions for maintainability\")\n\n        # Core development tasks\n\n        actions.append(\"Review TODO.md for next development priorities\")\n\n        actions.append(\"Run comprehensive testing before major changes\")\n\n        # Maintenance tasks (updated changelog reference)\n\n        actions.append(\"Update AI_CHANGELOG.md and CHANGELOG_DETAIL.md with recent changes\")\n\n        return actions\n\n    def _get_system_status(self) -> str:\n\n        \"\"\"Get current system status\"\"\"\n\n        status_lines = []\n\n        status_lines.append(\"SYSTEM STATUS\")\n\n        status_lines.append(\"=\" * 30)\n\n        # Check key files (configurable for portability)\n\n        for file_path in self.key_files:\n\n            if Path(file_path).exists():\n\n                status_lines.append(f\"[OK] {file_path}\")\n\n            else:\n\n                status_lines.append(f\"[MISSING] {file_path}\")\n\n        # Check recent audit results\n\n        results_file_name = (self.audit_config or {}).get('results_file', 'development_tools/reports/analysis_detailed_results.json')\n\n        for prefix in ('ai_tools/', 'development_tools/'):\n\n            if results_file_name.startswith(prefix):\n\n                results_file_name = results_file_name[len(prefix):]\n\n                break\n\n        results_file = self.project_root / results_file_name\n\n        if results_file.exists():\n\n            try:\n\n                with open(results_file, 'r') as f:\n\n                    data = json.load(f)\n\n                    timestamp = data.get('timestamp', 'Unknown')\n\n                    status_lines.append(f\"[AUDIT] Last audit: {timestamp}\")\n\n            except:\n\n                status_lines.append(\"[AUDIT] Last audit: Unknown\")\n\n        else:\n\n            status_lines.append(\"[AUDIT] No recent audit found\")\n\n        return '\\n'.join(status_lines)\n\n    def _execute_documentation_task(self) -> bool:\n\n        \"\"\"Execute documentation update task\"\"\"\n\n        logger.info(\"Updating documentation...\")\n\n        result = self.run_script('generate_documentation')\n\n        return result['success']\n\n    def _execute_function_registry_task(self) -> bool:\n\n        \"\"\"Execute function registry task\"\"\"\n\n        logger.info(\"Updating function registry...\")\n\n        result = self.run_script('generate_function_registry')\n\n        return result['success']\n\n    def _execute_module_dependencies_task(self) -> bool:\n\n        \"\"\"Execute module dependencies task\"\"\"\n\n        logger.info(\"Updating module dependencies...\")\n\n        result = self.run_script('generate_module_dependencies')\n\n        return result['success']\n\n    def _load_mtime_cached_tool_results(\n        self, \n        tool_name: str, \n        domain: str, \n        cache_file: Path, \n        result: Dict,\n        parse_output_func: Optional[Callable[[str], Dict[str, Any]]] = None,\n        cache_converter_func: Optional[Callable[[Dict[str, Any]], Dict[str, Any]]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Unified helper for loading results from mtime-cached tools.\n        \n        After tool execution, this method:\n        1. Loads from cache FIRST (fresh data after tool execution)\n        2. Converts cache format to results format (using converter or default)\n        3. Saves to results JSON\n        4. Returns results dict\n        5. Falls back to parsing output if cache fails\n        \n        Args:\n            tool_name: Name of the tool (e.g., 'analyze_ascii_compliance')\n            domain: Domain directory (e.g., 'docs')\n            cache_file: Path to the cache file\n            result: Result dict from tool execution (run_script output)\n            parse_output_func: Optional function to parse tool output if cache fails\n            cache_converter_func: Optional function to convert cache format to results format.\n                                 If None, uses default converter (for tools with 'files', 'file_count', 'total_issues' format).\n                                 Signature: (cache_data: Dict) -> Dict[str, Any]\n            \n        Returns:\n            Dict with tool-specific results format\n        \"\"\"\n        from .output_storage import save_tool_result\n        import json\n        \n        # Step 1: Load from cache FIRST (fresh data after tool execution)\n        cache_data = None\n        if cache_file.exists():\n            try:\n                with open(cache_file, 'r', encoding='utf-8') as f:\n                    cache_data = json.load(f)\n                logger.debug(f\"Loaded {tool_name} from cache (fresh data after execution)\")\n            except Exception as cache_error:\n                logger.debug(f\"Failed to load {tool_name} from cache: {cache_error}\")\n        \n        # Step 2: Convert cache format to results format\n        if cache_data and isinstance(cache_data, dict):\n            file_data = cache_data.get('data', {})\n            if file_data and isinstance(file_data, dict):\n                # Use custom converter if provided, otherwise use default\n                if cache_converter_func:\n                    tool_result = cache_converter_func(file_data)\n                else:\n                    # Default converter: for tools with 'files', 'file_count', 'total_issues' format\n                    files_with_issues = {}\n                    total_issues = 0\n                    for file_path, file_info in file_data.items():\n                        if isinstance(file_info, dict):\n                            results = file_info.get('results', [])\n                            if results:\n                                files_with_issues[file_path] = len(results)\n                                total_issues += len(results)\n                    \n                    tool_result = {\n                        'files': files_with_issues,\n                        'file_count': len(files_with_issues),\n                        'total_issues': total_issues\n                    }\n                \n                # Step 3: Save to results JSON\n                try:\n                    save_tool_result(tool_name, domain, tool_result, project_root=self.project_root)\n                    logger.debug(f\"Regenerated {tool_name}_results.json from fresh cache\")\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save {tool_name} results: {save_error}\")\n                \n                return tool_result\n        \n        # Step 4: Fallback to parsing output if cache failed or doesn't exist\n        if result.get('output') or result.get('success'):\n            if parse_output_func:\n                tool_result = parse_output_func(result.get('output', ''))\n                # Save parsed results\n                try:\n                    save_tool_result(tool_name, domain, tool_result, project_root=self.project_root)\n                    logger.debug(f\"Saved {tool_name} results from parsed output\")\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save {tool_name} results: {save_error}\")\n                return tool_result\n            else:\n                logger.warning(f\"No parser function provided for {tool_name}, cannot parse output\")\n        else:\n            logger.warning(f\"{tool_name} failed: {result.get('error', 'Unknown error')}\")\n        \n        # Return empty result if all else fails (default format)\n        return {\n            'files': {},\n            'file_count': 0,\n            'total_issues': 0\n        }\n\n    def _run_doc_sync_check(self, *args) -> bool:\n\n        \"\"\"Run all documentation sync checks and aggregate results.\"\"\"\n\n        all_results = {}\n\n        # Run paired documentation sync\n        logger.info(\"Running paired documentation synchronization checks...\")\n        result = self.run_script('analyze_documentation_sync', *args)\n        # For analysis tools, success means they ran and produced output (even if issues found)\n        if result.get('output') or result.get('success'):\n            all_results['paired_docs'] = self._parse_documentation_sync_output(result.get('output', ''))\n        else:\n            logger.warning(f\"analyze_documentation_sync failed: {result.get('error', 'Unknown error')}\")\n\n        # Run path drift analysis\n        logger.info(\"Running path drift analysis...\")\n        result = self.run_analyze_path_drift()\n        if result.get('data'):\n            # Use structured data if available\n            all_results['path_drift'] = result.get('data', {})\n        elif result.get('output') or result.get('success'):\n            # Fallback to parsing output\n            all_results['path_drift'] = self._parse_path_drift_output(result.get('output', ''))\n        else:\n            logger.warning(f\"analyze_path_drift failed: {result.get('error', 'Unknown error')}\")\n\n        # Run ASCII compliance check\n        logger.info(\"Running ASCII compliance check...\")\n        result = self.run_script('analyze_ascii_compliance', '--json')\n        try:\n            cache_file = self.project_root / \"development_tools\" / \"docs\" / \"jsons\" / \".analyze_ascii_compliance_cache.json\"\n            ascii_result = self._load_mtime_cached_tool_results(\n                'analyze_ascii_compliance',\n                'docs',\n                cache_file,\n                result,\n                self._parse_ascii_compliance_output\n            )\n            all_results['ascii_compliance'] = ascii_result\n        except Exception as e:\n            logger.debug(f\"Failed to load ASCII compliance: {e}, falling back to parsing output\")\n            if result.get('output') or result.get('success'):\n                ascii_result = self._parse_ascii_compliance_output(result.get('output', ''))\n                all_results['ascii_compliance'] = ascii_result\n                try:\n                    from .output_storage import save_tool_result\n                    save_tool_result('analyze_ascii_compliance', 'docs', ascii_result, project_root=self.project_root)\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save ASCII compliance results: {save_error}\")\n            else:\n                logger.warning(f\"analyze_ascii_compliance failed: {result.get('error', 'Unknown error')}\")\n\n        # Run heading numbering check\n        logger.info(\"Running heading numbering check...\")\n        result = self.run_script('analyze_heading_numbering', '--json')\n        try:\n            cache_file = self.project_root / \"development_tools\" / \"docs\" / \"jsons\" / \".analyze_heading_numbering_cache.json\"\n            heading_result = self._load_mtime_cached_tool_results(\n                'analyze_heading_numbering',\n                'docs',\n                cache_file,\n                result,\n                self._parse_heading_numbering_output\n            )\n            all_results['heading_numbering'] = heading_result\n        except Exception as e:\n            logger.debug(f\"Failed to load heading numbering: {e}, falling back to parsing output\")\n            if result.get('output') or result.get('success'):\n                heading_result = self._parse_heading_numbering_output(result.get('output', ''))\n                all_results['heading_numbering'] = heading_result\n                try:\n                    from .output_storage import save_tool_result\n                    save_tool_result('analyze_heading_numbering', 'docs', heading_result, project_root=self.project_root)\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save heading numbering results: {save_error}\")\n            else:\n                logger.warning(f\"analyze_heading_numbering failed: {result.get('error', 'Unknown error')}\")\n\n        # Run missing addresses check\n        logger.info(\"Running missing addresses check...\")\n        result = self.run_script('analyze_missing_addresses', '--json')\n        try:\n            cache_file = self.project_root / \"development_tools\" / \"docs\" / \"jsons\" / \".analyze_missing_addresses_cache.json\"\n            missing_result = self._load_mtime_cached_tool_results(\n                'analyze_missing_addresses',\n                'docs',\n                cache_file,\n                result,\n                self._parse_missing_addresses_output\n            )\n            all_results['missing_addresses'] = missing_result\n        except Exception as e:\n            logger.debug(f\"Failed to load missing addresses: {e}, falling back to parsing output\")\n            if result.get('output') or result.get('success'):\n                missing_result = self._parse_missing_addresses_output(result.get('output', ''))\n                all_results['missing_addresses'] = missing_result\n                try:\n                    from .output_storage import save_tool_result\n                    save_tool_result('analyze_missing_addresses', 'docs', missing_result, project_root=self.project_root)\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save missing addresses results: {save_error}\")\n            else:\n                logger.warning(f\"analyze_missing_addresses failed: {result.get('error', 'Unknown error')}\")\n\n        # Run unconverted links check\n        logger.info(\"Running unconverted links check...\")\n        result = self.run_script('analyze_unconverted_links', '--json')\n        try:\n            cache_file = self.project_root / \"development_tools\" / \"docs\" / \"jsons\" / \".analyze_unconverted_links_cache.json\"\n            links_result = self._load_mtime_cached_tool_results(\n                'analyze_unconverted_links',\n                'docs',\n                cache_file,\n                result,\n                self._parse_unconverted_links_output\n            )\n            all_results['unconverted_links'] = links_result\n        except Exception as e:\n            logger.debug(f\"Failed to load unconverted links: {e}, falling back to parsing output\")\n            if result.get('output') or result.get('success'):\n                links_result = self._parse_unconverted_links_output(result.get('output', ''))\n                all_results['unconverted_links'] = links_result\n                try:\n                    from .output_storage import save_tool_result\n                    save_tool_result('analyze_unconverted_links', 'docs', links_result, project_root=self.project_root)\n                except Exception as save_error:\n                    logger.debug(f\"Failed to save unconverted links results: {save_error}\")\n            else:\n                logger.warning(f\"analyze_unconverted_links failed: {result.get('error', 'Unknown error')}\")\n\n        # Aggregate all results\n        summary = self._aggregate_doc_sync_results(all_results)\n\n        self.docs_sync_results = {'success': True, 'summary': summary, 'all_results': all_results}\n        self.docs_sync_summary = summary\n\n        logger.info(f\"Documentation sync summary: {summary.get('status', 'UNKNOWN')} - {summary.get('total_issues', 0)} total issues\")\n\n        return True\n\n    def _run_legacy_cleanup_scan(self, *args) -> bool:\n\n        \"\"\"Run legacy cleanup and store structured results.\"\"\"\n\n        result = self.run_script('fix_legacy_references', *args)\n\n        if result.get('success'):\n\n            summary = self._parse_legacy_output(result.get('output', ''))\n\n            result['summary'] = summary\n\n            self.legacy_cleanup_results = result\n\n            self.legacy_cleanup_summary = summary\n\n            return True\n\n        if result.get('output'):\n\n            logger.info(result['output'])\n\n        if result.get('error'):\n\n            logger.error(result['error'])\n\n        return False\n\n    def show_help(self):\n\n        \"\"\"Show comprehensive help and the available command list.\"\"\"\n\n        print(\"AI Development Tools Runner\")\n        print(\"=\" * 50)\n        print(f\"Comprehensive AI collaboration tools for the {self.project_name} project\")\n        print()\n        print(\"USAGE:\")\n        print(\"  python development_tools/run_development_tools.py <command> [options]\")\n        print()\n        print(\"AVAILABLE COMMANDS:\")\n        print()\n\n        for section, metadata in COMMAND_TIERS.items():\n            print(f\"  {section}:\")\n            description = metadata.get(\"description\")\n            if description:\n                print(f\"    {description}\")\n            for cmd_name in metadata.get(\"commands\", []):\n                if cmd_name in COMMAND_REGISTRY:\n                    cmd = COMMAND_REGISTRY[cmd_name]\n                    print(f\"    {cmd.name:<16} {cmd.help}\")\n            if metadata.get(\"tier\") == \"experimental\":\n                print(\"    WARNING: Experimental commands may change or fail; run only with approval.\")\n            print()\n\n        print(\"EXAMPLES:\")\n        print(\"  python development_tools/run_development_tools.py status\")\n        print(\"  python development_tools/run_development_tools.py audit --full\")\n        print(\"  python development_tools/run_development_tools.py docs\")\n        print(\"  python development_tools/run_development_tools.py unused-imports\")\n        print()\n        print(\"For detailed command options:\")\n        print(\"  python development_tools/run_development_tools.py <command> --help\")\n\n@dataclass(frozen=True)\n\nclass CommandRegistration:\n\n    name: str\n\n    handler: Callable[[\"AIToolsService\", Sequence[str]], int]\n\n    help: str\n\n    description: str = ''\n\ndef _print_command_help(parser: argparse.ArgumentParser) -> None:\n\n    parser.print_help()\n\n    print()\n\ndef _audit_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    parser = argparse.ArgumentParser(prog='audit', add_help=False)\n\n    parser.add_argument('--full', action='store_true', help='Run comprehensive audit (Tier 3 - includes coverage and dependencies).')\n    \n    parser.add_argument('--quick', action='store_true', help='Run quick audit (Tier 1 - core metrics only).')\n    \n    # LEGACY COMPATIBILITY\n    # --fast flag is deprecated in favor of --quick for consistency with tier naming.\n    # Removal plan: Remove --fast flag after one release cycle. Update any scripts/docs using --fast.\n    # Detection: Search for \"--fast\" in scripts, documentation, and usage examples.\n    parser.add_argument('--fast', action='store_true', help='[DEPRECATED] Use --quick instead. Force fast audit (skip coverage).')\n\n    parser.add_argument('--include-tests', action='store_true', help='Include test files in analysis.')\n\n    parser.add_argument('--include-dev-tools', action='store_true', help='Include development_tools in analysis.')\n\n    parser.add_argument('--include-all', action='store_true', help='Include tests and dev tools (equivalent to --include-tests --include-dev-tools).')\n\n    parser.add_argument('--overlap', action='store_true', help='Include overlap analysis in documentation analysis (section overlaps and consolidation recommendations).')\n\n    if any(arg in ('-h', '--help') for arg in argv):\n\n        _print_command_help(parser)\n\n        return 0\n\n    ns = parser.parse_args(list(argv))\n\n    # Determine audit tier based on flags\n    # --quick takes precedence, then --full, then default (standard)\n    # --fast is deprecated but still supported for backward compatibility\n    quick_mode = ns.quick\n    full_mode = ns.full\n    \n    # LEGACY COMPATIBILITY: Handle deprecated --fast flag\n    if ns.fast and not ns.quick and not ns.full:\n        quick_mode = True\n        logger.warning(\"LEGACY: --fast flag is deprecated. Use --quick instead.\")\n\n    # Set exclusion configuration\n\n    service.set_exclusion_config(\n\n        include_tests=ns.include_tests or ns.include_all,\n\n        include_dev_tools=ns.include_dev_tools or ns.include_all\n\n    )\n\n    success = service.run_audit(quick=quick_mode, full=full_mode, include_overlap=ns.overlap)\n\n    return 0 if success else 1\n\ndef _docs_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'docs' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: docs\")\n\n        return 0\n\n    success = service.run_docs()\n\n    return 0 if success else 1\n\ndef _validate_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'validate' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: validate\")\n\n        return 0\n\n    success = service.run_validate()\n\n    return 0 if success else 1\n\ndef _config_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'config' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: config\")\n\n        return 0\n\n    success = service.run_config()\n\n    return 0 if success else 1\n\ndef _workflow_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    parser = argparse.ArgumentParser(prog='workflow', add_help=False)\n\n    parser.add_argument('task_type', help='Workflow task to execute')\n\n    if any(arg in ('-h', '--help') for arg in argv):\n\n        _print_command_help(parser)\n\n        return 0\n\n    if not argv:\n\n        print(\"Usage: workflow <task_type>\")\n\n        return 2\n\n    ns = parser.parse_args(list(argv))\n\n    success = service.run_workflow(ns.task_type)\n\n    return 0 if success else 1\n\n# LEGACY COMPATIBILITY\n# quick-audit command is deprecated in favor of 'audit --quick' for consistency.\n# Removal plan: Remove quick-audit command and _quick_audit_command handler after one release cycle.\n# Detection: Search for \"quick-audit\" in scripts, documentation, and usage examples.\ndef _quick_audit_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'quick-audit' command does not accept additional arguments.\")\n            print(\"Note: 'quick-audit' is deprecated. Use 'audit --quick' instead.\")\n\n            return 2\n\n        print(\"Usage: quick-audit\")\n        print(\"Note: This command is deprecated. Use 'audit --quick' instead.\")\n\n        return 0\n\n    # LEGACY: quick-audit command - redirect to audit --quick\n    logger.warning(\"LEGACY: 'quick-audit' command is deprecated. Use 'audit --quick' instead.\")\n    success = service.run_audit(quick=True)\n\n    return 0 if success else 1\n\ndef _decision_support_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'decision-support' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: decision-support\")\n\n        return 0\n\n    result = service.run_decision_support()\n\n    return 0 if (isinstance(result, dict) and result.get('success', False)) or result else 1\n\ndef _fix_version_sync_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    parser = argparse.ArgumentParser(prog='version-sync', add_help=False)\n\n    parser.add_argument('scope', nargs='?', default='docs', help='Scope to sync (docs, core, ai_docs, all).')\n\n    if any(arg in ('-h', '--help') for arg in argv):\n\n        _print_command_help(parser)\n\n        return 0\n\n    ns = parser.parse_args(list(argv))\n\n    success = service.run_version_sync(ns.scope)\n\n    return 0 if success else 1\n\ndef _status_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'status' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: status\")\n\n        return 0\n\n    success = service.run_status()\n\n    return 0 if success else 1\n\ndef _system_signals_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n    \"\"\"Handle system-signals command\"\"\"\n    if argv:\n        if any(arg not in ('-h', '--help') for arg in argv):\n            print(\"The 'system-signals' command does not accept additional arguments.\")\n            return 2\n        print(\"Usage: system-signals\")\n        return 0\n\n    success = service.run_system_signals()\n    return 0 if success else 1\n\ndef _doc_sync_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'doc-sync' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: doc-sync\")\n\n        return 0\n\n    success = service.run_documentation_sync()\n\n    return 0 if success else 1\n\ndef _doc_fix_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    \"\"\"Handle doc-fix command with options for different fix types.\"\"\"\n\n    parser = argparse.ArgumentParser(description='Fix documentation issues')\n\n    parser.add_argument('--add-addresses', action='store_true', help='Add file addresses to documentation files')\n\n    parser.add_argument('--fix-ascii', action='store_true', help='Fix non-ASCII characters in documentation')\n\n    parser.add_argument('--number-headings', action='store_true', help='Number H2 and H3 headings in documentation')\n\n    parser.add_argument('--convert-links', action='store_true', help='Convert file paths to markdown links')\n\n    parser.add_argument('--all', action='store_true', help='Apply all fix operations')\n\n    parser.add_argument('--dry-run', action='store_true', help='Show what would be changed without making changes')\n\n    try:\n\n        args = parser.parse_args(argv)\n\n    except SystemExit:\n\n        return 2\n\n    # Determine fix type\n\n    fix_types = []\n\n    if args.add_addresses:\n\n        fix_types.append('add-addresses')\n\n    if args.fix_ascii:\n\n        fix_types.append('fix-ascii')\n\n    if args.number_headings:\n\n        fix_types.append('number-headings')\n\n    if args.convert_links:\n\n        fix_types.append('convert-links')\n\n    if args.all:\n\n        fix_type = 'all'\n\n    elif len(fix_types) == 1:\n\n        fix_type = fix_types[0]\n\n    elif len(fix_types) > 1:\n\n        print(\"Error: Can only specify one fix type at a time (or use --all)\")\n\n        return 2\n\n    else:\n\n        # Default to all if nothing specified\n\n        fix_type = 'all'\n\n    success = service.run_documentation_fix(fix_type=fix_type, dry_run=args.dry_run)\n\n    return 0 if success else 1\n\ndef _coverage_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'coverage' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: coverage\")\n\n        return 0\n\n    success = service.run_coverage_regeneration()\n\n    return 0 if success else 1\n\ndef _legacy_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'legacy' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: legacy\")\n\n        return 0\n\n    success = service.run_legacy_cleanup()\n\n    return 0 if success else 1\n\ndef _unused_imports_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n    \"\"\"Handle unused-imports command.\"\"\"\n    if argv:\n        if '-h' in argv or '--help' in argv:\n            print(\"Usage: unused-imports\")\n            return 0\n        \n        if any(arg not in ('-h', '--help') for arg in argv):\n            print(\"The 'unused-imports' command does not accept additional arguments.\")\n            print(\"Usage: unused-imports\")\n            return 2\n\n    success = service.run_unused_imports_report()\n\n    return 0 if success else 1\n\ndef _cleanup_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n    \"\"\"Handle cleanup command.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(prog='cleanup', add_help=False)\n    parser.add_argument('--cache', action='store_true', help='Clean cache directories (__pycache__, .pytest_cache)')\n    parser.add_argument('--test-data', action='store_true', help='Clean test data directories')\n    parser.add_argument('--coverage', action='store_true', help='Clean coverage files and logs')\n    parser.add_argument('--all', action='store_true', help='Clean all categories (default if no specific category specified)')\n    parser.add_argument('--dry-run', action='store_true', help='Show what would be removed without actually removing')\n    \n    if '-h' in argv or '--help' in argv:\n        print(\"Usage: cleanup [--cache] [--test-data] [--coverage] [--all] [--dry-run]\")\n        print(\"  --cache      Clean cache directories (__pycache__, .pytest_cache)\")\n        print(\"  --test-data  Clean test data directories\")\n        print(\"  --coverage   Clean coverage files and logs\")\n        print(\"  --all        Clean all categories (default if no specific category specified)\")\n        print(\"  --dry-run    Show what would be removed without making changes\")\n        return 0\n    \n    try:\n        args, unknown = parser.parse_known_args(argv)\n        if unknown:\n            print(f\"Unknown arguments: {unknown}\")\n            print(\"Usage: cleanup [--cache] [--test-data] [--coverage] [--all] [--dry-run]\")\n            return 2\n    except SystemExit:\n        return 2\n    \n    result = service.run_cleanup(\n        cache=args.cache,\n        test_data=args.test_data,\n        coverage=args.coverage,\n        all_cleanup=args.all,\n        dry_run=args.dry_run\n    )\n    \n    if result.get('success'):\n        data = result.get('data', {})\n        total_removed = data.get('total_removed', 0)\n        total_failed = data.get('total_failed', 0)\n        if args.dry_run:\n            logger.info(f\"DRY RUN: Would remove {total_removed} items\")\n        else:\n            logger.info(f\"Cleanup completed: {total_removed} items removed, {total_failed} failed\")\n        return 0 if total_failed == 0 else 1\n    else:\n        logger.error(f\"Cleanup failed: {result.get('error', 'Unknown error')}\")\n        return 1\n\ndef _trees_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    if argv:\n\n        if any(arg not in ('-h', '--help') for arg in argv):\n\n            print(\"The 'trees' command does not accept additional arguments.\")\n\n            return 2\n\n        print(\"Usage: trees\")\n\n        return 0\n\n    success = service.generate_directory_trees()\n\n    return 0 if success else 1\n\ndef _show_help_command(service: \"AIToolsService\", argv: Sequence[str]) -> int:\n\n    service.show_help()\n\n    return 0\n\nCOMMAND_REGISTRY = OrderedDict([\n\n    ('audit', CommandRegistration('audit', _audit_command, 'Run audit (Tier 2 - standard). Use --quick for Tier 1, --full for Tier 3.')),\n\n    ('docs', CommandRegistration('docs', _docs_command, 'Regenerate documentation artifacts.')),\n\n    ('validate', CommandRegistration('validate', _validate_command, 'Validate AI-generated work.')),\n\n    ('config', CommandRegistration('config', _config_command, 'Check configuration consistency.')),\n\n    ('workflow', CommandRegistration('workflow', _workflow_command, 'Execute an audit-first workflow task.')),\n\n    ('quick-audit', CommandRegistration('quick-audit', _quick_audit_command, '[DEPRECATED] Use \"audit --quick\" instead. Run quick audit (Tier 1).')),\n\n    ('decision-support', CommandRegistration('decision-support', _decision_support_command, 'Generate decision support insights.')),\n\n    ('version-sync', CommandRegistration('version-sync', _fix_version_sync_command, 'Synchronize version metadata.')),\n\n    ('status', CommandRegistration('status', _status_command, 'Print quick system status.')),\n\n    ('system-signals', CommandRegistration('system-signals', _system_signals_command, 'Generate system health and status signals.')),\n\n    ('doc-sync', CommandRegistration('doc-sync', _doc_sync_command, 'Check documentation synchronisation.')),\n\n    ('doc-fix', CommandRegistration('doc-fix', _doc_fix_command, 'Fix documentation issues (addresses, ASCII, headings, links).')),\n\n    ('coverage', CommandRegistration('coverage', _coverage_command, 'Regenerate coverage metrics.')),\n\n    ('legacy', CommandRegistration('legacy', _legacy_command, 'Scan for legacy references.')),\n\n    ('unused-imports', CommandRegistration('unused-imports', _unused_imports_command, 'Detect unused imports in codebase.')),\n\n    ('cleanup', CommandRegistration('cleanup', _cleanup_command, 'Clean up project cache and temporary files.')),\n\n    ('trees', CommandRegistration('trees', _trees_command, 'Generate directory tree reports.')),\n\n    ('help', CommandRegistration('help', _show_help_command, 'Show detailed help information.')),\n\n])\n\ndef list_commands() -> Sequence[CommandRegistration]:\n\n    return tuple(COMMAND_REGISTRY.values())\n\n",
          [
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 879,
              "line_content": "# LEGACY COMPATIBILITY: Reading from old file location for backward compatibility",
              "start": 32943,
              "end": 32966
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 1046,
              "line_content": "# LEGACY COMPATIBILITY: Handle both standard format (new) and legacy format (old)",
              "start": 40831,
              "end": 40854
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 3215,
              "line_content": "# LEGACY COMPATIBILITY: Ensure data is in standard format",
              "start": 139269,
              "end": 139292
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4306,
              "line_content": "# LEGACY COMPATIBILITY: Convert back to legacy format for backward compatibility with existing code",
              "start": 172242,
              "end": 172265
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4320,
              "line_content": "# LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility",
              "start": 173172,
              "end": 173195
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4376,
              "line_content": "# LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility",
              "start": 175699,
              "end": 175722
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4421,
              "line_content": "# LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility",
              "start": 177867,
              "end": 177890
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4465,
              "line_content": "# LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility",
              "start": 179920,
              "end": 179943
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 4502,
              "line_content": "# LEGACY COMPATIBILITY: Fall back to text parsing for backward compatibility",
              "start": 181604,
              "end": 181627
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 6315,
              "line_content": "# LEGACY COMPATIBILITY: Reading from old file location for backward compatibility",
              "start": 267903,
              "end": 267926
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 10137,
              "line_content": "# LEGACY COMPATIBILITY: Handle deprecated --fast flag",
              "start": 477662,
              "end": 477685
            }
          ]
        ],
        [
          "tests\\fixtures\\development_tools_demo\\legacy_code.py",
          "\"\"\"\nLegacy code module for testing legacy reference cleanup.\n\nThis module contains legacy patterns that should be detected and cleaned up.\n\"\"\"\n\n# LEGACY COMPATIBILITY: This function is kept for backward compatibility\ndef legacy_function():\n    \"\"\"Legacy function that should be detected.\"\"\"\n    pass\n\n\n# LEGACY COMPATIBILITY: Old import pattern\n# Note: This is commented out to avoid import errors, but the pattern is still detectable\n# from bot.communication import old_module  # noqa: F401\n\n\ndef uses_legacy_pattern():\n    \"\"\"Function that uses legacy patterns.\"\"\"\n    # Reference to old bot directory\n    old_path = \"bot/communication/old_file.py\"\n    return old_path\n\n\nclass LegacyChannelWrapper:\n    \"\"\"Legacy wrapper class.\"\"\"\n    pass\n\n\ndef _create_legacy_channel_access():\n    \"\"\"Legacy channel access function.\"\"\"\n    pass\n\n",
          [
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 7,
              "line_content": "# LEGACY COMPATIBILITY: This function is kept for backward compatibility",
              "start": 144,
              "end": 167
            },
            {
              "pattern": "# LEGACY COMPATIBILITY:",
              "match": "# LEGACY COMPATIBILITY:",
              "line": 13,
              "line_content": "# LEGACY COMPATIBILITY: Old import pattern",
              "start": 302,
              "end": 325
            }
          ]
        ]
      ],
      "old_bot_directory": [
        [
          "tests\\development_tools\\test_legacy_reference_cleanup.py",
          "\"\"\"\nTests for fix_legacy_references.py.\n\nTests scanning, verification, and safe cleanup operations.\n\"\"\"\n\nimport pytest\nimport sys\nfrom pathlib import Path\n\n# Import helper from conftest\nfrom tests.development_tools.conftest import load_development_tools_module\n\n# Load the modules using the helper\ncleanup_module = load_development_tools_module(\"fix_legacy_references\")\nanalyzer_module = load_development_tools_module(\"analyze_legacy_references\")\nreport_module = load_development_tools_module(\"generate_legacy_reference_report\")\n\nLegacyReferenceFixer = cleanup_module.LegacyReferenceFixer\nLegacyReferenceAnalyzer = analyzer_module.LegacyReferenceAnalyzer\nLegacyReferenceReportGenerator = report_module.LegacyReferenceReportGenerator\n\n\nclass TestLegacyScanning:\n    \"\"\"Test legacy reference scanning.\"\"\"\n    \n    @pytest.mark.unit\n    def test_scan_for_legacy_references_finds_markers(self, demo_project_root):\n        \"\"\"Test that legacy markers are found.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        findings = analyzer.scan_for_legacy_references()\n        \n        # Should find legacy compatibility markers in legacy_code.py\n        if 'legacy_compatibility_markers' in findings:\n            legacy_files = [file_path for file_path, _, _ in findings['legacy_compatibility_markers']]\n            assert any('legacy_code.py' in str(f) for f in legacy_files)\n    \n    @pytest.mark.unit\n    def test_scan_for_legacy_references_respects_preserve_files(self, demo_project_root):\n        \"\"\"Test that preserved files are skipped.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Add a preserve pattern that matches our demo project\n        original_preserve = analyzer.preserve_files\n        analyzer.preserve_files = analyzer.preserve_files | {'README.md'}\n        \n        findings = analyzer.scan_for_legacy_references()\n        \n        # README.md should not appear in findings\n        for pattern_type, files in findings.items():\n            for file_path, _, _ in files:\n                assert 'README.md' not in str(file_path)\n        \n        analyzer.preserve_files = original_preserve\n    \n    @pytest.mark.unit\n    def test_should_skip_file_exclusions(self, demo_project_root):\n        \"\"\"Test that excluded files are skipped.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with a file that should be excluded\n        excluded_file = demo_project_root / \"__pycache__\" / \"test.pyc\"\n        excluded_file.parent.mkdir(exist_ok=True)\n        excluded_file.write_bytes(b\"test\")\n        \n        should_skip = analyzer.should_skip_file(excluded_file)\n        assert should_skip is True\n        \n        # Clean up - remove file and directory if empty\n        excluded_file.unlink()\n        try:\n            excluded_file.parent.rmdir()\n        except OSError:\n            # Directory not empty, that's okay - just remove our test file\n            pass\n\n\nclass TestReferenceFinding:\n    \"\"\"Test finding specific legacy references.\"\"\"\n    \n    @pytest.mark.unit\n    def test_find_all_references_specific_item(self, demo_project_root):\n        \"\"\"Test that specific legacy items are found.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Verify the legacy file exists\n        legacy_file = demo_project_root / \"legacy_code.py\"\n        assert legacy_file.exists(), \"legacy_code.py should exist in demo project\"\n        \n        # Verify the item exists in the file\n        content = legacy_file.read_text(encoding='utf-8')\n        assert 'LegacyChannelWrapper' in content, \"LegacyChannelWrapper should exist in legacy_code.py\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), \"legacy_code.py should not be skipped\"\n        \n        # Find references to LegacyChannelWrapper\n        # Note: find_all_references searches for the item as a pattern in files\n        references = analyzer.find_all_references('LegacyChannelWrapper')\n        \n        # The function should find the class definition\n        # It searches for patterns like 'class LegacyChannelWrapper', 'LegacyChannelWrapper(', etc.\n        assert len(references) > 0, f\"find_all_references should find LegacyChannelWrapper. Found: {references}\"\n        assert any('legacy_code.py' in file_path for file_path in references.keys()), \\\n            f\"legacy_code.py should be in references. Found: {list(references.keys())}\"\n\n\nclass TestRemovalReadiness:\n    \"\"\"Test removal readiness verification.\"\"\"\n    \n    @pytest.mark.unit\n    def test_verify_removal_readiness_ready(self, demo_project_root):\n        \"\"\"Test that items with no active code references are ready.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with a non-existent item (should be ready)\n        verification = analyzer.verify_removal_readiness('NonExistentItem12345')\n        \n        # Should be ready (no references found)\n        assert verification['ready_for_removal'] is True\n        assert len(verification['categorized']['active_code']) == 0\n    \n    @pytest.mark.unit\n    def test_verify_removal_readiness_not_ready(self, demo_project_root):\n        \"\"\"Test that items with active code references are not ready.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with LegacyChannelWrapper which exists in legacy_code.py\n        verification = analyzer.verify_removal_readiness('LegacyChannelWrapper')\n        \n        # Should not be ready (has references)\n        # Note: May be ready if only in legacy_code.py which might be considered legacy itself\n        assert 'ready_for_removal' in verification\n        assert 'references' in verification\n        assert 'recommendations' in verification\n\n\nclass TestCleanupOperations:\n    \"\"\"Test cleanup operations (safe, using copies).\"\"\"\n    \n    @pytest.mark.unit\n    def test_cleanup_legacy_references_dry_run(self, temp_project_copy):\n        \"\"\"Test that dry-run reports planned changes without modifying files.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(temp_project_copy))\n        fixer = LegacyReferenceFixer(str(temp_project_copy))\n        \n        # Verify legacy_code.py exists in the copied project\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        assert legacy_file.exists(), f\"legacy_code.py should exist in {temp_project_copy}\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), f\"legacy_code.py should not be skipped\"\n        \n        # Scan for legacy references\n        findings = analyzer.scan_for_legacy_references()\n        \n        # Check if we have any findings\n        has_findings = any(len(files) > 0 for files in findings.values())\n        assert has_findings, f\"No legacy references found. Findings: {dict(findings)}\"\n        \n        # Run cleanup in dry-run mode\n        cleanup_results = fixer.cleanup_legacy_references(findings, dry_run=True)\n        \n        # Should report what would be changed (structure may vary)\n        # The results should be a dict with some indication of what would change\n        assert isinstance(cleanup_results, dict), f\"Expected dict, got {type(cleanup_results)}\"\n        # May have keys like 'files_would_update', 'changes', 'files_updated', etc.\n        assert len(cleanup_results) > 0, \"Cleanup results should not be empty\"\n        \n        # Verify files were NOT actually modified\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        if legacy_file.exists():\n            original_content = legacy_file.read_text(encoding='utf-8')\n            # Should still contain legacy markers\n            assert 'LEGACY COMPATIBILITY' in original_content\n    \n    @pytest.mark.unit\n    def test_cleanup_legacy_references_actual_cleanup(self, temp_project_copy):\n        \"\"\"Test that actual cleanup modifies files correctly.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(temp_project_copy))\n        fixer = LegacyReferenceFixer(str(temp_project_copy))\n        \n        # Verify legacy_code.py exists in the copied project\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        assert legacy_file.exists(), f\"legacy_code.py should exist in {temp_project_copy}\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), f\"legacy_code.py should not be skipped\"\n        \n        # Scan for legacy references\n        findings = analyzer.scan_for_legacy_references()\n        \n        # Check if we have any findings (findings is dict of pattern_type -> list of (file_path, content, matches))\n        has_findings = any(len(files) > 0 for files in findings.values())\n        assert has_findings, f\"No legacy references found. Findings: {dict(findings)}\"\n        \n        # Run cleanup in actual mode (not dry-run)\n        cleanup_results = fixer.cleanup_legacy_references(findings, dry_run=False)\n        \n        # Should return a dict with results structure\n        assert isinstance(cleanup_results, dict)\n        # The results dict should have expected keys (may be empty lists if no changes made)\n        assert 'files_updated' in cleanup_results or 'changes' in cleanup_results or 'errors' in cleanup_results or 'files_would_update' in cleanup_results\n        \n        # Note: Actual cleanup may modify files, but we're using a copy so it's safe\n\n\nclass TestReportGeneration:\n    \"\"\"Test report generation.\"\"\"\n    \n    @pytest.mark.unit\n    def test_generate_cleanup_report_structure(self, demo_project_root):\n        \"\"\"Test that report has expected structure.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        report_gen = LegacyReferenceReportGenerator(str(demo_project_root))\n        \n        findings = analyzer.scan_for_legacy_references()\n        report = report_gen.generate_cleanup_report(findings)\n        \n        # Should have expected sections\n        assert '# Legacy Reference Cleanup Report' in report\n        assert '## Summary' in report or 'Summary' in report\n\n\nclass TestReplacementMappings:\n    \"\"\"Test replacement mappings.\"\"\"\n    \n    @pytest.mark.unit\n    def test_get_replacement_mappings(self, demo_project_root):\n        \"\"\"Test that replacement mappings work correctly.\"\"\"\n        fixer = LegacyReferenceFixer(str(demo_project_root))\n        \n        # Test various replacements\n        test_cases = [\n            ('bot/', 'communication/'),\n            ('from bot.', 'from communication.'),\n            ('import bot.', 'import communication.'),\n        ]\n        \n        for original, expected_start in test_cases:\n            replacement = fixer.get_replacement(original)\n            # Should start with expected replacement\n            assert replacement.startswith(expected_start) or original not in fixer.replacement_mappings\n\n",
          [
            {
              "pattern": "bot/",
              "match": "bot/",
              "line": 236,
              "line_content": "('bot/', 'communication/'),",
              "start": 10510,
              "end": 10514
            },
            {
              "pattern": "from\\s+bot\\.",
              "match": "from bot.",
              "line": 237,
              "line_content": "('from bot.', 'from communication.'),",
              "start": 10550,
              "end": 10559
            },
            {
              "pattern": "import\\s+bot\\.",
              "match": "import bot.",
              "line": 238,
              "line_content": "('import bot.', 'import communication.'),",
              "start": 10600,
              "end": 10611
            }
          ]
        ],
        [
          "tests\\development_tools\\test_path_drift_detection.py",
          "#!/usr/bin/env python3\n\"\"\"\nTest path drift detection functionality.\n\nThis test verifies that path drift detection correctly identifies\ndocumentation references to files that don't exist.\n\"\"\"\n\nimport pytest\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\n# Import helper from conftest\nfrom tests.development_tools.conftest import load_development_tools_module\n\n# Load the module using the helper\npath_drift_module = load_development_tools_module(\"docs.analyze_path_drift\")\nPathDriftAnalyzer = path_drift_module.PathDriftAnalyzer\n\n\nclass TestPathDriftDetection:\n    \"\"\"Test path drift detection.\"\"\"\n    \n    def test_path_drift_detects_missing_file(self, tmp_path):\n        \"\"\"Test that path drift detection finds references to non-existent files.\"\"\"\n        # Create a temporary project structure\n        project_dir = tmp_path / \"test_project\"\n        project_dir.mkdir()\n        \n        # Create a documentation file with a reference to a non-existent file\n        docs_dir = project_dir / \"docs\"\n        docs_dir.mkdir()\n        \n        doc_file = docs_dir / \"README.md\"\n        # Write content without leading spaces to avoid issues with path extraction\n        doc_file.write_text(\n            \"# Test Documentation\\n\\n\"\n            \"This file references a non-existent file: `core/nonexistent_module.py`\\n\\n\"\n            \"Also references: `tests/missing_test.py`\\n\"\n        )\n        \n        # Create analyzer with cache disabled for testing\n        analyzer = PathDriftAnalyzer(project_root=str(project_dir), use_cache=False)\n        \n        # Run path drift check\n        results = analyzer.check_path_drift()\n\n        # Verify that the documentation file is flagged\n        # Normalize path separators for cross-platform compatibility\n        doc_file_str = str(doc_file.relative_to(project_dir)).replace('\\\\', '/')\n        doc_file_win = str(doc_file.relative_to(project_dir))\n        # Check both normalized and original path formats\n        found = doc_file_str in results or doc_file_win in results\n        doc_paths = analyzer.scan_documentation_paths()\n        assert found, f\"Expected {doc_file_str} (or Windows path) to be in drift results. Got: {list(results.keys())}. Doc paths: {dict(doc_paths)}\"\n\n        # Get the key that was actually used (could be either format)\n        result_key = doc_file_str if doc_file_str in results else doc_file_win\n        issues = results[result_key]\n        assert len(issues) > 0, \"Expected at least one path drift issue\"\n        \n        # Check that the non-existent files are mentioned\n        issue_text = ' '.join(issues)\n        assert 'nonexistent_module.py' in issue_text or 'missing_test.py' in issue_text, \\\n            f\"Expected non-existent file to be mentioned in issues: {issues}\"\n    \n    def test_path_drift_ignores_existing_files(self, tmp_path):\n        \"\"\"Test that path drift detection doesn't flag existing files.\"\"\"\n        # Create a temporary project structure\n        project_dir = tmp_path / \"test_project\"\n        project_dir.mkdir()\n        \n        # Create actual files\n        core_dir = project_dir / \"core\"\n        core_dir.mkdir()\n        existing_file = core_dir / \"existing_module.py\"\n        existing_file.write_text(\"# Existing module\")\n        \n        # Create documentation that references the existing file\n        docs_dir = project_dir / \"docs\"\n        docs_dir.mkdir()\n        \n        doc_file = docs_dir / \"README.md\"\n        doc_file.write_text(f\"\"\"\n# Test Documentation\n\nThis file references an existing file: `core/existing_module.py`\n\"\"\")\n        \n        # Create analyzer\n        analyzer = PathDriftAnalyzer(project_root=str(project_dir))\n        \n        # Run path drift check\n        results = analyzer.check_path_drift()\n        \n        # Verify that the documentation file is NOT flagged (or flagged for other reasons only)\n        doc_file_str = str(doc_file.relative_to(project_dir))\n        if doc_file_str in results:\n            # If it's flagged, make sure it's not for the existing file\n            issues = results[doc_file_str]\n            issue_text = ' '.join(issues)\n            assert 'existing_module.py' not in issue_text, \\\n                f\"Existing file should not be flagged: {issues}\"\n    \n    def test_path_drift_with_legacy_documentation(self, tmp_path):\n        \"\"\"Test that path drift detection skips legacy documentation files.\"\"\"\n        # Create a temporary project structure\n        project_dir = tmp_path / \"test_project\"\n        project_dir.mkdir()\n        \n        # Create legacy documentation file\n        dev_docs_dir = project_dir / \"development_docs\"\n        dev_docs_dir.mkdir(parents=True)\n        \n        legacy_file = dev_docs_dir / \"LEGACY_REFERENCE_REPORT.md\"\n        legacy_file.write_text(\"\"\"\n# Legacy Reference Report\n\nThis file intentionally references old paths:\n- `bot/old_module.py` (legacy path)\n- `old_directory/file.py` (historical reference)\n\"\"\")\n        \n        # Create analyzer\n        analyzer = PathDriftAnalyzer(project_root=str(project_dir))\n        \n        # Run path drift check\n        results = analyzer.check_path_drift()\n        \n        # Verify that legacy documentation is skipped\n        legacy_file_str = str(legacy_file.relative_to(project_dir))\n        # Legacy files should be skipped, so they shouldn't appear in results\n        # (or if they do, it should be for non-legacy reasons)\n        if legacy_file_str in results:\n            # If it appears, verify it's not for the legacy paths\n            issues = results[legacy_file_str]\n            issue_text = ' '.join(issues)\n            # Legacy paths should be filtered out\n            assert 'old_module.py' not in issue_text or 'old_directory' not in issue_text, \\\n                f\"Legacy paths should be filtered: {issues}\"\n\n",
          [
            {
              "pattern": "bot/",
              "match": "bot/",
              "line": 121,
              "line_content": "- `bot/old_module.py` (legacy path)",
              "start": 4841,
              "end": 4845
            }
          ]
        ],
        [
          "tests\\fixtures\\development_tools_demo\\legacy_code.py",
          "\"\"\"\nLegacy code module for testing legacy reference cleanup.\n\nThis module contains legacy patterns that should be detected and cleaned up.\n\"\"\"\n\n# LEGACY COMPATIBILITY: This function is kept for backward compatibility\ndef legacy_function():\n    \"\"\"Legacy function that should be detected.\"\"\"\n    pass\n\n\n# LEGACY COMPATIBILITY: Old import pattern\n# Note: This is commented out to avoid import errors, but the pattern is still detectable\n# from bot.communication import old_module  # noqa: F401\n\n\ndef uses_legacy_pattern():\n    \"\"\"Function that uses legacy patterns.\"\"\"\n    # Reference to old bot directory\n    old_path = \"bot/communication/old_file.py\"\n    return old_path\n\n\nclass LegacyChannelWrapper:\n    \"\"\"Legacy wrapper class.\"\"\"\n    pass\n\n\ndef _create_legacy_channel_access():\n    \"\"\"Legacy channel access function.\"\"\"\n    pass\n\n",
          [
            {
              "pattern": "bot/",
              "match": "bot/",
              "line": 21,
              "line_content": "old_path = \"bot/communication/old_file.py\"",
              "start": 620,
              "end": 624
            },
            {
              "pattern": "from\\s+bot\\.",
              "match": "from bot.",
              "line": 15,
              "line_content": "# from bot.communication import old_module  # noqa: F401",
              "start": 437,
              "end": 446
            }
          ]
        ]
      ],
      "deprecated_functions": [
        [
          "tests\\development_tools\\test_legacy_reference_cleanup.py",
          "\"\"\"\nTests for fix_legacy_references.py.\n\nTests scanning, verification, and safe cleanup operations.\n\"\"\"\n\nimport pytest\nimport sys\nfrom pathlib import Path\n\n# Import helper from conftest\nfrom tests.development_tools.conftest import load_development_tools_module\n\n# Load the modules using the helper\ncleanup_module = load_development_tools_module(\"fix_legacy_references\")\nanalyzer_module = load_development_tools_module(\"analyze_legacy_references\")\nreport_module = load_development_tools_module(\"generate_legacy_reference_report\")\n\nLegacyReferenceFixer = cleanup_module.LegacyReferenceFixer\nLegacyReferenceAnalyzer = analyzer_module.LegacyReferenceAnalyzer\nLegacyReferenceReportGenerator = report_module.LegacyReferenceReportGenerator\n\n\nclass TestLegacyScanning:\n    \"\"\"Test legacy reference scanning.\"\"\"\n    \n    @pytest.mark.unit\n    def test_scan_for_legacy_references_finds_markers(self, demo_project_root):\n        \"\"\"Test that legacy markers are found.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        findings = analyzer.scan_for_legacy_references()\n        \n        # Should find legacy compatibility markers in legacy_code.py\n        if 'legacy_compatibility_markers' in findings:\n            legacy_files = [file_path for file_path, _, _ in findings['legacy_compatibility_markers']]\n            assert any('legacy_code.py' in str(f) for f in legacy_files)\n    \n    @pytest.mark.unit\n    def test_scan_for_legacy_references_respects_preserve_files(self, demo_project_root):\n        \"\"\"Test that preserved files are skipped.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Add a preserve pattern that matches our demo project\n        original_preserve = analyzer.preserve_files\n        analyzer.preserve_files = analyzer.preserve_files | {'README.md'}\n        \n        findings = analyzer.scan_for_legacy_references()\n        \n        # README.md should not appear in findings\n        for pattern_type, files in findings.items():\n            for file_path, _, _ in files:\n                assert 'README.md' not in str(file_path)\n        \n        analyzer.preserve_files = original_preserve\n    \n    @pytest.mark.unit\n    def test_should_skip_file_exclusions(self, demo_project_root):\n        \"\"\"Test that excluded files are skipped.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with a file that should be excluded\n        excluded_file = demo_project_root / \"__pycache__\" / \"test.pyc\"\n        excluded_file.parent.mkdir(exist_ok=True)\n        excluded_file.write_bytes(b\"test\")\n        \n        should_skip = analyzer.should_skip_file(excluded_file)\n        assert should_skip is True\n        \n        # Clean up - remove file and directory if empty\n        excluded_file.unlink()\n        try:\n            excluded_file.parent.rmdir()\n        except OSError:\n            # Directory not empty, that's okay - just remove our test file\n            pass\n\n\nclass TestReferenceFinding:\n    \"\"\"Test finding specific legacy references.\"\"\"\n    \n    @pytest.mark.unit\n    def test_find_all_references_specific_item(self, demo_project_root):\n        \"\"\"Test that specific legacy items are found.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Verify the legacy file exists\n        legacy_file = demo_project_root / \"legacy_code.py\"\n        assert legacy_file.exists(), \"legacy_code.py should exist in demo project\"\n        \n        # Verify the item exists in the file\n        content = legacy_file.read_text(encoding='utf-8')\n        assert 'LegacyChannelWrapper' in content, \"LegacyChannelWrapper should exist in legacy_code.py\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), \"legacy_code.py should not be skipped\"\n        \n        # Find references to LegacyChannelWrapper\n        # Note: find_all_references searches for the item as a pattern in files\n        references = analyzer.find_all_references('LegacyChannelWrapper')\n        \n        # The function should find the class definition\n        # It searches for patterns like 'class LegacyChannelWrapper', 'LegacyChannelWrapper(', etc.\n        assert len(references) > 0, f\"find_all_references should find LegacyChannelWrapper. Found: {references}\"\n        assert any('legacy_code.py' in file_path for file_path in references.keys()), \\\n            f\"legacy_code.py should be in references. Found: {list(references.keys())}\"\n\n\nclass TestRemovalReadiness:\n    \"\"\"Test removal readiness verification.\"\"\"\n    \n    @pytest.mark.unit\n    def test_verify_removal_readiness_ready(self, demo_project_root):\n        \"\"\"Test that items with no active code references are ready.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with a non-existent item (should be ready)\n        verification = analyzer.verify_removal_readiness('NonExistentItem12345')\n        \n        # Should be ready (no references found)\n        assert verification['ready_for_removal'] is True\n        assert len(verification['categorized']['active_code']) == 0\n    \n    @pytest.mark.unit\n    def test_verify_removal_readiness_not_ready(self, demo_project_root):\n        \"\"\"Test that items with active code references are not ready.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        \n        # Test with LegacyChannelWrapper which exists in legacy_code.py\n        verification = analyzer.verify_removal_readiness('LegacyChannelWrapper')\n        \n        # Should not be ready (has references)\n        # Note: May be ready if only in legacy_code.py which might be considered legacy itself\n        assert 'ready_for_removal' in verification\n        assert 'references' in verification\n        assert 'recommendations' in verification\n\n\nclass TestCleanupOperations:\n    \"\"\"Test cleanup operations (safe, using copies).\"\"\"\n    \n    @pytest.mark.unit\n    def test_cleanup_legacy_references_dry_run(self, temp_project_copy):\n        \"\"\"Test that dry-run reports planned changes without modifying files.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(temp_project_copy))\n        fixer = LegacyReferenceFixer(str(temp_project_copy))\n        \n        # Verify legacy_code.py exists in the copied project\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        assert legacy_file.exists(), f\"legacy_code.py should exist in {temp_project_copy}\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), f\"legacy_code.py should not be skipped\"\n        \n        # Scan for legacy references\n        findings = analyzer.scan_for_legacy_references()\n        \n        # Check if we have any findings\n        has_findings = any(len(files) > 0 for files in findings.values())\n        assert has_findings, f\"No legacy references found. Findings: {dict(findings)}\"\n        \n        # Run cleanup in dry-run mode\n        cleanup_results = fixer.cleanup_legacy_references(findings, dry_run=True)\n        \n        # Should report what would be changed (structure may vary)\n        # The results should be a dict with some indication of what would change\n        assert isinstance(cleanup_results, dict), f\"Expected dict, got {type(cleanup_results)}\"\n        # May have keys like 'files_would_update', 'changes', 'files_updated', etc.\n        assert len(cleanup_results) > 0, \"Cleanup results should not be empty\"\n        \n        # Verify files were NOT actually modified\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        if legacy_file.exists():\n            original_content = legacy_file.read_text(encoding='utf-8')\n            # Should still contain legacy markers\n            assert 'LEGACY COMPATIBILITY' in original_content\n    \n    @pytest.mark.unit\n    def test_cleanup_legacy_references_actual_cleanup(self, temp_project_copy):\n        \"\"\"Test that actual cleanup modifies files correctly.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(temp_project_copy))\n        fixer = LegacyReferenceFixer(str(temp_project_copy))\n        \n        # Verify legacy_code.py exists in the copied project\n        legacy_file = temp_project_copy / \"legacy_code.py\"\n        assert legacy_file.exists(), f\"legacy_code.py should exist in {temp_project_copy}\"\n        \n        # Verify the file is not being skipped\n        assert not analyzer.should_skip_file(legacy_file), f\"legacy_code.py should not be skipped\"\n        \n        # Scan for legacy references\n        findings = analyzer.scan_for_legacy_references()\n        \n        # Check if we have any findings (findings is dict of pattern_type -> list of (file_path, content, matches))\n        has_findings = any(len(files) > 0 for files in findings.values())\n        assert has_findings, f\"No legacy references found. Findings: {dict(findings)}\"\n        \n        # Run cleanup in actual mode (not dry-run)\n        cleanup_results = fixer.cleanup_legacy_references(findings, dry_run=False)\n        \n        # Should return a dict with results structure\n        assert isinstance(cleanup_results, dict)\n        # The results dict should have expected keys (may be empty lists if no changes made)\n        assert 'files_updated' in cleanup_results or 'changes' in cleanup_results or 'errors' in cleanup_results or 'files_would_update' in cleanup_results\n        \n        # Note: Actual cleanup may modify files, but we're using a copy so it's safe\n\n\nclass TestReportGeneration:\n    \"\"\"Test report generation.\"\"\"\n    \n    @pytest.mark.unit\n    def test_generate_cleanup_report_structure(self, demo_project_root):\n        \"\"\"Test that report has expected structure.\"\"\"\n        analyzer = LegacyReferenceAnalyzer(str(demo_project_root))\n        report_gen = LegacyReferenceReportGenerator(str(demo_project_root))\n        \n        findings = analyzer.scan_for_legacy_references()\n        report = report_gen.generate_cleanup_report(findings)\n        \n        # Should have expected sections\n        assert '# Legacy Reference Cleanup Report' in report\n        assert '## Summary' in report or 'Summary' in report\n\n\nclass TestReplacementMappings:\n    \"\"\"Test replacement mappings.\"\"\"\n    \n    @pytest.mark.unit\n    def test_get_replacement_mappings(self, demo_project_root):\n        \"\"\"Test that replacement mappings work correctly.\"\"\"\n        fixer = LegacyReferenceFixer(str(demo_project_root))\n        \n        # Test various replacements\n        test_cases = [\n            ('bot/', 'communication/'),\n            ('from bot.', 'from communication.'),\n            ('import bot.', 'import communication.'),\n        ]\n        \n        for original, expected_start in test_cases:\n            replacement = fixer.get_replacement(original)\n            # Should start with expected replacement\n            assert replacement.startswith(expected_start) or original not in fixer.replacement_mappings\n\n",
          [
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 93,
              "line_content": "assert 'LegacyChannelWrapper' in content, \"LegacyChannelWrapper should exist in legacy_code.py\"",
              "start": 3609,
              "end": 3629
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 93,
              "line_content": "assert 'LegacyChannelWrapper' in content, \"LegacyChannelWrapper should exist in legacy_code.py\"",
              "start": 3644,
              "end": 3664
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 98,
              "line_content": "# Find references to LegacyChannelWrapper",
              "start": 3889,
              "end": 3909
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 100,
              "line_content": "references = analyzer.find_all_references('LegacyChannelWrapper')",
              "start": 4041,
              "end": 4061
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 103,
              "line_content": "# It searches for patterns like 'class LegacyChannelWrapper', 'LegacyChannelWrapper(', etc.",
              "start": 4176,
              "end": 4196
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 103,
              "line_content": "# It searches for patterns like 'class LegacyChannelWrapper', 'LegacyChannelWrapper(', etc.",
              "start": 4200,
              "end": 4220
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 104,
              "line_content": "assert len(references) > 0, f\"find_all_references should find LegacyChannelWrapper. Found: {references}\"",
              "start": 4299,
              "end": 4319
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 129,
              "line_content": "# Test with LegacyChannelWrapper which exists in legacy_code.py",
              "start": 5431,
              "end": 5451
            },
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 130,
              "line_content": "verification = analyzer.verify_removal_readiness('LegacyChannelWrapper')",
              "start": 5541,
              "end": 5561
            }
          ]
        ],
        [
          "tests\\fixtures\\development_tools_demo\\legacy_code.py",
          "\"\"\"\nLegacy code module for testing legacy reference cleanup.\n\nThis module contains legacy patterns that should be detected and cleaned up.\n\"\"\"\n\n# LEGACY COMPATIBILITY: This function is kept for backward compatibility\ndef legacy_function():\n    \"\"\"Legacy function that should be detected.\"\"\"\n    pass\n\n\n# LEGACY COMPATIBILITY: Old import pattern\n# Note: This is commented out to avoid import errors, but the pattern is still detectable\n# from bot.communication import old_module  # noqa: F401\n\n\ndef uses_legacy_pattern():\n    \"\"\"Function that uses legacy patterns.\"\"\"\n    # Reference to old bot directory\n    old_path = \"bot/communication/old_file.py\"\n    return old_path\n\n\nclass LegacyChannelWrapper:\n    \"\"\"Legacy wrapper class.\"\"\"\n    pass\n\n\ndef _create_legacy_channel_access():\n    \"\"\"Legacy channel access function.\"\"\"\n    pass\n\n",
          [
            {
              "pattern": "LegacyChannelWrapper",
              "match": "LegacyChannelWrapper",
              "line": 25,
              "line_content": "class LegacyChannelWrapper:",
              "start": 679,
              "end": 699
            },
            {
              "pattern": "_create_legacy_channel_access\\(",
              "match": "_create_legacy_channel_access(",
              "line": 30,
              "line_content": "def _create_legacy_channel_access():",
              "start": 748,
              "end": 778
            }
          ]
        ]
      ],
      "old_import_paths": [
        [
          "tests\\fixtures\\development_tools_demo\\legacy_code.py",
          "\"\"\"\nLegacy code module for testing legacy reference cleanup.\n\nThis module contains legacy patterns that should be detected and cleaned up.\n\"\"\"\n\n# LEGACY COMPATIBILITY: This function is kept for backward compatibility\ndef legacy_function():\n    \"\"\"Legacy function that should be detected.\"\"\"\n    pass\n\n\n# LEGACY COMPATIBILITY: Old import pattern\n# Note: This is commented out to avoid import errors, but the pattern is still detectable\n# from bot.communication import old_module  # noqa: F401\n\n\ndef uses_legacy_pattern():\n    \"\"\"Function that uses legacy patterns.\"\"\"\n    # Reference to old bot directory\n    old_path = \"bot/communication/old_file.py\"\n    return old_path\n\n\nclass LegacyChannelWrapper:\n    \"\"\"Legacy wrapper class.\"\"\"\n    pass\n\n\ndef _create_legacy_channel_access():\n    \"\"\"Legacy channel access function.\"\"\"\n    pass\n\n",
          [
            {
              "pattern": "from\\s+bot\\.communication",
              "match": "from bot.communication",
              "line": 15,
              "line_content": "# from bot.communication import old_module  # noqa: F401",
              "start": 437,
              "end": 459
            }
          ]
        ]
      ],
      "historical_references": [
        [
          "tests\\fixtures\\development_tools_demo\\legacy_code.py",
          "\"\"\"\nLegacy code module for testing legacy reference cleanup.\n\nThis module contains legacy patterns that should be detected and cleaned up.\n\"\"\"\n\n# LEGACY COMPATIBILITY: This function is kept for backward compatibility\ndef legacy_function():\n    \"\"\"Legacy function that should be detected.\"\"\"\n    pass\n\n\n# LEGACY COMPATIBILITY: Old import pattern\n# Note: This is commented out to avoid import errors, but the pattern is still detectable\n# from bot.communication import old_module  # noqa: F401\n\n\ndef uses_legacy_pattern():\n    \"\"\"Function that uses legacy patterns.\"\"\"\n    # Reference to old bot directory\n    old_path = \"bot/communication/old_file.py\"\n    return old_path\n\n\nclass LegacyChannelWrapper:\n    \"\"\"Legacy wrapper class.\"\"\"\n    pass\n\n\ndef _create_legacy_channel_access():\n    \"\"\"Legacy channel access function.\"\"\"\n    pass\n\n",
          [
            {
              "pattern": "bot/communication",
              "match": "bot/communication",
              "line": 21,
              "line_content": "old_path = \"bot/communication/old_file.py\"",
              "start": 620,
              "end": 637
            }
          ]
        ]
      ]
    },
    "files_with_issues": 11,
    "legacy_markers": 35,
    "report_path": "development_docs/LEGACY_REFERENCE_REPORT.md"
  }
}