"""
Message Formatter Tests

Tests for communication/communication_channels/base/message_formatter.py:
- TextMessageFormatter functionality
- EmailMessageFormatter functionality
- Factory function behavior
- Error handling and edge cases
"""

import pytest
from unittest.mock import patch, MagicMock

from communication.communication_channels.base.message_formatter import (
    TextMessageFormatter,
    EmailMessageFormatter,
    get_message_formatter
)
from core.error_handling import DataError


class TestTextMessageFormatter:
    """Test TextMessageFormatter functionality"""
    
    @pytest.fixture
    def formatter(self):
        """Create a TextMessageFormatter instance"""
        return TextMessageFormatter()
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_without_rich_data(self, formatter):
        """Test: format_message returns plain message when no rich data provided"""
        # Arrange
        message = "Hello, world!"
        
        # Act
        result = formatter.format_message(message)
        
        # Assert
        assert result == message, "Should return plain message when no rich data"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_empty_message(self, formatter):
        """Test: format_message handles empty message gracefully"""
        # Arrange
        message = ""
        
        # Act
        result = formatter.format_message(message)
        
        # Assert
        assert result == "", "Should return empty string for empty message"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_title(self, formatter):
        """Test: format_message adds title from rich data"""
        # Arrange
        message = "This is the message body"
        rich_data = {"title": "Important Notice"}
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "**Important Notice**" in result, "Should include title in bold"
        assert message in result, "Should include message body"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_fields(self, formatter):
        """Test: format_message adds fields from rich data"""
        # Arrange
        message = "Task information"
        rich_data = {
            "fields": [
                {"name": "Priority", "value": "High"},
                {"name": "Due Date", "value": "2025-12-01"}
            ]
        }
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "**Priority:** High" in result, "Should include first field"
        assert "**Due Date:** 2025-12-01" in result, "Should include second field"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_footer(self, formatter):
        """Test: format_message adds footer from rich data"""
        # Arrange
        message = "Main message"
        rich_data = {"footer": "Generated by MHM"}
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "---" in result, "Should include footer separator"
        assert "Generated by MHM" in result, "Should include footer text"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_all_rich_data(self, formatter):
        """Test: format_message combines title, fields, and footer"""
        # Arrange
        message = "Complete message"
        rich_data = {
            "title": "Task Update",
            "fields": [{"name": "Status", "value": "Completed"}],
            "footer": "Task Management System"
        }
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "**Task Update**" in result, "Should include title"
        assert "**Status:** Completed" in result, "Should include field"
        assert "Task Management System" in result, "Should include footer"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_invalid_fields(self, formatter):
        """Test: format_message handles invalid field format gracefully"""
        # Arrange
        message = "Test message"
        rich_data = {"fields": "not a list"}
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert message in result, "Should return message even with invalid fields"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_missing_field_values(self, formatter):
        """Test: format_message handles missing field values"""
        # Arrange
        message = "Test message"
        rich_data = {
            "fields": [
                {"name": "Field1"},  # Missing value
                {"value": "Value2"}  # Missing name
            ]
        }
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "**Field1:**" in result, "Should handle missing value"
        assert "**:** Value2" in result, "Should handle missing name"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_rich_content_without_rich_data(self, formatter):
        """Test: create_rich_content returns message when no rich data"""
        # Arrange
        message = "Simple message"
        
        # Act
        result = formatter.create_rich_content(message, {})
        
        # Assert
        assert result == message, "Should return message when no rich data"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_rich_content_with_rich_data(self, formatter):
        """Test: create_rich_content formats message with rich data"""
        # Arrange
        message = "Message body"
        rich_data = {"title": "Title"}
        
        # Act
        result = formatter.create_rich_content(message, rich_data)
        
        # Assert
        assert "**Title**" in result, "Should format with rich data"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_with_suggestions(self, formatter):
        """Test: create_interactive_elements formats suggestions as numbered list"""
        # Arrange
        suggestions = ["Option 1", "Option 2", "Option 3"]
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert "**Suggestions:**" in result, "Should include suggestions header"
        assert "1. Option 1" in result, "Should include first suggestion"
        assert "2. Option 2" in result, "Should include second suggestion"
        assert "3. Option 3" in result, "Should include third suggestion"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_with_empty_list(self, formatter):
        """Test: create_interactive_elements handles empty suggestions"""
        # Arrange
        suggestions = []
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert result == "", "Should return empty string for empty suggestions"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_limits_to_five(self, formatter):
        """Test: create_interactive_elements limits suggestions to 5"""
        # Arrange
        suggestions = [f"Option {i}" for i in range(10)]
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert "5. Option 4" in result, "Should include fifth suggestion"
        assert "6. Option 5" not in result, "Should not include sixth suggestion"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_skips_empty_suggestions(self, formatter):
        """Test: create_interactive_elements skips empty suggestions"""
        # Arrange
        suggestions = ["Valid", "", "Also Valid", None]
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert "1. Valid" in result, "Should include valid suggestion"
        assert "3. Also Valid" in result, "Should include second valid suggestion (numbered by position)"
        assert "2. " not in result, "Should not include empty suggestion"
        assert "4. " not in result, "Should not include None suggestion"


class TestEmailMessageFormatter:
    """Test EmailMessageFormatter functionality"""
    
    @pytest.fixture
    def formatter(self):
        """Create an EmailMessageFormatter instance"""
        return EmailMessageFormatter()
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_without_rich_data(self, formatter):
        """Test: format_message returns plain message when no rich data"""
        # Arrange
        message = "Hello, world!"
        
        # Act
        result = formatter.format_message(message)
        
        # Assert
        assert result == message, "Should return plain message when no rich data"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_title(self, formatter):
        """Test: format_message adds HTML title from rich data"""
        # Arrange
        message = "This is the message body"
        rich_data = {"title": "Important Notice"}
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "<h2>Important Notice</h2>" in result, "Should include HTML title"
        assert message in result, "Should include message body"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_fields(self, formatter):
        """Test: format_message adds HTML fields from rich data"""
        # Arrange
        message = "Task information"
        rich_data = {
            "fields": [
                {"name": "Priority", "value": "High"},
                {"name": "Due Date", "value": "2025-12-01"}
            ]
        }
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "<strong>Priority:</strong> High<br>" in result, "Should include first field"
        assert "<strong>Due Date:</strong> 2025-12-01<br>" in result, "Should include second field"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_with_footer(self, formatter):
        """Test: format_message adds HTML footer from rich data"""
        # Arrange
        message = "Main message"
        rich_data = {"footer": "Generated by MHM"}
        
        # Act
        result = formatter.format_message(message, rich_data)
        
        # Assert
        assert "<hr>" in result, "Should include HTML footer separator"
        assert "Generated by MHM" in result, "Should include footer text"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_rich_content_with_rich_data(self, formatter):
        """Test: create_rich_content formats message with rich data"""
        # Arrange
        message = "Message body"
        rich_data = {"title": "Title"}
        
        # Act
        result = formatter.create_rich_content(message, rich_data)
        
        # Assert
        assert "<h2>Title</h2>" in result, "Should format with rich data"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_with_suggestions(self, formatter):
        """Test: create_interactive_elements formats suggestions as HTML bullet points"""
        # Arrange
        suggestions = ["Option 1", "Option 2", "Option 3"]
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert "<strong>Quick Actions:</strong>" in result, "Should include header"
        assert "Option 1" in result, "Should include first suggestion"
        assert "Option 2" in result, "Should include second suggestion"
        assert "â€¢" in result or "<br>" in result, "Should include HTML formatting"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_limits_to_five(self, formatter):
        """Test: create_interactive_elements limits suggestions to 5"""
        # Arrange
        suggestions = [f"Option {i}" for i in range(10)]
        
        # Act
        result = formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert "Option 4" in result, "Should include fifth suggestion"
        assert "Option 5" not in result, "Should not include sixth suggestion"


class TestMessageFormatterFactory:
    """Test get_message_formatter factory function"""
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_for_email(self):
        """Test: get_message_formatter returns EmailMessageFormatter for email"""
        # Arrange & Act
        formatter = get_message_formatter("email")
        
        # Assert
        assert isinstance(formatter, EmailMessageFormatter), "Should return EmailMessageFormatter for email"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_for_text(self):
        """Test: get_message_formatter returns TextMessageFormatter for text"""
        # Arrange & Act
        formatter = get_message_formatter("text")
        
        # Assert
        assert isinstance(formatter, TextMessageFormatter), "Should return TextMessageFormatter for text"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_for_unknown_type(self):
        """Test: get_message_formatter returns TextMessageFormatter for unknown type"""
        # Arrange & Act
        formatter = get_message_formatter("unknown")
        
        # Assert
        assert isinstance(formatter, TextMessageFormatter), "Should return TextMessageFormatter as default"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_with_empty_string(self):
        """Test: get_message_formatter returns TextMessageFormatter for empty string"""
        # Arrange & Act
        formatter = get_message_formatter("")
        
        # Assert
        assert isinstance(formatter, TextMessageFormatter), "Should return TextMessageFormatter as default"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_with_none(self):
        """Test: get_message_formatter returns TextMessageFormatter for None"""
        # Arrange & Act
        formatter = get_message_formatter(None)
        
        # Assert
        assert isinstance(formatter, TextMessageFormatter), "Should return TextMessageFormatter as default"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_case_insensitive(self):
        """Test: get_message_formatter is case insensitive"""
        # Arrange & Act
        formatter1 = get_message_formatter("EMAIL")
        formatter2 = get_message_formatter("Email")
        formatter3 = get_message_formatter("eMaIl")
        
        # Assert
        assert isinstance(formatter1, EmailMessageFormatter), "Should handle uppercase"
        assert isinstance(formatter2, EmailMessageFormatter), "Should handle mixed case"
        assert isinstance(formatter3, EmailMessageFormatter), "Should handle mixed case"


class TestMessageFormatterErrorHandling:
    """Test error handling in message formatters"""
    
    @pytest.fixture
    def text_formatter(self):
        """Create a TextMessageFormatter instance"""
        return TextMessageFormatter()
    
    @pytest.fixture
    def email_formatter(self):
        """Create an EmailMessageFormatter instance"""
        return EmailMessageFormatter()
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_handles_type_error(self, text_formatter):
        """Test: format_message handles invalid fields type gracefully"""
        # Arrange
        message = "Test message"
        rich_data = {"fields": None}  # Invalid type - not a list
        
        # Act
        result = text_formatter.format_message(message, rich_data)
        
        # Assert
        # Code checks isinstance(rich_data['fields'], list) before iterating, so None is skipped
        assert message in result, "Should return message when fields is not a list"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_format_message_handles_key_error(self, text_formatter):
        """Test: format_message handles KeyError in rich data processing"""
        # Arrange
        message = "Test message"
        rich_data = {"fields": [{}]}  # Empty dict will cause KeyError
        
        # Act
        result = text_formatter.format_message(message, rich_data)
        
        # Assert
        # Should handle KeyError and return formatted message
        assert message in result or result == "", "Should handle KeyError gracefully"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_create_interactive_elements_handles_type_error(self, text_formatter):
        """Test: create_interactive_elements handles TypeError"""
        # Arrange
        suggestions = None  # Will cause TypeError
        
        # Act
        result = text_formatter.create_interactive_elements(suggestions)
        
        # Assert
        assert result == "", "Should handle TypeError gracefully"
    
    @pytest.mark.communication
    @pytest.mark.unit
    def test_get_message_formatter_handles_exception(self):
        """Test: get_message_formatter handles exceptions and returns default"""
        # Arrange
        with patch('communication.communication_channels.base.message_formatter.EmailMessageFormatter', side_effect=Exception("Test error")):
            # Act
            formatter = get_message_formatter("email")
            
            # Assert
            assert isinstance(formatter, TextMessageFormatter), "Should return default formatter on error"

