"""
Comprehensive behavior tests for UI widgets.

Tests real behavior, user interactions, and side effects for all widgets:
- TagWidget
- TaskSettingsWidget
- CategorySelectionWidget
- ChannelSelectionWidget
- CheckinSettingsWidget
- UserProfileSettingsWidget
- PeriodRowWidget
- DynamicListField
- DynamicListContainer
"""
from tests.conftest import ensure_qt_runtime

ensure_qt_runtime()


import pytest
import json
import tempfile
import shutil
import uuid
from unittest.mock import patch, Mock, MagicMock
from datetime import datetime, time
from pathlib import Path
from PySide6.QtWidgets import QApplication, QWidget, QMessageBox, QDialog, QVBoxLayout
from PySide6.QtCore import Qt, QTimer
from PySide6.QtTest import QTest

# Do not modify sys.path; rely on package imports

from core.user_data_handlers import save_user_data, get_user_data
from core.file_operations import create_user_files, get_user_file_path
from tests.test_utilities import TestUserFactory, TestUserDataFactory
from ui.widgets.tag_widget import TagWidget
from ui.widgets.task_settings_widget import TaskSettingsWidget
from ui.widgets.category_selection_widget import CategorySelectionWidget
from ui.widgets.channel_selection_widget import ChannelSelectionWidget
from ui.widgets.checkin_settings_widget import CheckinSettingsWidget
from ui.widgets.user_profile_settings_widget import UserProfileSettingsWidget
from ui.widgets.period_row_widget import PeriodRowWidget
from ui.widgets.dynamic_list_field import DynamicListField
from ui.widgets.dynamic_list_container import DynamicListContainer

# Create QApplication instance for testing
@pytest.fixture(scope="session")
def qapp():
    """Create QApplication instance for UI testing."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app
    # Don't quit the app as it might be used by other tests

class TestTagWidgetBehavior:
    """Test TagWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create TagWidget for testing."""
        # Create test user with task focus (includes task settings with tags)
        user_id = f"test_user_tag_widget_{uuid.uuid4().hex[:8]}"
        success = TestUserFactory.create_user_with_task_focus(user_id, test_data_dir)
        assert success, f"Failed to create test user {user_id}"
        
        # Get the actual user ID (UUID) from the test data
        actual_user_id = TestUserFactory.get_test_user_id_by_internal_username(user_id, test_data_dir)
        assert actual_user_id, f"Could not find actual user ID for {user_id}"
        
        # Create widget with valid user_id
        widget = TagWidget(mode="management", parent=None, user_id=actual_user_id)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    @pytest.mark.critical
    @pytest.mark.regression
    @pytest.mark.slow
    @pytest.mark.user_management
    @pytest.mark.tasks
    @pytest.mark.checkins
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check management mode elements
        assert hasattr(widget.ui, 'lineEdit_new_tag'), "New tag input should exist"
        assert hasattr(widget.ui, 'pushButton_add_tag'), "Add tag button should exist"
        assert hasattr(widget.ui, 'listWidget_tags'), "Tags list should exist"
    
    @pytest.mark.ui
    @pytest.mark.critical
    @pytest.mark.regression
    @pytest.mark.slow
    @pytest.mark.user_management
    @pytest.mark.tasks
    @pytest.mark.checkins
    def test_tag_management_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test adding and removing tags works correctly."""
        #[OK] VERIFY REAL BEHAVIOR: Check widget has user_id set
        assert widget.user_id is not None, "Widget should have user_id set"
        # The user_id should be a UUID generated by the test utilities
        assert len(widget.user_id) > 20, "Widget should have valid UUID user_id"
        
        #[OK] VERIFY REAL BEHAVIOR: Check initial tag list
        list_widget = widget.ui.listWidget_tags
        initial_count = list_widget.count()
        
        #[OK] VERIFY REAL BEHAVIOR: Check that tags are loaded (task focus user may have default tags)
        # Note: Task focus user may not have pre-existing tags, so we just verify the widget loads correctly
        assert initial_count >= 0, "Should have zero or more tags loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: If tags exist, they should be valid
        if initial_count > 0:
            item = list_widget.item(0)
            assert item.text(), "Tag text should not be empty"
    
    @pytest.mark.ui
    @pytest.mark.critical
    @pytest.mark.regression
    @pytest.mark.slow
    @pytest.mark.user_management
    @pytest.mark.tasks
    @pytest.mark.checkins
    def test_tag_selection_mode_real_behavior(self, qapp, test_data_dir, mock_config):
        """REAL BEHAVIOR TEST: Test widget works in selection mode."""
        # Create test user with task focus (includes task settings with tags)
        user_id = f"test_user_tag_selection_{uuid.uuid4().hex[:8]}"
        success = TestUserFactory.create_user_with_task_focus(user_id, test_data_dir)
        assert success, f"Failed to create test user {user_id}"
        
        # Get the actual user ID (UUID) from the test data
        actual_user_id = TestUserFactory.get_test_user_id_by_internal_username(user_id, test_data_dir)
        assert actual_user_id, f"Could not find actual user ID for {user_id}"
        
        # Create widget in selection mode with valid user_id
        widget = TagWidget(mode="selection", parent=None, user_id=actual_user_id)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        #[OK] VERIFY REAL BEHAVIOR: Check selection mode elements
        assert hasattr(widget.ui, 'listWidget_tags'), "Tags list should exist in selection mode"
        
        # Cleanup
        widget.close()
        widget.deleteLater()

class TestTaskSettingsWidgetBehavior:
    """Test TaskSettingsWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create TaskSettingsWidget for testing."""
        # Create test user with task focus
        user_id = f"test_user_task_settings_{uuid.uuid4().hex[:8]}"
        success = TestUserFactory.create_user_with_task_focus(user_id, test_data_dir)
        assert success, f"Failed to create test user {user_id}"
        
        # Get the actual user ID (UUID) from the test data
        actual_user_id = TestUserFactory.get_test_user_id_by_internal_username(user_id, test_data_dir)
        assert actual_user_id, f"Could not find actual user ID for {user_id}"
        
        # Create widget
        widget = TaskSettingsWidget(user_id=actual_user_id, parent=None)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check task settings elements
        assert hasattr(widget.ui, 'groupBox_task_reminder_time_periods'), "Task reminder periods group should exist"
        assert hasattr(widget.ui, 'pushButton_task_reminder_add_new_period'), "Add new period button should exist"
        assert hasattr(widget, 'tag_widget'), "Tag widget should be loaded"
    
    @pytest.mark.ui
    def test_task_enablement_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test task period management works correctly."""
        #[OK] VERIFY REAL BEHAVIOR: Check initial state
        initial_period_count = len(widget.period_widgets)
        
        #[OK] VERIFY REAL BEHAVIOR: Add new period
        widget.add_new_period()
        new_period_count = len(widget.period_widgets)
        
        #[OK] VERIFY REAL BEHAVIOR: Period count should have increased
        assert new_period_count > initial_period_count, "Period count should increase when adding new period"

class TestCategorySelectionWidgetBehavior:
    """Test CategorySelectionWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create CategorySelectionWidget for testing."""
        # Create test user data
        user_id = "test_user_category_selection"
        user_data = {
            "account": {
                "username": "test_user_category_selection",
                "timezone": "America/New_York"
            },
            "preferences": {
                "categories": ["general", "health", "work"]
            }
        }
        
        # Save test user data
        user_dir = Path(test_data_dir) / "users" / user_id
        user_dir.mkdir(parents=True, exist_ok=True)
        
        with open(user_dir / "account.json", "w") as f:
            json.dump(user_data["account"], f)
        with open(user_dir / "preferences.json", "w") as f:
            json.dump(user_data["preferences"], f)
        
        # Create widget
        widget = CategorySelectionWidget(parent=None)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check category selection elements
        assert hasattr(widget.ui, 'checkBox_fun_facts'), "Fun facts checkbox should exist"
        assert hasattr(widget.ui, 'checkBox_health'), "Health checkbox should exist"
        assert hasattr(widget.ui, 'checkBox_motivational'), "Motivational checkbox should exist"

class TestChannelSelectionWidgetBehavior:
    """Test ChannelSelectionWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create ChannelSelectionWidget for testing."""
        # Create test user data
        user_id = "test_user_channel_selection"
        user_data = {
            "account": {
                "username": "test_user_channel_selection",
                "timezone": "America/New_York"
            },
            "preferences": {
                "channels": {
                    "email": {
                        "enabled": True,
                        "contact": "test@example.com"
                    },
                    "discord": {
                        "enabled": False,
                        "contact": ""
                    }
                }
            }
        }
        
        # Save test user data
        user_dir = Path(test_data_dir) / "users" / user_id
        user_dir.mkdir(parents=True, exist_ok=True)
        
        with open(user_dir / "account.json", "w") as f:
            json.dump(user_data["account"], f)
        with open(user_dir / "preferences.json", "w") as f:
            json.dump(user_data["preferences"], f)
        
        # Create widget
        widget = ChannelSelectionWidget(parent=None)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check channel selection elements
        assert hasattr(widget.ui, 'comboBox_timezone'), "Timezone combo box should exist"
        assert hasattr(widget.ui, 'radioButton_Email'), "Email radio button should exist"
        assert hasattr(widget.ui, 'radioButton_Discord'), "Discord radio button should exist"

class TestCheckinSettingsWidgetBehavior:
    """Test CheckinSettingsWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create CheckinSettingsWidget for testing."""
        # Create test user with complex check-ins
        user_id = "test_user_checkin_settings"
        success = TestUserFactory.create_user_with_complex_checkins(user_id, test_data_dir)
        assert success, f"Failed to create test user {user_id}"
        
        # Get the actual user ID (UUID) from the test data - retry in case of race conditions
        from core.user_data_handlers import get_user_id_by_identifier
        from core.user_data_manager import rebuild_user_index
        import time
        actual_user_id = None
        for attempt in range(5):
            actual_user_id = get_user_id_by_identifier(user_id) or TestUserFactory.get_test_user_id_by_internal_username(user_id, test_data_dir)
            if actual_user_id:
                break
            # Rebuild index if lookup fails (race condition fix)
            if attempt == 2:
                rebuild_user_index()
            if attempt < 4:
                time.sleep(0.1)
        assert actual_user_id, f"Could not find actual user ID for {user_id} after retries"
        
        # Create widget
        widget = CheckinSettingsWidget(user_id=actual_user_id, parent=None)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check check-in settings elements
        assert hasattr(widget.ui, 'groupBox_checkin_time_periods'), "Check-in time periods group should exist"
        assert hasattr(widget.ui, 'pushButton_add_new_checkin_time_period'), "Add new check-in period button should exist"
        assert hasattr(widget, 'period_widgets'), "Period widgets should be loaded"
    
    @pytest.mark.ui
    def test_checkin_enablement_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test check-in period management works correctly."""
        #[OK] VERIFY REAL BEHAVIOR: Check initial state
        initial_period_count = len(widget.period_widgets)
        
        #[OK] VERIFY REAL BEHAVIOR: Add new period
        widget.add_new_period()
        new_period_count = len(widget.period_widgets)
        
        #[OK] VERIFY REAL BEHAVIOR: Period count should have increased
        assert new_period_count > initial_period_count, "Period count should increase when adding new period"

class TestUserProfileSettingsWidgetBehavior:
    """Test UserProfileSettingsWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp, test_data_dir, mock_config):
        """Create UserProfileSettingsWidget for testing."""
        # Create test user with health focus (includes profile data)
        user_id = "test_user_profile_settings"
        success = TestUserFactory.create_user_with_health_focus(user_id, test_data_dir)
        assert success, f"Failed to create test user {user_id}"
        
        # Get the actual user ID (UUID) from the test data
        actual_user_id = TestUserFactory.get_test_user_id_by_internal_username(user_id, test_data_dir)
        assert actual_user_id, f"Could not find actual user ID for {user_id}"
        
        # Create widget
        widget = UserProfileSettingsWidget(user_id=actual_user_id, parent=None)
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check profile settings elements
        assert hasattr(widget.ui, 'tabWidget'), "Tab widget should exist"
        assert hasattr(widget.ui, 'lineEdit_custom_gender'), "Custom gender field should exist"
        assert hasattr(widget.ui, 'calendarWidget_date_of_birth'), "Date of birth calendar should exist"

class TestPeriodRowWidgetBehavior:
    """Test PeriodRowWidget with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp):
        """Create PeriodRowWidget for testing."""
        # Create a parent widget to hold the period row
        parent = QWidget()
        parent.setLayout(QVBoxLayout())
        
        # Create widget
        widget = PeriodRowWidget(
            period_data={
                "start_time": "09:00",
                "end_time": "10:00",
                "enabled": True,
                "questions": ["How are you feeling?"]
            },
            parent=parent
        )
        parent.layout().addWidget(widget)
        # parent.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        parent.close()
        parent.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check period row elements
        assert hasattr(widget.ui, 'comboBox_start_time_hours'), "Start time hours combo should exist"
        assert hasattr(widget.ui, 'comboBox_start_time_minutes'), "Start time minutes combo should exist"
        assert hasattr(widget.ui, 'checkBox_active'), "Active checkbox should exist"
        assert hasattr(widget.ui, 'lineEdit_time_period_name'), "Time period name field should exist"

class TestDynamicListFieldBehavior:
    """Test DynamicListField with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp):
        """Create DynamicListField for testing."""
        widget = DynamicListField(
            parent=None,
            preset_label="Test Item",
            editable=True,
            checked=False
        )
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        assert hasattr(widget, 'ui'), "Widget should have UI loaded"
        
        #[OK] VERIFY REAL BEHAVIOR: Check dynamic list elements
        assert hasattr(widget.ui, 'lineEdit_dynamic_list_field'), "Dynamic list field input should exist"
        assert hasattr(widget.ui, 'checkBox__dynamic_list_field'), "Dynamic list field checkbox should exist"
        assert hasattr(widget.ui, 'pushButton_delete_DynamicListField'), "Delete button should exist"
    
    @pytest.mark.ui
    def test_item_management_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test dynamic list field functionality."""
        #[OK] VERIFY REAL BEHAVIOR: Check initial state
        assert widget.get_text() == "Test Item", "Initial text should match preset label"
        assert not widget.is_checked(), "Initial checkbox should be unchecked"
        
        #[OK] VERIFY REAL BEHAVIOR: Set text and check
        widget.set_text("New Test Item")
        widget.set_checked(True)
        
        #[OK] VERIFY REAL BEHAVIOR: Check state changes
        assert widget.get_text() == "New Test Item", "Text should be updated"
        assert widget.is_checked(), "Checkbox should be checked"

class TestDynamicListContainerBehavior:
    """Test DynamicListContainer with real behavior verification."""
    
    @pytest.fixture
    def widget(self, qapp):
        """Create DynamicListContainer for testing."""
        widget = DynamicListContainer(
            parent=None,
            field_key="test_field"
        )
        # widget.show()  # Removed - widgets should not be shown during automated testing
        
        yield widget
        
        # Cleanup
        widget.close()
        widget.deleteLater()
    
    @pytest.mark.ui
    def test_widget_initialization_real_behavior(self, widget):
        """REAL BEHAVIOR TEST: Test widget initializes correctly with proper UI state."""
        #[OK] VERIFY INITIAL STATE: Check widget exists and is not visible during testing
        assert widget is not None, "Widget should be created"
        assert not widget.isVisible(), "Widget should not be visible during automated testing"
        # DynamicListContainer is a custom widget without a UI file
        
        #[OK] VERIFY REAL BEHAVIOR: Check container elements
        assert hasattr(widget, 'field_key'), "Field key should be set"
        assert hasattr(widget, 'rows'), "Rows list should exist"
        assert hasattr(widget, 'grid_widget'), "Grid widget should exist"
        assert hasattr(widget, 'custom_widget'), "Custom widget should exist" 
